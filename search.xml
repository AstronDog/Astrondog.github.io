<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>20240110-hexo-transplant</title>
      <link href="/2024/01/10/20240110-hexo-transplant/"/>
      <url>/2024/01/10/20240110-hexo-transplant/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="HEXO-博客移植"><a href="#HEXO-博客移植" class="headerlink" title="HEXO 博客移植"></a>HEXO 博客移植</h1><p>本文主要记载了在Ubuntu系统下移植Hexo搭建的个人网站到一台新电脑的步骤</p><h2 id="前期准备——基本环境的搭建"><a href="#前期准备——基本环境的搭建" class="headerlink" title="前期准备——基本环境的搭建"></a>前期准备——基本环境的搭建</h2><p>首先是在Ubuntu下搭建基础环境，主要是git和node.js.在Ubuntu中比较简单，直接使用apt安装</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><pre><code>sudo apt install git-core</code></pre><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>在Ubuntu上安装Node.js也比较简单，直接使用apt安装即可。</p><pre><code>sudo apt install npmsudo apt install nodejs</code></pre><h3 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h3><pre><code>sudo npm install hexo-cli -gsudo npm install hexo -g</code></pre><h2 id="准备移植"><a href="#准备移植" class="headerlink" title="准备移植"></a>准备移植</h2><h3 id="需要从原电脑复制的文件"><a href="#需要从原电脑复制的文件" class="headerlink" title="需要从原电脑复制的文件"></a>需要从原电脑复制的文件</h3><ul><li>_config.yml：站点配置</li><li>package.json：说明使用那些包</li><li>scaffolds：文章的模板</li><li>source：自己写的博客文件</li><li>themes：主题</li><li>.gitignore：限定在提交的时候哪些文件可以忽略</li></ul><h3 id="移植开始"><a href="#移植开始" class="headerlink" title="移植开始"></a>移植开始</h3><p>在新电脑中新建myblog文件夹，并将复制的文件移动到该文件夹，并在该文件夹下执行：</p><pre><code>npm installnpm install hexo-deployer-git --save</code></pre><p>然后就可以查看效果和部署了。</p><h2 id="查看效果及部署。"><a href="#查看效果及部署。" class="headerlink" title="查看效果及部署。"></a>查看效果及部署。</h2><p>运行 hexo g 生成博客。<br>运行 hexo s 查看博客。<br>打开 <a href="http://localhost:4000/%EF%BC%8C%E6%B2%A1%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AD%A5%E3%80%82">http://localhost:4000/，没问题的话，执行下一步。</a><br>执行 hexo d 推送到远程仓库部署。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leisure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker and Singularity</title>
      <link href="/2022/09/25/20220925-docker-singularity/"/>
      <url>/2022/09/25/20220925-docker-singularity/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Docker-and-Singularity"><a href="#Docker-and-Singularity" class="headerlink" title="Docker and Singularity"></a>Docker and Singularity</h1><h2 id="Docker-安装和基本配置"><a href="#Docker-安装和基本配置" class="headerlink" title="Docker 安装和基本配置"></a>Docker 安装和基本配置</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><pre><code>$ curl -fsSL test.docker.com -o get-docker.sh$ sudo sh get-docker.sh</code></pre><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><pre><code>$ sudo systemctl enable docker$ sudo systemctl start docker</code></pre><h3 id="建立-docker-用户组-免sudo运行"><a href="#建立-docker-用户组-免sudo运行" class="headerlink" title="建立 docker 用户组,免sudo运行"></a>建立 docker 用户组,免sudo运行</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br>建立 docker 组：</p><pre><code>$ sudo groupadd docker</code></pre><p>将当前用户加入 docker 组：</p><pre><code>$ sudo usermod -aG docker $USER</code></pre><p>退出当前终端并重新登录，进行如下测试。</p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><pre><code>$ docker run --rm hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldb8dfde127a29: Pull completeDigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with:    $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID:  https://hub.docker.com/   For more examples and ideas, visit:   https://docs.docker.com/get-started/</code></pre><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="Docker的基本使用"><a href="#Docker的基本使用" class="headerlink" title="Docker的基本使用"></a>Docker的基本使用</h2><h3 id="启动docker-container"><a href="#启动docker-container" class="headerlink" title="启动docker container"></a>启动docker container</h3><pre><code>$ docker run -it --rm -v /home/jwang/Desktop/:/home/jovyan/work/test gitlab-registry.in2p3.fr/epta/docker_singularity:master_std /bin/bash# -v   参数： 挂载/home/jwang/Desktop/至/home/jovyan/work/test的目录，注意使用绝对路径# --rm 参数： 在容器终止运行后自动删除容器文件# -it  参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。# /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell</code></pre><h3 id="镜像image有关命令"><a href="#镜像image有关命令" class="headerlink" title="镜像image有关命令"></a>镜像image有关命令</h3><pre><code>$ docker pull ubuntu:22.04 # 获取一个新的镜像ubuntu:22.04$ docker image ls #列出本机的所有 image 文件$ docker rmi ubuntu:22.04  #删除本机 image 文件ubuntu:22.04$ docker search httpd # 查找镜像httpd</code></pre><h3 id="容器container有关命令"><a href="#容器container有关命令" class="headerlink" title="容器container有关命令"></a>容器container有关命令</h3><pre><code>$ docker ps -a  # 查看所有容器列表$ docker run -it ubuntu /bin/bash # 启动容器，并以命令行模式进入该容器$ docker ps -a # 查出容器的 ID$ docker rm [containerID] # 删除指定的容器</code></pre><h4 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h4><p>前面的docker run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker start命令，它用来启动已经生成、已经停止运行的容器文件。</p><pre><code>$ docker start [containerID]</code></pre><h4 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h4><p>前面的docker kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><pre><code>$ docker stop [containerID]</code></pre><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h4><p>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p><pre><code>$ docker logs [containerID]</code></pre><h4 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h4><p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><pre><code>$ docker container exec -it [containerID] /bin/bash</code></pre><h2 id="Singularity-安装和基本配置"><a href="#Singularity-安装和基本配置" class="headerlink" title="Singularity 安装和基本配置"></a>Singularity 安装和基本配置</h2><h3 id="Singularity-安装"><a href="#Singularity-安装" class="headerlink" title="Singularity 安装"></a>Singularity 安装</h3><pre><code># 下载并安装Go-lang$ sudo add-apt-repository ppa:longsleep/golang-backports$ sudo apt update$ sudo apt install golang-go#下载并解压Singularity$ export VERSION=3.7.0 &amp;&amp; # adjust this as necessary \    wget https://github.com/hpcng/singularity/releases/download/v${VERSION}/singularity-${VERSION}.tar.gz &amp;&amp; \    tar -xzf singularity-${VERSION}.tar.gz &amp;&amp; \    cd singularity#编译Singularity$ ./mconfig &amp;&amp; \    make -C builddir &amp;&amp; \    sudo make -C builddir install</code></pre><p>检查是否安装成功</p><pre><code>$ singularityUsage:  singularity [global options...] &lt;command&gt;Available Commands:  build       Build a Singularity image  cache       Manage the local cache  capability  Manage Linux capabilities for users and groups  config      Manage various singularity configuration (root user only)  delete      Deletes requested image from the library  exec        Run a command within a container  inspect     Show metadata for an image  instance    Manage containers running as services  key         Manage OpenPGP keys  oci         Manage OCI containers  overlay     Manage an EXT3 writable overlay image  plugin      Manage Singularity plugins  pull        Pull an image from a URI  push        Upload image to the provided URI  remote      Manage singularity remote endpoints, keyservers and OCI/Docker registry credentials  run         Run the user-defined default command within a container  run-help    Show the user-defined help for an image  search      Search a Container Library for images  shell       Run a shell within a container  sif         siftool is a program for Singularity Image Format (SIF) file manipulation  sign        Attach digital signature(s) to an image  test        Run the user-defined tests within a container  verify      Verify cryptographic signatures attached to an image  version     Show the version for SingularityRun 'singularity --help' for more detailed usage information.</code></pre><h3 id="Sigularity镜像image"><a href="#Sigularity镜像image" class="headerlink" title="Sigularity镜像image"></a>Sigularity镜像image</h3><p>Singularity 镜像文件(Singularity Image File, sif)是一种内容只读的文件格式，其文件内容不能被修改。</p><p>Singularity 可以从 Singularity Hub (以 shub:// 开头)或者 Docker Hub (以 docker:// 开头)来获取镜像</p><pre><code>$ sudo singularity pull docker://ubuntu # 获取预编译镜像，完成后会在本地目录生成文件 &lt;image-name&gt;_&lt;tag&gt;.sif$ singularity -d build lolcow.simg shub://GodloveD/lolcow # build 镜像，会在本地目录 build 出镜像$ sudo singularity instance list # 查看运行的容器实例$ sudo singularity shell -B /opt:/opt ubuntu.simg # 绑定目录 -B，类似于 docker 的 -v 参数$ singularity exec --bind /mnt/nfs:/mnt/nfs ubuntu.latest.sif /bin/bash script.sh 使用--bind选项映射主机目录到容器内</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行下执行latex</title>
      <link href="/2021/12/07/20211207-latex-process/"/>
      <url>/2021/12/07/20211207-latex-process/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>为了编译出出正确的pdf文件，需要执行4条命令完成整个编译过程。<br>编译命令及输出</p><pre><code>$ pdflatex draft.tex   #目录下会生成draft.aux、draft.log、draft.pdf三个个文件。draft.aux有用。 draft.pdf文件内参考文献，没有正确显示出来。只显示"?"，表明还没有引用$ bibtex bb#生成 draft.bbl，draft.blg两个文件。这两个文件都是字符文件，可查看。其中*.bbl内容就是要插入到*.tex中去的。注意命令中，文件名字是draft，而不是draft.tex$ pdflatex draft.tex#无新文件生成，但查看draft.pdf，其中的参考文献已经显示出来，但正文中对参考文献的引用依然显示为"?"，没有正确（产生交叉）引用$ pdflatex draft.tex#此时，用evince draft.pdf查看生成的pdf，已经是一份正式的档了。</code></pre><h2 id="参考文献引用"><a href="#参考文献引用" class="headerlink" title="参考文献引用"></a>参考文献引用</h2><p>bibtex 格式参考文献文件后缀为 <code>bib</code>，通过此种方式引入参考文献，可以方便利用文献软件进行管理. 其他的诸多好处可以在<a href="http://www.zhihu.com/question/23565739/answer/51511029">如何在LaTeX写作中管理参考文献?</a>中查看。</p><pre><code>xelatex main.tex# 参考文献编译bibtex main.auxxelatex main.texxelatex main.tex</code></pre><p>注意:</p><p>bibtex不是编译.tex文件的，也不是编译.bib文件的，而是编译.aux文件的。bibtex后面应该跟.aux文件. .bib, .bst 和 .aux的区别如下：</p><ol><li><strong>.bib就是参考文献数据文件</strong>  </li><li><strong>.bst一般由期刊或者杂志提供, bst设定了参考文献出现在文末的方式</strong></li><li><strong>.aux由编译tex文件得到，编译tex没错误的话会生成aux文件，aux文件包含了引用这些的信息</strong></li></ol><p>2.去掉容差报警的方法：</p><pre><code>\hbadness=10000\tolerance=10000 \hfuzz=150pt</code></pre><div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div><script>var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"当爱已成往事","author":"李宗盛、林忆莲","url":"/file/dang_ai_yi_cheng_wang_shi.mp3","pic":"/file/dang_ai_yi_cheng_wang_shi.jpg","lrc":"/file/dang_ai_yi_cheng_wang_shi.lrc"}]};options.element = document.getElementById("aplayer1");var ap = new APlayer(options);window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下PDF文件处理</title>
      <link href="/2021/12/06/20211206-pdf-process/"/>
      <url>/2021/12/06/20211206-pdf-process/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-gs命令"><a href="#1-gs命令" class="headerlink" title="1. gs命令"></a>1. gs命令</h2><p>linux下可以直接用命令进行PDF的原生操作</p><p>使用命令：gs（GhostScript）</p><p>官网：<a href="https://www.ghostscript.com/">https://www.ghostscript.com/</a></p><p>安装该命令：<code>sudo apt-get install gs</code></p><h3 id="1-1-合并多个PDF为1个"><a href="#1-1-合并多个PDF为1个" class="headerlink" title="1.1 合并多个PDF为1个"></a>1.1 合并多个PDF为1个</h3><pre><code>gs -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=target.pdf -dBATCH 1.pdf 2.pdf ... n.pdf</code></pre><h3 id="1-2-单个PDF压缩"><a href="#1-2-单个PDF压缩" class="headerlink" title="1.2 单个PDF压缩"></a>1.2 单个PDF压缩</h3><pre><code>gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/prepress -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf-dPDFSETTINGS 参数描述：/prepress ：质量最好，文件最大/printer ：打印模式，推荐压缩/ebook ： 电子书模式，适合文本/screen ：文件最小，不推荐 </code></pre><h2 id="2-pdftk命令"><a href="#2-pdftk命令" class="headerlink" title="2. pdftk命令"></a>2. pdftk命令</h2><p>官网：<a href="http://www.pdflabs.com/docs/install-pdftk/">http://www.pdflabs.com/docs/install-pdftk/</a><br>安装该命令：<code>sudo snap install pdftk</code></p><h3 id="2-1-pdf文件合并"><a href="#2-1-pdf文件合并" class="headerlink" title="2.1 pdf文件合并"></a>2.1 pdf文件合并</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk in1.pdf in2.pdf <span class="token function">cat</span> output out.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-多个不同页面合并"><a href="#2-2-多个不同页面合并" class="headerlink" title="2.2 多个不同页面合并"></a>2.2 多个不同页面合并</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk A<span class="token operator">=</span>1.pdf B<span class="token operator">=</span>2.pdf C<span class="token operator">=</span>pdf <span class="token function">cat</span> A1-2 B2-3 C3 output abc.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-旋转第一页"><a href="#2-3-旋转第一页" class="headerlink" title="2.3 旋转第一页"></a>2.3 旋转第一页</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk in.pdf <span class="token function">cat</span> 1E 2-end output out.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-加密（128位）"><a href="#2-4-加密（128位）" class="headerlink" title="2.4 加密（128位）"></a>2.4 加密（128位）</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf owner_pw pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-加访问密码"><a href="#2-5-加访问密码" class="headerlink" title="2.5 加访问密码"></a>2.5 加访问密码</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf user_pw pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-6-解密"><a href="#2-6-解密" class="headerlink" title="2.6 解密"></a>2.6 解密</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf input_pw pass output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-7-解压"><a href="#2-7-解压" class="headerlink" title="2.7 解压"></a>2.7 解压</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf uncompress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-8-压缩"><a href="#2-8-压缩" class="headerlink" title="2.8 压缩"></a>2.8 压缩</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf compress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-9-修复"><a href="#2-9-修复" class="headerlink" title="2.9 修复"></a>2.9 修复</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-10-切割"><a href="#2-10-切割" class="headerlink" title="2.10 切割"></a>2.10 切割</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf <span class="token function">cat</span> 1-end output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-11-分解成单页"><a href="#2-11-分解成单页" class="headerlink" title="2.11 分解成单页"></a>2.11 分解成单页</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf burst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-Imagemagick命令"><a href="#3-Imagemagick命令" class="headerlink" title="3. Imagemagick命令"></a>3. Imagemagick命令</h2><p>官网：<a href="http://www.imagemagick.org/">http://www.imagemagick.org</a></p><p>安装方法：<code>sudo apt-get install imagemagick</code></p><h3 id="3-1-PDF-TO-JPG"><a href="#3-1-PDF-TO-JPG" class="headerlink" title="3.1 PDF TO JPG"></a>3.1 PDF TO JPG</h3><p><code>convert -verbose -colorspace RGB -resize 1800 -interlace none -density 300 -quality 100 XXX.pdf XXX.jpg</code></p><p>参数：<br>-resize 1800：设置输出图片的宽度为1800像素，清晰度高了很多<br>-density 300：打印分辨率为300<br>-quality 100：JPG的质量为100%</p><h3 id="3-2-JPG-TO-PDF"><a href="#3-2-JPG-TO-PDF" class="headerlink" title="3.2 JPG TO PDF"></a>3.2 JPG TO PDF</h3><p>转换单个JPG：<code>convert x.jpg x.pdf</code><br>转换多个JPG为1个PDF：<code>convert *.jpg x.pdf</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ph.D. Thesis</title>
      <link href="/2021/12/05/20211205-phd-thesis/"/>
      <url>/2021/12/05/20211205-phd-thesis/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><center>** Ph.D. Thesis: Optimizing Analysis Standards for Pulsar Timing Arrays and GravitationalWave Detection **</center><br> <div class="row">    <embed src="https://astrondog.github.io/file/phd_thesis.pdf" width="100%" height="550" type="application/pdf"></div><br><p>This is a colorized version of my Ph.D. thesis. For an submitted version, please download through the <a href="https://pub.uni-bielefeld.de/record/2958421">Bielefeld University library portal</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA White Noise Parameters</title>
      <link href="/2021/11/13/20211113-PTA-WN-Parameters/"/>
      <url>/2021/11/13/20211113-PTA-WN-Parameters/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="EFAC-and-EQUAD"><a href="#EFAC-and-EQUAD" class="headerlink" title="EFAC and EQUAD"></a>EFAC and EQUAD</h2><p>For pulsar timing purpose, ToAs can be created precisely by determining the phase offset between each observed pulse profile and a reference profile (known as standard template) through cross-correlation algorithms. Assuming that the intensity of the profile of an individual pulse, $P(t)$ is a shifted and scaled version of the template, $T(t)$, plus Gaussian measurement error $N(t)$, (for details, see <a href="https://ui.adsabs.harvard.edu/abs/1992RSPTA.341..117T/abstract">Taylor 1992</a>):</p><p><img src="/images/20211113-PTA-WN-Parameters.assets/001.png"><br>which can be expressed either in the time or in the phase domain within one folding period. $a$ is an arbitrary intensity shift, $b$ is the intensity scaling factor and $\tau$ is the phase offset.</p><p>The uncertainty in the ToA determination process is approximately the ratio of the pulse width, $W$, to the $S/N$, which is defined as the ratio of the power of a signal to the noise fluctuations. The ToA uncertainty can be expressed as (for further details, please refer to <a href="https://ui.adsabs.harvard.edu/abs/2012hpa..book.....L/abstract">Lorimer &amp; Kramer 2012</a>):</p><p><img src="/images/20211113-PTA-WN-Parameters.assets/002.png"></p><p>where $S_{\textrm{sys}}$ and $S_{\textrm{mean}}$ is the system equivalent temperature and the pulsar’s mean flux density, respectively. Here, $t_{\textrm{obs}}$ is the integration time, $\Delta f$ is the bandwidth and $P$ is the spin period of the pulsar.</p><p>Once the ToAs and their related uncertainties have been determined, a linear least-squares method is normally performed to estimate the pulsar parameters and generate timing residuals by minimizing the reduced chi-squared value, $\chi_r^2$, which effectively describes the goodness of fit of the model: </p><p><img src="/images/20211113-PTA-WN-Parameters.assets/003.png"></p><p>Notice that the least-squares timing model fits are performed on the basis of assuming radiometer noise to be the only source of error in the ToAs. However, this is not always the case, for some pulsars, the ToA uncertainties tend to be too small and thus yield large $\chi_r^2$ values. In addition, some pulsars, would also show a noticeable red spectral pattern in their residuals which worsen the least-squares model.</p><p>A conservative way to solve this problem is to increase the size of each errorbar until the reduced chi-squared turn to unity. Generally, this can be archived by either multiplying a constant factor, EFAC to account for possible mis-calibration from a particular system, or adding in quadrature a constant additional uncertainty value, EQUAD, to make up additional sources of time independent noise, such as the intrinsic jitter noise inherited from pulse emission perturbations, which should be pulsar-dependent and observing-system-independent.</p><p>The revised ToA uncertainties, $\hat{\sigma}_{\textrm{ToA}}$, can then be expressed as:</p><p><img src="/images/20211113-PTA-WN-Parameters.assets/004.png"></p><h3 id="Brief-summary"><a href="#Brief-summary" class="headerlink" title="Brief summary:"></a>Brief summary:</h3><p><strong>EFAC</strong> is introdueced to account for possible mis-calibration of this <strong>radiometer noise</strong>, acting as a <strong>multiplier</strong> for all the TOA error bars for a given pulsar, observed with a particular system.</p><p><strong>EQUAD</strong>, added in <strong>quadrature</strong>,  is used to represent some additional source of time independent noise, (i.e. <strong>jitter noise</strong>).  A single EQUAD parameter is available to include for all TOAs</p><h2 id="ECORR"><a href="#ECORR" class="headerlink" title="ECORR"></a>ECORR</h2><p>ECORR, namely the ‘error correction factor’,  describes short-timescale noise process that has no correlation between observing epochs, but correlated in frequency, data obtained simultaneously at different observing frequencies.</p><p>This parameter is only used by NANOGrav data and not applicable to EPTA and PPTA data.</p><h2 id="Parameters-applied-to-Tempo2-and-Tempo"><a href="#Parameters-applied-to-Tempo2-and-Tempo" class="headerlink" title="Parameters applied to Tempo2 and Tempo"></a>Parameters applied to Tempo2 and Tempo</h2><h3 id="EFAC-amp-EQUAD"><a href="#EFAC-amp-EQUAD" class="headerlink" title="EFAC &amp; EQUAD"></a>EFAC &amp; EQUAD</h3><blockquote><p><strong>Both tempo and tempo2</strong> accept <strong>T2EQUAD/T2EFAC</strong>. </p></blockquote><blockquote><p><strong>Neither</strong> accepts <strong>EQUAD/EFAC</strong> in the par file. </p></blockquote><p>Using EQUAD in tempo2 results in some confusing behavior since the “QUAD” string is also used for other purposes and the parsing is buggy. This specific bug could of course be easily fixed if we wanted to but older versions would still have the issue so might be good practice to avoid EQUAD/EFAC.</p><blockquote><p><strong>tempo2</strong> also accepts <strong>TNEF</strong> and <strong>TNEQ</strong>. These have different definition than T2EFAC/T2EQUAD. </p></blockquote><p>The order of application is different and I think TNEQ is given as log10 (seconds). tempo does not support these. I think we should avoid these for nanograv purposes. If PINT wants to support them someone should double-check the definitions vs tempo2.</p><h3 id="ECORR-1"><a href="#ECORR-1" class="headerlink" title="ECORR"></a>ECORR</h3><blockquote><p><strong>tempo</strong> accepts ECORR only. </p><p><strong>tempo2</strong> accepts either <strong>ECORR</strong> or <strong>TNECORR</strong>, they are treated identically. </p><p>T2ECORR is not a thing.</p></blockquote><h3 id="Red-Noise"><a href="#Red-Noise" class="headerlink" title="Red Noise"></a>Red Noise</h3><p><strong>tempo and tempo2 both</strong> accept <strong>RNAMP</strong> and <strong>RNIDX</strong>. </p><p><strong>tempo2</strong> also accepts <strong>TNRedAmp</strong> and <strong>TNRedGam</strong>, but the units/definitions are different than RNAMP/RNIDX. </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>On the way to detecting the gravitational-wave background in the nanohertz range</title>
      <link href="/2021/10/27/20211027-epta-press/"/>
      <url>/2021/10/27/20211027-epta-press/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>How do galaxies form? The European Pulsar Timing Array marks an important step forward</strong> </p><p>The research collaboration EPTA (the “European Pulsar Timing Array”) reports on the result of a 24-year observation campaign with the five largest European radio telescopes. The campaign has led to a possible signal for the long-sought gravitational-wave background (GWB), which is expected to be orbiting supermassive black holes in the centers of galaxies at a short distance. The cooperation brings together teams of astronomers at the institutes of the major European radio telescopes, as well as research groups specializing in data analysis and modeling of gravitational wave signals. Among them are astrophysicists from the research group of Professor Dr. Joris Verbiest from the Faculty of Physics at Bielefeld University. Although a clear proof has not yet been achieved, it is an important step to detect gravitational waves at very low frequencies in the nanohertz range for the first time. The results are published online in the journal “Monthly Notices of the Royal Astronomical Society”.</p><p>This result was made possible by a data set collected over a long period of 24 years with the five major European radio telescopes. These include the 100 m radio telescope of the Max Planck Institute for Radio Astronomy near Effelsberg in Bonn, the 76 m Lovell telescope in Cheshire/Great Britain, the Nançay telescope for decimeter radio waves in France, the 64 m radio telescope at Pranu Sanguni (Sardinia/Italy) and the 16 antennas of the Westerbork Synthesis radio telescope in the Netherlands. In the observation mode of the Large European Array for Pulsars (LEAP), these five telescopes are connected to each other in such a way that they represent a virtual fully movable 200 m radio telescope, which significantly improves the sensitivity of the EPTA to gravitational waves.</p><p>The researchers observe the rays emitted by the magnetic poles of the rotating pulsars as pulses as they pass through the line of sight, similar to the light of a distant lighthouse. Pulsar Timing Arrays (PTAs) are networks of very stable rotating pulsars that are used as detectors for gravitational waves on a galactic scale. They are particularly sensitive to very low-frequency gravitational waves in the billionth of a hertz or nanohertz range. This expands the observation window for gravitational waves from the high frequencies of hundreds of hertz currently observed by ground-based observatories (LIGO, Virgo, KAGRA). While their detectors study short-term collisions of stellar black holes and neutron stars, the Pulsar Timing Arrays can be used to study gravitational waves as emitted by systems of rotating and slowly approaching supermassive black holes in the centers of galaxies. The addition of the gravitational waves released by a cosmic population of these binary systems forms the gravitational wave background.</p><p>“We can measure small changes in the arrival times of pulsar radio signals on Earth caused by the deformation of space-time due to a passing gravitational wave of very low frequency. In practice, these deformations in space-time show up as sources of very low-frequency noise in the series of observed arrival times of the pulses, a noise that is detected jointly by all pulsars of a pulsar timing array,” explains Dr. Jun Wang, who recently completed his doctorate on this topic at Bielefeld University.</p><p>However, the amplitude of this noise is incredibly tiny (estimated to be between ten and a few hundred billionths of a second), and in principle, many other effects could transmit a corresponding noise to every single pulsar in the pulsar timing array. To validate the results, several independent evaluation programs with different statistical frameworks were then used to exclude alternative noise sources and to search for the gravitational-wave background. Importantly, two independent procedures were used throughout the analysis to ensure mutual consistency.</p><p>The analysis with both methods in the context of the EPTA observations resulted in a clear can data signal for a gravitational wave background.</p><p>Einstein’s General Theory of Relativity predicts a very specific relationship between the space-time deformations experienced by the radio signals from pulsars located in different cardinal directions. The scientists refer to this as the spatial correlation of the signal or the so-called hellings-downs curve. Their detection can identify the observed noise as clearly caused by a gravitational-wave background. Dr. Siyuan Chen, researcher at the Laboratoire de Physique et de Chimie de l’Environnement et de l’Espace in Orleans, one of the two lead authors of the study, notes: “At the moment, the statistical uncertainties in our measurements do not yet allow us to identify the presence of the spatial correlation expected for the gravitational-wave background signal. For further confirmation, we need to include an even larger amount of pulsar data in the analysis, but the current results are already very encouraging.”</p><p>Prof. Dr. Joris Verbiest, group leader at Bielefeld University and one of the leading members of the European Pulsar Timing Array Consortium, summarizes: “It is really satisfying to finally see the first indications of a signal that underpin the expectation that we will soon open up a new part of the gravitational wave spectrum that will allow us to detail the formation history of galaxies over the course of cosmic time. study.”</p><p>Contact:<br>Prof. Dr. Joris Verbiest Bielefeld University Phone: 0521 106 3184 E-Mail: <a href="mailto:verbiest@physik.uni-bielefeld.de">verbiest@physik.uni-bielefeld.de</a> The authors of the original publication include S. Chen, R. N. Caballero, Y. J. Guo, A. Chalumeau, K. Liu, G. Shaifullah, K. J. Lee, S. Babak, G. Desvignes, A. Parthasarathy, H. Hu, E. van der Wateren, J. Antoniadis, A.-S.<br>Bak Nielsen, C. G. Bassa, A. Berthereau, M. Burgay, D. J. Champion, I. Cognard, M. Falxa, R. D. Ferdman, P.C.C. Freire, J. R. Gair, E. Graikou, L. Guil-lemot, J. Jang, G. H. Janssen, R. Karuppusamy, M. J.Keith, M. Kramer, X. J. Liu, A. G. Lyne, R. A. Main, J. W. McKee, M.B. Mickaliger, B.B. P. Perera, D. Perrodin, A. Petiteau, N. K. Porayko, A. Possenti, A. Samajdar, S. A. Sanidas, A. Sesana, L. Speri, B.W. Stappers, G. Theureau, C. Tiburzi, A. Vecchio, J. P. W. Verbiest, J. Wang, L. Wang and H. Xu.<br>Among them are the following authors from Bielefeld University: Ann-Sofie Bak Nielsen, Joris Verbiest, Jun Wang.</p><p>Original publication: S. Chen et al: Common-red-signal analysis with 24-yr high-precision timing of the European Pulsar Timing Array: Inferences in the stochastic gravitational-wave background search, 2021, Monthly Notices of the Royal Astronomical Society ( <a href="https://doi.org/10.1093/mnras/stab2833">https://doi.org/10.1093/mnras/stab2833</a> or <a href="https://academic.oup.com/mnras/article/508/4/4970/6410749">https://academic.oup.com/mnras/article/508/4/4970/6410749</a> )</p><p>More information: European Pulsar Timing Array (EPTA) <a href="http://www.epta.eu.org/">http://www.epta.eu.org/</a> International Pulsar Timing Array (IPTA) <a href="http://www.ipta4gw.org/">http://www.ipta4gw.org/</a></p><p>This is an traslation of the news report by the Bielefeld University. <a href="https://ekvv.uni-bielefeld.de/blog/pressemitteilungen/entry/auf_dem_weg_zum_nachweis">Orignal in German</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Press </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学符号以及公式的英语读法</title>
      <link href="/2021/06/05/20210605-formula-english/"/>
      <url>/2021/06/05/20210605-formula-english/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="内容一"><a href="#内容一" class="headerlink" title="内容一"></a>内容一</h1><h2 id="基本数学符号"><a href="#基本数学符号" class="headerlink" title="基本数学符号"></a>基本数学符号</h2><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p><img src="/20190730111512457.png"></p><p><strong>“+”<strong>当作运算符</strong>加号</strong>时读作plus，比如：</p><p>1+2 ➡️ one plus two</p><p>当”+”放在数字前表示<strong>正数</strong>时，读作positive，比如：</p><p>+4 ➡️ positive four</p><p>同样，<strong>“-”</strong>也有minus和negative两种读法，分别是<strong>减号</strong>和<strong>负数</strong>。</p><p><strong>“×”</strong> 两种读法都可以，国外的教授会常常读成times，可能因为比较简单吧，比如：</p><p>9x6 ➡️ nine times six</p><p><strong>“÷”</strong>只有一种读法divided by，就是被…分成几份</p><p>15÷3 ➡️ fifteen is divided by three</p><p><strong>注意</strong>：</p><p>其中plus和minus是不用第三人称单数形式的，因为plus和minus根本就不是动词，而是介词。</p><p>但是乘和除，的的确确是动词，出现第三人称单数的形式。您记住了吗？</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/./20210605-formula-english/20190730111607189.png" alt="20190730111607189"></p><p>比较运算符用来比较两个表达式的大小关系，比如：1+4&gt;3 ➡️ one plus four is greater thanthree</p><p>为什么用<strong>is</strong>？</p><p>这里one plus four 是介词plus 连接两个名词，但是one plus four 作为一个整体当作主语，因此不用are，而是is</p><p>4+5=9 ➡️ four plus five equalsnine 或 four plus five is equal tonine</p><p>其他的类推，只要你认识数学符号，应该不难用英语说出来。</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><img src="/./20210605-formula-english/20190730111632512-1622908253696.png" alt="20190730111632512"></p><p>括号是最常见的数学符号了。</p><p>中文里同类词习惯有相同的部分，比如：卡车、消防车、救护车都有“车”字。<strong>小括号，中括号，大括号</strong>都是括号。（多么科学啊！）</p><p>而英语里卡车、消防车、救护车分别是truck, fire engine, ambulance一点都不像。</p><p>英语里<strong>小括号，中括号，大括号</strong>这三个词也是没有一点相似，分别是：parenthesis，bracket，brace.（太不科学了！）</p><p><strong>左括号</strong>叫做left或open，<strong>右括号</strong>叫做right或closed. 下次碰到了就大胆地说出来吧！</p><h3 id="级数表示"><a href="#级数表示" class="headerlink" title="级数表示"></a>级数表示</h3><p><img src="/./20210605-formula-english/20190730111737292-1622908273227.png" alt="20190730111737292"></p><p>哇～到中学数学了～这张表里的<strong>“a”</strong>是变量，而不是冠词“一个”的意思哦。</p><p>**|a|**是a的绝对值或绝对值a， 英文读作absolute value of a, 非常好理解。</p><p><strong>a’<strong>是什么？</strong>a****撇</strong>就是与a相关又不想重复的时候会用一下，英语里读成aprime, 同样有<strong>两撇</strong>adouble prime，<strong>三撇</strong>a triple prime…</p><p>但是注意了，如果**a’**表示时间分秒里的分，或者其他有具体意义的时候，就要按照具体意义读了。</p><p><strong>是a的n次方，</strong>是n 个a 相乘的结果，读作a super n或者ato the n</p><p>这两个初中代数就出现了，读作 abar和 astar. <strong>Bar</strong>就是 <strong>杆</strong>的意思。 a上面有个杆。中文怎么读？ a杠， a星。 </p><p>square是数学里的平方，cube是立方，root是根号，这几个词用于表示<strong>开方</strong></p><p>是最常出现的了，读作 asub n，一定要记住了！！在数学上大量出现。 <strong>根号a</strong>和 <strong>三次方a</strong>读作 square root of a和 cube root of a</p><h3 id="微分和偏微分"><a href="#微分和偏微分" class="headerlink" title="微分和偏微分"></a>微分和偏微分</h3><p><img src="/./20210605-formula-english/f94815bf3a894cf095596e6c3a2e4d7c.png" alt="img"></p><p>升级到了高等数学，经过高考的学生才会碰到这两个。</p><p>这是什么鬼？这是一个变量对 x微分或偏微分的运算符，符号后面还要加上某一个变量。 首先，小伙伴知道中文怎么念吗？</p><p>嘿嘿，d比d x？英文读作dby d x，严谨地读作the derivative with respect to x， with respect to是<strong>关于</strong>的意思，就是关于x的微分。</p><p>偏 比偏x？英文读作the partial derivative with respect to x或者简单地读作partial over partialx，partial是部分的意思。</p><p>顺便显摆一下，<strong>微分是单变量时候叫法，如果是多变量就是偏微分喽</strong>！看咱这数学是不是杠杠滴！</p><h3 id="其他数学符号"><a href="#其他数学符号" class="headerlink" title="其他数学符号**"></a>其他数学符号**</h3><p><img src="/./20210605-formula-english/cb952e4a8fc741e1877d195c6bd1a25e.jpeg" alt="cb952e4a8fc741e1877d195c6bd1a25e"></p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><p>有点数学基础了吧，来点实用的！进阶篇！</p><h3 id="代数-1"><a href="#代数-1" class="headerlink" title="代数(1)"></a>代数(1)</h3><p><img src="/./20210605-formula-english/3150d930e37b4febb6f45ac3a4070d1b.jpeg" alt="3150d930e37b4febb6f45ac3a4070d1b"></p><p>以上几个是<strong>代数表达式</strong>，是符号之间的运算。表达式不是等式，所以其英文翻译也不是一个句子，类似一个名词短语。</p><p>比如<strong>ab-c</strong>读作a bminus c，介词minus连接两个名词变量，结果还是一堆名词变量。<strong>ab</strong>直接读 a b就行。</p><p>因为语言的本质是传递信息，懂数学的人已经明白了，没有二义性。</p><p>如要更清晰地表达<strong>ab****，</strong>是 atimes b，times是谓语动词 time的第三人称单数。</p><p>**a-(b-c)<strong>和</strong>a(b+c)**里有一对括号，不用把括号读出来，读出来是赵本山，读信件时读逗号、括号、括号完了(liǎo)</p><p><strong>a-(b-c)<strong>数学上的意思是a减去b与c的差，英文也是这个逻辑，读作aminus the difference b minus c，没有of，其中the difference是</strong>差</strong>的意思。</p><p>**a(b+c)**读作atimes the sum b plus c，应该很好理解了。</p><p>**a-(-b-c)**读作aminus the quantity minus b minus c，使用quantity是英语语言习惯，避免plus和minus连在一起说。</p><h3 id="代数-2"><a href="#代数-2" class="headerlink" title="代数(2)"></a>代数(2)</h3><p><img src="/./20210605-formula-english/4cbfbbed6a9c40cb84c1b7566da8ff55.jpeg" alt="4cbfbbed6a9c40cb84c1b7566da8ff55"></p><p>这几个单独拿来说事，是因为太重要了！</p><p>在国外课堂上，老师一边写公式一边嘴里叨咕着，公式里分数是很多，一般都念做over！因为快！比如<strong>8/9</strong>直接念eight over nine</p><p>复杂点的第二个</p><p><img src="/./20210605-formula-english/3d956f5731e947f388228338a5c4ae1f.png" alt="img"></p><p>中文读<strong>c****分之a加b加d</strong>，中文读法有歧义，分不清加<strong>d</strong>是在分子上还是分数后面。</p><p>英文读作the quantity a plus b over c, that fraction plus d, 没有歧义！perfect！ </p><p><img src="/./20210605-formula-english/6ab1d8570a6a4c8091d4b1a14839cbd1.png" alt="img"></p><p>是拿来绕嘴的，读作the fraction x squared over a squared plus the fraction y</p><p>squared over b squared equals 1，其中fraction是分数的意思。</p><p>这个是拿来是给你找信心的，很简单吧：a xsquared plus b x y plus c y squared plus d x plus e y plus fequals zero完全读对的童鞋奖励自己一根棒棒糖。</p><h3 id="几个特殊的"><a href="#几个特殊的" class="headerlink" title="几个特殊的"></a>几个特殊的</h3><p><img src="/./20210605-formula-english/a94babc66a25445c9707f16a1d49db39.jpeg" alt="a94babc66a25445c9707f16a1d49db39"></p><p>这几个特殊的每一个都很珍贵！拿走不谢。</p><p>第一个</p><p>简单读成 a to the x，例子非常多，比如 读作 three to four，也可以读的更完整点， three raised to the four power</p><p>是以b为底的a的对数，log to the base b of a，其中the base就是为底了，介词严谨地表达了准确的数学定义。</p><p>，是以10为底的3乘4的积的对数，读作log to the base 10 of the product 3 times 4</p><p>以此类推，</p><p><img src="/./20210605-formula-english/8923b75e9e684a0ca8b722b445e85ab2.png" alt="8923b75e9e684a0ca8b722b445e85ab2"></p><p>中注意 the fraction和 the ratio是一样的，分数就是比的意思嘛。 </p><p>是 x的自然对数，读作 the natural log of x。 </p><p>自然对数底是多少？哼哼，百度啊，e=2.71828</p><p>注意：</p><p>中的“点点点”就读做 dot dot dot</p><p>**p(x)**数学上是表示一个以x为自变量的函数p，读作p of x。为什么不读成p x, 汉语就是这么读的.应该是避免和px搞混吧。</p><p>另外注意，</p><p>里也有个 <strong>of</strong></p><h3 id="带of-的函数"><a href="#带of-的函数" class="headerlink" title="带of 的函数"></a>带of 的函数</h3><p><img src="/./20210605-formula-english/a2234148b6b64d75b6b3c0a322431742.jpeg" alt="a2234148b6b64d75b6b3c0a322431742"></p><p>单独总结一下<strong>带of 的函数</strong>，数学上是以x为自变量的函数p，其他的都不复杂。</p><h3 id="专业课里常出的数学符号"><a href="#专业课里常出的数学符号" class="headerlink" title="专业课里常出的数学符号"></a>专业课里常出的数学符号</h3><p><img src="/./20210605-formula-english/e21267c25693471f87ecb45a54d80df1.jpeg" alt="e21267c25693471f87ecb45a54d80df1"></p><p>这些在工程学科的专业课里很容易见到，理论力学里用</p><p>表示正应力，读作 sigma sub x，注意 sub 表示下标。 </p><p>当有大写字母时，读作 Capital q sub one。 </p><p>有括号，读作 Capital e of x，结合上面的 **p(x)**印象应该很深吧。 </p><p>这个比较怪，下标带括号，汉语一般读成 <strong>j 下标括号p</strong>，英文读作 j sub p in parentheses，parentheses是括号的意思。</p><h3 id="高等数学里面的几个符号"><a href="#高等数学里面的几个符号" class="headerlink" title="高等数学里面的几个符号"></a>高等数学里面的几个符号</h3><p><img src="/./20210605-formula-english/72d9c60f413044c98dfed50da0538ef5.jpeg" alt="72d9c60f413044c98dfed50da0538ef5"></p><p>这几个表达式是求和、求积和求极限。</p><p>汉语读 <strong>西格玛1到大n</strong>，英文读作 summation from one to capital n</p><p><img src="/./20210605-formula-english/0a11d8fc327e4f52aea8645eb18b3229.png" alt="0a11d8fc327e4f52aea8645eb18b3229"></p><p>英文里把希腊字母的意思说出来了，求和( summation), 这里多了 <strong>正无穷</strong>，读作 summation from i equals one to infinity of x sub i</p><p>是infinity就是正无穷。数学上是多个量求积的符号，英文 <strong>积</strong>是 product，是名词。 </p><p><img src="/./20210605-formula-english/a7f13fb2a6224d788eeba70554798b83.png" alt="a7f13fb2a6224d788eeba70554798b83"></p><p>结构和求和一样， product from one to n</p><p>同理，</p><p><img src="/./20210605-formula-english/26187dbb7eb34b608f576c32060b229b.png" alt="26187dbb7eb34b608f576c32060b229b"></p><p>读成 product from i equals one to infinity of y sub i</p><p>的意思是 <strong>当x趋近a时y的极限等于b</strong>， limit as x approaches a of y equals b，limit是极限，名词，approaches 是趋紧的第三人称单数。 <img src="/./20210605-formula-english/254f53af6f864952b7621d6c6998e3ed.jpeg" alt="254f53af6f864952b7621d6c6998e3ed"></p><p>的数学意思是 <strong>当x从左边趋紧a时关于x的函数f的极限</strong>，英文读作 limit as x approaches a minus of fof x，从左边就是从minus方向 </p><p>数学意思是 <strong>函数fx的不定积分</strong>，英文读作 integral of f of x d x，其中integral是积分的意思。 </p><h3 id="线性代数中的英文读法"><a href="#线性代数中的英文读法" class="headerlink" title="线性代数中的英文读法"></a>线性代数中的英文读法</h3><p><img src="/./20210605-formula-english/3fa2a273e3404d1eb97378a7ffb3fe5c.jpeg" alt="3fa2a273e3404d1eb97378a7ffb3fe5c"></p><p>线性代数是大学生必学的科目，里面全是<strong>矩阵</strong>和<strong>向量</strong>，英文分别是matrix和vector，不明觉厉！</p><p>表里第一个是个矩阵，有四个元素，第一行是2 和 7, 第二行是3和10，用英文读时也和中文表达类似。</p><p>Two by two matrix (意思是2x2 矩阵)，first row two seven, second row tree ten</p><p>注意此处没有is 等动词。 </p><p>第二个是<strong>行向量</strong>，读作row vector </p><p>第三个是<strong>列向量</strong>，读作column vector</p><h3 id="其他常用的表达式"><a href="#其他常用的表达式" class="headerlink" title="其他常用的表达式"></a>其他常用的表达式</h3><p><img src="/./20210605-formula-english/ae9670f71d024eaabbedb046a2582ba7.jpeg" alt="ae9670f71d024eaabbedb046a2582ba7"></p><p>读时汉语从不强调 <strong>大写delta</strong>，英文要读 capital delta y</p><p>其他的都在前面出现过，列在此处再此强调一下。</p><p><a href="https://www.sohu.com/a/214664854_200286">本文来源</a></p><h1 id="内容二"><a href="#内容二" class="headerlink" title="内容二"></a>内容二</h1><h2 id="基本运算（加减乘除、乘方、开方）"><a href="#基本运算（加减乘除、乘方、开方）" class="headerlink" title="基本运算（加减乘除、乘方、开方）"></a>基本运算（加减乘除、乘方、开方）</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>相关符号： +</p><p>举例： 1 + 2 = 3 augend + addend = sum</p><p>相关词汇：addition 加法、plus sign 加号、plus symbol 加号、augend 被加数、addend 加数、sum 和</p><p>口语表达： One plus two equals three. 一加二等于三。One is the augend, two is the addend, and three is the sum. 1是被加数，2是加数，3是和。</p><pre><code>The sum of one and two is three. 1与2的和是3。If you add one and two, you get three. 1加上2，得到3。We are doing an addition (operation). 我们在做加法（运算）。</code></pre><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>相关符号： -</p><p>举例： 8 - 6 = 2 minuend -subtrahend = difference</p><p>相关词汇： subtraction 减法、minus sign 减号、minus symbol 减号、minuend 被减数、subtrahend 减数、difference 差</p><p>口语表达： Eight minus six equals two. 8减去6等于2。</p><pre><code>8 is the minuend, 6 is the subtrahend, and 2 is the difference. 8是被减数，6是减数，2是差。8, subtract/deduct 6 gives you 2. 8减去6，得到2。If you take 6 away from 8, you get/are left with 2. 8去掉6，得到/剩下2。We are doing a subtraction (operation). 我们在做减法（运算）。</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p><strong>相关符号：</strong>×</p><p>举例： 3 × 4 = 12; multiplier × multiplicand = product ; factor × factor = product</p><p>相关词汇： multiplication 乘法、multiplier 被乘数、multiplicand 乘数、factor因数、product 积</p><p>口语表达： Three times four equals twelve. 3乘以4等于12。</p><pre><code>12 is the product of 3 and 4. 12是3与4的积。3 multiplied by 4 is 12. 3乘以4等于12。</code></pre><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>相关符号： ÷</p><p>举例： 8 ÷ 2 = 4 10 ÷ 4 = 2…2 dividend ÷ divisor = quotient, remainder</p><p>相关词汇： division 除法、obelus 除号、dividend 被除数、divisor 除数、quotient 商、remainder 余数</p><p>口语表达： Eight divided by two equals four. 8除以2等于4。</p><pre><code>10 divided by 4 gives you 2 with a remainder of 2. 10除以4等于2，余数为2。</code></pre><h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><p>举例： bn base exponent = power</p><p>相关词汇： exponentiation 幂运算、power operation 指数运算、exponent 指数、base 底、power 幂</p><p>口语表达： bn 可以读作 b to the n-th power, b to the power of n 或者 b raised to the n-th power</p><p>当指数为2或3时，即 b2 和 b3 通常读作 b squared 和 b cubed</p><pre><code>103 = 1000 可读作 10 cubed is 1,000. 10 to the third power is 1,000. 或 10 to the power of three is 1,000.</code></pre><h3 id="开方运算"><a href="#开方运算" class="headerlink" title="开方运算"></a>开方运算</h3><p>![20200718010629591]./20210605-formula-english/20200718010629591.png)</p><p>相关词汇： root 根、degree 次、radicand 被开方数、square root 平方根、cube root 立方根</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718010713680.png" alt="20200718010713680"></p><p>The squared root of 9 is 3.</p><p><img src="/./20210605-formula-english/2020071801084329.png" alt="2020071801084329"></p><p>The cube root of 8 is 2.</p><p><img src="/./20210605-formula-english/20200718010908350.png" alt="20200718010908350"></p><p>读作 the n-th root of x x 的 n 次方根</p><h2 id="基本计数方法（整数、小数、分数、科学计数法）"><a href="#基本计数方法（整数、小数、分数、科学计数法）" class="headerlink" title="基本计数方法（整数、小数、分数、科学计数法）"></a>基本计数方法（整数、小数、分数、科学计数法）</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>举例： 123; 1234; 12345678</p><p>相关词汇： integer 整数、hundred 百、thousand 千、million 百万、billion 十亿、trillion 万亿</p><p>口语表达： 123 读作 one hundred and twenty-three，非正式可以省读为 one twenty-three</p><pre><code>1,234 读作 one thousand, two hundred and thirty-four 或者 twelve hundred and thirty-four，非正式可以省读为 twelve thirty-four12,345,678 读作 twelve million, three hundred and forty-five thousand, six hundred and seventy-eight（英语中数字以三位数为一组，每一组三位数前面加一个逗号）</code></pre><h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>举例： 0.5; 0.33; 10.875</p><p><strong>相关词汇：</strong>decimal或decimal number 小数、decimal point 小数点、decimal place 小数位、rounding 四舍五入、round up 上入、round down 下舍</p><p><strong>口语表达：</strong>0.5 读作 zero point five</p><pre><code>0.33 读作 zero point three three（注意小数点后面的数字要一个一个念出来，不能读成zero point thirty-three）10.875 读作 ten point eight seven five1.2735 rounded to 3 decimal places is 1.274. 1.2735四舍五入到三位小数是1.274。</code></pre><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>举例： a/b;<br>相关词汇： fraction或fraction number 分数、numerator 分子、denominator 分母</p><p>口语表达：</p><p><img src="/./20210605-formula-english/2020071801122493.png" alt="2020071801122493"></p><p>在口语里通常读作 a over b，要比读作 a divided by b简略</p><pre><code>½，one over two，一般说成one half，同样1/3一般说成one third，1/4 一般说成one quarter或one forth2/3， two over three, 一般说成two thirds（注意third后面加s变复数），类似地，5/12可以说成five twelfths1/100 一般说成one hundredth，其它以此类推</code></pre><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>举例： 1.23×103 或 1.23E3; 7.21×10-22或7.21E-22</p><p>相关词汇： scientific notation 科学计数法</p><p><strong>口语表达：</strong>参见幂运算和指数运算的读法，1.23×103 可读做 one point two three times/multiplied by ten to the power of three, one point two three times ten to the third</p><pre><code>1.23E3 可读作 one point two three times E to the power of three / E to the third7.21×10-22 可读作 seven point two one times ten to the (power of) minus twenty-two 或 seven point two one times ten to the minus twenty-second</code></pre><h2 id="基本数学符号-1"><a href="#基本数学符号-1" class="headerlink" title="基本数学符号"></a>基本数学符号</h2><p>表1：基本数学符号（包括常用的标点符号）</p><p><img src="/./20210605-formula-english/20200718012908657.png" alt="20200718012908657"></p><p>（四） 数学符号进阶<br>表2：数学符号进阶</p><p><img src="/./20210605-formula-english/20200718013500619.png" alt="20200718013500619"></p><p>（五） 常用数学标记<br>表格3：常用数学标记</p><p><img src="/./20210605-formula-english/20200718013650591.png" alt="20200718013650591"></p><h2 id="数学运算进阶"><a href="#数学运算进阶" class="headerlink" title="数学运算进阶"></a>数学运算进阶</h2><h3 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h3><p>相关符号： !</p><p>相关词汇： factorial 阶乘</p><p>口语表达： 5! 读作five factorial 5的阶乘</p><pre><code>5! = 120 The value of five factorial is 120.</code></pre><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>相关符号： ∑</p><p>相关词汇： summation 和、capital sigma notation 大写西格玛标记法</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718014014554.png" alt="20200718014014554"></p><pre><code>读作 the summation over k from 1 to 5 of k squared 或 the sum of k squared as k goes from 1 to 5，通常把summation省读为sum</code></pre><h3 id="求积"><a href="#求积" class="headerlink" title="求积"></a>求积</h3><p>相关符号： Π \Pi Π</p><p>相关词汇： the product of a sequence 序列的积、capital pi notation 大写π标记法</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718014218200.png" alt="20200718014218200"></p><pre><code>读作 the product of i overi from 1 to 4 或者 the product of i as i goes from 1 to 4</code></pre><h3 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h3><p>相关符号： lim</p><p>相关词汇： limit 极限</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718014342270.png" alt="20200718014342270"></p><pre><code>读作 the limit as x approaches zero of f of x</code></pre><p><img src="/./20210605-formula-english/20200718014425551.png" alt="20200718014425551"></p><pre><code>The limit of 1 over the absolute value of x as x approaches zero is infinity.</code></pre><h3 id="对数运算"><a href="#对数运算" class="headerlink" title="对数运算"></a>对数运算</h3><p>相关符号： log， ln</p><p>相关词汇： logarithm operation 对数运算、base 底、common logarithm 常用对数（以10为底）、natural logarithm 自然对数（以自然数e=2.71818…为底）</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718015020530.png" alt="20200718015020530"></p><pre><code>读作 the logarithm of x to base b，通常口语里把logarithm简称loglnx 读作 the natural log of x</code></pre><h3 id="求倒数"><a href="#求倒数" class="headerlink" title="求倒数"></a>求倒数</h3><p>相关词汇： reciprocal 倒数</p><p>口语表达： the reciprocal of 5 is one fifth (1/5) or zero point two (0.2).</p><h3 id="求反函数"><a href="#求反函数" class="headerlink" title="求反函数"></a>求反函数</h3><p>相关符号： f -1</p><p>相关词汇： inverse function 反函数</p><p>口语表达： y = f(x) = 2x + 4 Function y equals f of x equals 2 x plus 4.</p><pre><code>Its inverse function f inverse as a function of y is equal to one half y minus 2, f -1(y) = y/2 - 2.</code></pre><h3 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h3><p>相关符号： .</p><p>相关词汇： dot product 点积，数量积、scalar product 标量积</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718015605303.png" alt="20200718015605303"></p><pre><code>读作 the dot product of vectors u and v</code></pre><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><p>相关符号： ×</p><p>相关词汇： cros product 叉积、vector product 矢量积，向量积</p><p>口语表达：</p><p><img src="/./20210605-formula-english/20200718015729261.png" alt="20200718015729261"></p><pre><code>读作 the cross product of vectors u and v</code></pre><h3 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h3><p>相关符号：</p><p><img src="/./20210605-formula-english/20200718015912916.png" alt="20200718015912916"></p><p>相关词汇： integration 积分运算、integral 积分、definite integral 定积分、</p><p>indefinite integral 不定积分、double integral 双重积分</p><p>口语表达：</p><p><img src="/./20210605-formula-english/2020071801593810.png" alt="2020071801593810"></p><p>读作the integral of f of x d x</p><p><img src="/./20210605-formula-english/20200718020000384.png" alt="20200718020000384"></p><pre><code>读作 the integral from t equals 0 to t equals infinity of f of t d t 或者 the integral of f of t d t as t goes from 0 to infinity</code></pre><h3 id="求导数，求微分"><a href="#求导数，求微分" class="headerlink" title="求导数，求微分"></a>求导数，求微分</h3><p>相关符号：</p><p><img src="/./20210605-formula-english/20200718020229706.png" alt="20200718020229706"></p><p>相关词汇： derivative 导数、first derivative 一阶导数、differential 微分</p><p>口语表达： dy/dx 全称为 the derivative with respect to x of y 或者 the derivative of y with respect to x，简读为d y over d x</p><p><img src="/./20210605-formula-english/20200718020306212.png" alt="20200718020306212"></p><p>读作 the n-th derivative with respect to x of y</p><h3 id="求偏导数，求偏微分"><a href="#求偏导数，求偏微分" class="headerlink" title="求偏导数，求偏微分"></a>求偏导数，求偏微分</h3><p>相关符号：</p><p><img src="/./20210605-formula-english/20200718020402746.png" alt="20200718020402746"></p><pre><code>读作 the partial derivative of f with respect to x</code></pre><h3 id="求卷积"><a href="#求卷积" class="headerlink" title="求卷积"></a>求卷积</h3><p>相关符号： *</p><p>相关词汇： convolution 卷积</p><p>口语表达： f(t)*g(t) 读作 the convolution of functions f of t and g of t</p><p><a href="https://blog.csdn.net/zhuoqingjoking97298/article/details/107405536#t28">本文来源</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Formula </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python虚拟环境</title>
      <link href="/2021/05/17/20210517-virtualenv/"/>
      <url>/2021/05/17/20210517-virtualenv/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Python虚拟环境"><a href="#Python虚拟环境" class="headerlink" title="Python虚拟环境"></a>Python虚拟环境</h1><p>Python 应用程序通常会使用不在标准库内的软件包和模块，且有时会需要包或者模块的特定版本，如应用程序 A 需要特定模块的 1.0 版本但应用程序 B 需要 2.0 版本。因此有效的环境管理在Python开发过程中至关重要，它不仅能避免不同项目之间的依赖冲突，还能保证代码可以在不同机器和系统上的一致运行。</p><p>Python的虚拟环境（Virtualenv）技术可以很好的实现python及其文件包的版本管理。virtualenv 的关键词是隔离（Isolation）, 其通过创建一个包含所有必要的可执行文件的文件夹，用来使用Python项目所需的包。Python社区提供了多种虚拟环境管理工具可供选择，其中virtualenv，venv和pipenv和conda是最为常见的三种。在本文中，我们将简单介绍这四种工具的使用，读者可以根据自己的需求和习惯自行选择一个合适的虚拟环境管理工具。</p><h2 id="1-virtualenv"><a href="#1-virtualenv" class="headerlink" title="1. virtualenv"></a>1. virtualenv</h2><p>virtualenv是Python的第三方库，它可以创建独立的Python环境。它的核心优势是同时支持Python 2.7+ 和 3.3+版本。</p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><pre class="line-numbers language-sh"><code class="language-sh"># 使用自己对应安装的pip版本pip3 install --user virtualenv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-创建虚拟环境目录"><a href="#1-2-创建虚拟环境目录" class="headerlink" title="1.2 创建虚拟环境目录"></a>1.2 创建虚拟环境目录</h3><pre class="line-numbers language-sh"><code class="language-sh">mkdir myprojectcd myproject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-创建Python运行环境-jwenv"><a href="#1-3-创建Python运行环境-jwenv" class="headerlink" title="1.3 创建Python运行环境: jwenv"></a>1.3 创建Python运行环境: jwenv</h3><pre class="line-numbers language-sh"><code class="language-sh">virtualenv --no-site-packages　jwenv  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注： 1） 此时当前目录下会生成一个名为：“myenv” 的目录，该目录中存放刚生成的虚拟环境文件。<br>　　 2） 参数：–no-site-packages （可省略） 其意义在于不复制已经安装到系统 Python 环境中的所有第三方包从而得到一个 “纯净” 的运行环境。<br>    3)  虚拟环境的名字（此例中是 jwenv）可以是任意的；若省略名字将会把文件均放在当前目录。</p><h3 id="1-4-选择使用一个Python解释器："><a href="#1-4-选择使用一个Python解释器：" class="headerlink" title="1.4 选择使用一个Python解释器："></a>1.4 选择使用一个Python解释器：</h3><pre class="line-numbers language-sh"><code class="language-sh">virtualenv -p /usr/bin/python2.7 myenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据需要选择将会使用的pyhon版本，此例使用 /usr/bin/python2.7 作为项目的Python解释器。</p><h3 id="1-5-激活虚拟运行环境"><a href="#1-5-激活虚拟运行环境" class="headerlink" title="1.5 激活虚拟运行环境"></a>1.5 激活虚拟运行环境</h3><pre class="line-numbers language-sh"><code class="language-sh">source jwenv/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注： 执行完上述命令后，虚拟环境的名字(jwenv)会显示在命令提示符左侧，表明虚拟环境已激活，当前处于虚拟环境中。此时可以在该环境中安装常用的库文件或运行程序。</p><h3 id="1-6-安装第三方包，并运行Python命令"><a href="#1-6-安装第三方包，并运行Python命令" class="headerlink" title="1.6 安装第三方包，并运行Python命令"></a>1.6 安装第三方包，并运行Python命令</h3><pre class="line-numbers language-sh"><code class="language-sh"># 安装第三方包numpy和指定版本的astropypip install numpy astropy==4.0# 执行自己的程序python helloworld.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-退出当前的虚拟环境"><a href="#1-7-退出当前的虚拟环境" class="headerlink" title="1.7 退出当前的虚拟环境"></a>1.7 退出当前的虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将会回到系统默认的Python解释器，包括已安装的库也会回到默认的。</p><h3 id="1-8-删除虚拟环境"><a href="#1-8-删除虚拟环境" class="headerlink" title="1.8 删除虚拟环境"></a>1.8 删除虚拟环境</h3><p>没有使用virtualenvwrapper前，可以直接删除venv文件夹来删除环境</p><h2 id="2-venv"><a href="#2-venv" class="headerlink" title="2. venv"></a>2. venv</h2><p>venv是Python 3.3及以上版本内置的库，无需额外安装。它的很多操作都和 virtualenv 类似，但是两者运行机制不同。因为是从 3.3 版本开始自带的，这个工具也仅仅支持 python 3.3 和以后版本。所以，如果需要在 python2 上使用虚拟环境，依然要利用 virtualenv，但好在现在基本很少再使用python2版本。</p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>一般无需额外安装，在Python 3.3及以上版本内置venv,如果某些Linux版本没有内置，可以使用如下命令安装：</p><p>｀｀｀<br>sudo apt install python3-venv  # 如有不同版本的Python3,可指定具体版本venv：python3.5-venv<br>｀｀｀</p><h3 id="2-2-创建虚拟环境目录"><a href="#2-2-创建虚拟环境目录" class="headerlink" title="2.2 创建虚拟环境目录"></a>2.2 创建虚拟环境目录</h3><pre class="line-numbers language-sh"><code class="language-sh">mkdir myprojectcd myproject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-创建Python运行环境-jwenv"><a href="#2-3-创建Python运行环境-jwenv" class="headerlink" title="2.3 创建Python运行环境: jwenv"></a>2.3 创建Python运行环境: jwenv</h3><pre class="line-numbers language-sh"><code class="language-sh">python3 -m venv　jwenv  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注： 1） 此时当前目录下会生成一个名为：“myenv” 的目录，该目录中存放刚生成的虚拟环境文件。<br>    3)  虚拟环境的名字（此例中是 jwenv）可以是任意的；若省略名字将会把文件均放在当前目录。</p><h3 id="2-4-激活虚拟运行环境"><a href="#2-4-激活虚拟运行环境" class="headerlink" title="2.4 激活虚拟运行环境"></a>2.4 激活虚拟运行环境</h3><pre class="line-numbers language-sh"><code class="language-sh">source jwenv/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注： 执行完上述命令后，虚拟环境的名字(jwenv)会显示在命令提示符左侧，表明虚拟环境已激活，当前处于虚拟环境中。此时可以在该环境中安装常用的库文件或运行程序。</p><h3 id="2-5-安装第三方包，并运行Python命令"><a href="#2-5-安装第三方包，并运行Python命令" class="headerlink" title="2.5 安装第三方包，并运行Python命令"></a>2.5 安装第三方包，并运行Python命令</h3><pre class="line-numbers language-sh"><code class="language-sh"># 安装第三方包numpy和指定版本的astropypip install numpy astropy==4.0# 执行自己的程序python helloworld.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-退出当前的虚拟环境"><a href="#2-6-退出当前的虚拟环境" class="headerlink" title="2.6 退出当前的虚拟环境"></a>2.6 退出当前的虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将会回到系统默认的Python解释器，包括已安装的库也会回到默认的。</p><h2 id="3-conda"><a href="#3-conda" class="headerlink" title="3. conda"></a>3. conda</h2><p>Anaconda是一个基于Python的平台，管理主要的数据科学包，包括panda、scikit-learn、SciPy、NumPy和谷歌的机器学习平台TensorFlow。它与conda(类似于pip的安装工具)、Anaconda导航器(用于GUI体验)和spyder(用于IDE)一起打包。</p><p>Conda是Anaconda包管理和环境工具，是Anaconda的核心。它可以直接创建不同python版本的虚拟环境。virtualenv只可以指定创建不同python版本的虚拟环境，前提是你的电脑上已经安装了不同版本的python,但conda就比较灵活。</p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载<a href="https://www.anaconda.com/products/individual">Anaconda</a>,选择对应的系统和版本类型下载后命令行执行安装即可。</p><h3 id="3-2-创建虚拟环境"><a href="#3-2-创建虚拟环境" class="headerlink" title="3.2 创建虚拟环境"></a>3.2 创建虚拟环境</h3><p>创建不同的python版本，直接写出版本号就好了，还可以同时安装想要的库。</p><pre class="line-numbers language-sh"><code class="language-sh"># Python 2.7  conda create -n jwenv python=2.7  # Python 3.5  conda create -n jwenv python=3.5.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-激活虚拟环境"><a href="#3-3-激活虚拟环境" class="headerlink" title="3.3 激活虚拟环境"></a>3.3 激活虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh">source activate jwenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-4-退出虚拟环境"><a href="#3-4-退出虚拟环境" class="headerlink" title="3.4 退出虚拟环境"></a>3.4 退出虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh">source deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-5-删除虚拟环境"><a href="#3-5-删除虚拟环境" class="headerlink" title="3.5 删除虚拟环境"></a>3.5 删除虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh"># 删除一个已有环境conda remove --name jwenv --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-6-更多命令"><a href="#3-6-更多命令" class="headerlink" title="3.6 更多命令"></a>3.6 更多命令</h3><pre class="line-numbers language-sh"><code class="language-sh"># 用户安装的不同Python环境会放在~/anaconda/envs目录下。# 列出系统存在虚拟环境conda info -econda env list# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n jwenv# 查找package信息conda search numpy# 安装packageconda install -n jwenv numpy# 如果不用-n指定环境名称，则被安装在当前激活环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n jwenv numpy# 删除packageconda remove -n jwenv numpy# 更新anacondaconda update anaconda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-pipenv"><a href="#4-pipenv" class="headerlink" title="4. pipenv"></a>4. pipenv</h2><p>pipenv是Python官方推荐的包管理工具。它综合了 virtualenv , pip 和 pyenv 三者的功能, 能够自动为项目创建和管理虚拟环境。 它主要包含了Pipfile、pip、click、requests和virtualenv，能够有效管理Python多个环境，各种第三方包及模块。它可以自动创建和管理virtualenv，并在安装或卸载包时从Pipfile中添加/删除包。它还会自生成Pipfile.lock文件，来锁定安装包的版本和依赖信息，避免构建错误。</p><h3 id="4-1-pipenv安装"><a href="#4-1-pipenv安装" class="headerlink" title="4.1 pipenv安装"></a>4.1 pipenv安装</h3><pre class="line-numbers language-sh"><code class="language-sh">pip install pipenv# 如需更新可使用pip install --user --upgrade pipenv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-2-创建虚拟环境"><a href="#4-2-创建虚拟环境" class="headerlink" title="4.2 创建虚拟环境"></a>4.2 创建虚拟环境</h3><pre class="line-numbers language-sh"><code class="language-sh">cd myproject# 指定使用 Python3.6 创建环境pipenv --python 3.6  # 或指定使用 Python2.7.14 创建环境pipenv --python 2.7.14  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-激活Pipenv-Shell"><a href="#4-3-激活Pipenv-Shell" class="headerlink" title="4.3 激活Pipenv Shell"></a>4.3 激活Pipenv Shell</h3><pre class="line-numbers language-sh"><code class="language-sh">pipenv shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-4-安装模块"><a href="#4-4-安装模块" class="headerlink" title="4.4 安装模块"></a>4.4 安装模块</h3><pre class="line-numbers language-sh"><code class="language-sh">pipenv install XXX  # 安装XXX模块并加入到Pipfilepipenv install XXX==1.11  # 安装固定版本的XXX模块并加入到Pipfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-5-Python-文件的运行"><a href="#4-5-Python-文件的运行" class="headerlink" title="4.5 Python 文件的运行"></a>4.5 Python 文件的运行</h3><p>方式一： </p><pre class="line-numbers language-sh"><code class="language-sh">pipenv run python xxx.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：在激活环境中运行</p><pre class="line-numbers language-sh"><code class="language-sh"># 进入激活环境pipenv shell# 运行文件python xxx.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-虚拟环境的退出和删除"><a href="#4-6-虚拟环境的退出和删除" class="headerlink" title="4.6 虚拟环境的退出和删除"></a>4.6 虚拟环境的退出和删除</h3><pre class="line-numbers language-sh"><code class="language-sh"># 退出当前虚拟环境exit# 删除虚拟环境pipenv --rm  # 删除虚拟环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-7-Pipenv-常用命令"><a href="#4-7-Pipenv-常用命令" class="headerlink" title="4.7 Pipenv 常用命令"></a>4.7 Pipenv 常用命令</h3><pre class="line-numbers language-sh"><code class="language-sh"># 显示信息pipenv --where  # 显示目录信息pipenv --venv  # 显示虚拟环境信息pipenv --py  # 显示Python解释器信息# 检查pipenv graph  # 查看目前安装的库及其依赖pipenv check  # 检查安全漏洞# 更新pipenv update --outdated  # 查看所有需要更新的依赖项pipenv update  # 更新所有包的依赖项pipenv update <包名>  # 更新指定的包的依赖项# 删除包pipenv uninstall XXX  # 卸载XXX模块并从Pipfile中移除pipenv uninstall --all  # 卸载全部包并从Pipfile中移除pipenv uninstall --all-dev  # 卸载全部开发包并从Pipfile中移除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-8-requirements文件"><a href="#4-8-requirements文件" class="headerlink" title="4.8 requirements文件"></a>4.8 requirements文件</h3><p>pipenv可以像virtualenv一样用命令生成requirements.txt 文件：</p><pre class="line-numbers language-sh"><code class="language-sh"># 将Pipfile和Pipfile.lock文件里面的包导出为requirements.txt文件pipenv lock -r > requirements.txt# 将Pipfile和Pipfile.lock文件里面的开发包导出为requirements.txt文件pipenv lock -r --dev > requirements.txt  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pipenv 通过requirements.txt安装包：</p><pre class="line-numbers language-sh"><code class="language-sh">pipenv install -r requirements.txt# 只安装开发包pipenv install -r --dev requirements.txt  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook</title>
      <link href="/2021/03/08/20210308-jupyter-notebook/"/>
      <url>/2021/03/08/20210308-jupyter-notebook/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-1-执行shell命令"><a href="#1-1-执行shell命令" class="headerlink" title="1.1 执行shell命令"></a>1.1 执行shell命令</h2><p>直接在命令之前放一个“!”，就能执行shell命令。甚至可以将值传递给shell，像下面这样：</p><pre class="line-numbers language-python"><code class="language-python">!pwd!echo <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>directory = !pwdprint(directory)</code></pre><h2 id="1-2-更换主题"><a href="#1-2-更换主题" class="headerlink" title="1.2 更换主题"></a>1.2 更换主题</h2><ol><li>安装</li></ol><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterthemes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>加载可用主题列表：</li></ol><pre class="line-numbers language-bash"><code class="language-bash">jt -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>选择你想要的主题：</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># selecting a particular theme</span>jt -t <span class="token operator">&lt;</span>name of the theme<span class="token operator">></span><span class="token comment" spellcheck="true"># reverting to original Theme</span>jt -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-笔记本扩展"><a href="#1-3-笔记本扩展" class="headerlink" title="1.3 笔记本扩展"></a>1.3 笔记本扩展</h2><p>笔记本扩展（nbextensions）是一种JavaScript模块，可以加载到笔记本前端页面上，可以大大提升用户体验。</p><h3 id="1-3-1-Hinterland"><a href="#1-3-1-Hinterland" class="headerlink" title="1.3.1 Hinterland"></a>1.3.1 Hinterland</h3><p>Hinterland功能可以让你每敲完一个键，就出现下拉菜单，可以直接选中你需要的词汇。</p><h3 id="1-3-2-Snippets"><a href="#1-3-2-Snippets" class="headerlink" title="1.3.2 Snippets"></a>1.3.2 Snippets</h3><p>Snippets在工具栏里加了一个下拉菜单，可以非常方便的直接插入代码段，完全不用手动敲。</p><h3 id="1-3-3-目录"><a href="#1-3-3-目录" class="headerlink" title="1.3.3 目录"></a>1.3.3 目录</h3><p>这个功能可以自动找到所有的标题，生成目录。</p><p>并且这个目录还是移动的呦，你可以放在侧边栏，也可以拖动到任何你喜欢的地方悬浮起来。</p><h3 id="1-3-4-折叠一个标题下的全部内容"><a href="#1-3-4-折叠一个标题下的全部内容" class="headerlink" title="1.3.4 折叠一个标题下的全部内容"></a>1.3.4 折叠一个标题下的全部内容</h3><p>如果你的代码太长，觉得滚动过去太麻烦，可以直接折叠掉。</p><h3 id="1-3-5-Autopep8"><a href="#1-3-5-Autopep8" class="headerlink" title="1.3.5 Autopep8"></a>1.3.5 Autopep8</h3><p>一键美化代码，强迫症的福音。</p><h3 id="1-3-6-安装方法"><a href="#1-3-6-安装方法" class="headerlink" title="1.3.6 安装方法"></a>1.3.6 安装方法</h3><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyter_contrib_nbextensions <span class="token operator">&amp;&amp;</span> jupyter contrib nbextension <span class="token function">install</span><span class="token comment" spellcheck="true">#incase you get permission errors on MacOS,</span>pip <span class="token function">install</span> jupyter_contrib_nbextensions <span class="token operator">&amp;&amp;</span> jupyter contrib nbextension <span class="token function">install</span> --user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后把Jupyter打开，你就可以看到NBextensions这个选项卡了。</p><p>widgets.DatePicker( description=’Pick a Date’, disabled=False )</p><h2 id="1-4-Jupyter小工具"><a href="#1-4-Jupyter小工具" class="headerlink" title="1.4 Jupyter小工具"></a>1.4 Jupyter小工具</h2><p>还有一些Jupyter小工具，比如滑块、文本框之类的部分，可以做一些方便的交互。</p><h3 id="1-4-1-滑块"><a href="#1-4-1-滑块" class="headerlink" title="1.4.1 滑块"></a>1.4.1 滑块</h3><pre><code>def f(x): return x# Generate a slider interact(f, x=10,);</code></pre><h3 id="1-4-2-布尔值生成复选框"><a href="#1-4-2-布尔值生成复选框" class="headerlink" title="1.4.2 布尔值生成复选框"></a>1.4.2 布尔值生成复选框</h3><pre><code># Booleans generate check-boxesinteract(f, x=True);</code></pre><h3 id="1-4-3-字符串生成文本区域"><a href="#1-4-3-字符串生成文本区域" class="headerlink" title="1.4.3 字符串生成文本区域"></a>1.4.3 字符串生成文本区域</h3><pre><code># Strings generate text areasinteract(f, x='Hi there!');</code></pre><h3 id="1-4-4-播放器"><a href="#1-4-4-播放器" class="headerlink" title="1.4.4 播放器"></a>1.4.4 播放器</h3><pre><code>play = widgets.Play(  # interval=10,  value=50, min=0, max=100, step=1, description="Press play", disabled=False)slider = widgets.IntSlider()widgets.jslink((play, 'value'), (slider, 'value'))widgets.HBox([play, slider])</code></pre><h3 id="1-4-5-日历"><a href="#1-4-5-日历" class="headerlink" title="1.4.5 日历"></a>1.4.5 日历</h3><pre><code>widgets.DatePicker( description='Pick a Date', disabled=False)</code></pre><h3 id="1-4-6-调色盘"><a href="#1-4-6-调色盘" class="headerlink" title="1.4.6 调色盘"></a>1.4.6 调色盘</h3><pre><code>widgets.ColorPicker( concise=False, description='Pick a color', value='blue', disabled=False)</code></pre><h3 id="1-4-7-标签"><a href="#1-4-7-标签" class="headerlink" title="1.4.7 标签"></a>1.4.7 标签</h3><pre><code>tab_contents = ['P0', 'P1', 'P2', 'P3', 'P4']children = [widgets.Text(description=name) for name in tab_contents]tab = widgets.Tab()tab.children = childrenfor i in range(len(children)): tab.set_title(i, str(i))tab</code></pre><blockquote><p>安装方法</p></blockquote><pre><code># pippip install ipywidgetsjupyter nbextension enable --py widgetsnbextension# Condaconda install -c conda-forge ipywidgets#Installing ipywidgets with conda automatically enables the extension</code></pre><p>使用“interact”功能自动创建UI控件，这是使用IPython最方便的方法。</p><pre><code># Start with some imports!from ipywidgets import interactimport ipywidgets as widgets</code></pre><h2 id="1-5-放PPT"><a href="#1-5-放PPT" class="headerlink" title="1.5 放PPT"></a>1.5 放PPT</h2><p>人在江湖飘，难免遇到要做PPT的时候。</p><p>但是，如果你的内容都已经放在Jupyter里了，再重新导入PPT，太麻烦了，我们自动转换吧。</p><p>一种方法是用Jupyter内置的PPT选项，依次点击菜单栏里的View → Cell Toolbar → Slideshow，之后每个单元格上面都会有一个灰色的横条，选Sub-Slide。 然后输入以下代码：</p><pre><code>jupyter nbconvert *.ipynb --to slides --post serve# insert your notebook name instead of *.ipynb</code></pre><p>你也可以提前换好主题，比如onedork主题，然后再转换成PPT的的时候就是同一个主题风格的PPT了。</p><p>不过，用PyTorch默认方法生成的PPT代码不能编辑，这个时候就要用到RISE插件了。</p><p>RISE用到reveal.js来运行PPT，可以不退出PPT，直接运行代码。</p><p>先来安装RISE，</p><pre><code>pip install RISE</code></pre><p>然后调用JS和CSS：</p><pre><code>jupyter-nbextension install rise --py --sys-prefix#enable the nbextension:jupyter-nbextension enable rise --py --sys-prefix</code></pre><p>安装好啦，现在重新打开你的Jupyter Notebook，发现一个新的扩展，名叫“Enter/Exit RISE Slideshow”。戳一下，一个可以边演示边改的PPT就好了。</p><h2 id="1-6-嵌入链接和pdf"><a href="#1-6-嵌入链接和pdf" class="headerlink" title="1.6 嵌入链接和pdf"></a>1.6 嵌入链接和pdf</h2><p>扔链接再跳转实在是太麻烦了，不如直接把素材放进Jupyter里面。</p><h3 id="1-6-1-嵌入链接"><a href="#1-6-1-嵌入链接" class="headerlink" title="1.6.1 嵌入链接"></a>1.6.1 嵌入链接</h3><pre><code>#Note that http urls will not be displayed. Only https are allowed inside the Iframefrom IPython.display import IFrameIFrame('https://en.wikipedia.org/wiki/HTTPS', width=800, height=450)</code></pre><p>操作方式如下，当然你需要把链接换成你要放的链接：</p><pre><code>from IPython.display import IFrameIFrame('https://www.astrondog.com', width=800, heigh=450)</code></pre><h3 id="1-6-2-嵌入pdf"><a href="#1-6-2-嵌入pdf" class="headerlink" title="1.6.2 嵌入pdf"></a>1.6.2 嵌入pdf</h3><pre><code>from IPython.display import IFrameIFrame('https://arxiv.org/pdf/1406.2661.pdf', width=800, height=450)</code></pre><h2 id="1-7-图片"><a href="#1-7-图片" class="headerlink" title="1.7 图片"></a>1.7 图片</h2><h3 id="1-7-1-输出矢量图"><a href="#1-7-1-输出矢量图" class="headerlink" title="1.7.1 输出矢量图"></a>1.7.1 输出矢量图</h3><pre><code>import matplotlibimport matplotlib.pyplot as plt%matplotlib inline%config InlineBackend.figure_format = 'svg'</code></pre><h3 id="1-7-2-指定文件名后缀pdf或eps保存"><a href="#1-7-2-指定文件名后缀pdf或eps保存" class="headerlink" title="1.7.2 指定文件名后缀pdf或eps保存"></a>1.7.2 指定文件名后缀pdf或eps保存</h3><pre><code>plt.savefig('tmp.pdf', bbox_inches='tight')plt.show()</code></pre><h3 id="1-7-3-图片插入"><a href="#1-7-3-图片插入" class="headerlink" title="1.7.3 图片插入"></a>1.7.3 图片插入</h3><p><strong>方法1:(MarkDown模式下)(不能改变大小)(只能居中)</strong></p><p><img src="https://github.com/AstronDog/blog-pic/raw/master/logo1.png" alt="title"></p><p><strong>方法2:(MarkDown模式下)(不能改变大小)(可居中)</strong>(推荐)</p><p><img src="https://github.com/AstronDog/blog-pic/raw/master/logo1.png" alt="img"></p><p><strong>方法3:(Code模式下)(不能改变大小)(不可居中)</strong></p><pre><code>from IPython.display import ImageImage(filename = 'https://github.com/AstronDog/blog-pic/raw/master/logo.png', width=100, height=60)</code></pre><p><strong>方法4:(Code模式下)(不能改变大小)(不可居中)</strong></p><pre><code>%%html&lt;img src='./logo.png', width=100, height=60&gt;</code></pre><p><img src="https://github.com/AstronDog/blog-pic/raw/master/logo1.png" alt="img"></p><h2 id="1-8-魔法命令-Magic-Command"><a href="#1-8-魔法命令-Magic-Command" class="headerlink" title="1.8 魔法命令 Magic Command"></a>1.8 魔法命令 Magic Command</h2><p>magic函数主要包含两大类，一类是行魔法（Line magic）前缀为%，一类是单元魔法(Cell magic)前缀为%%； 行魔法只对命令所在的行有效，而单元魔法则必须出现在单元的第一行，对整个单元的代码进行处理。</p><p>%lsmagic #打印当前可以用的魔法命令，当我们想使用一个魔法命令，而不知怎么拼写函数名时，可以使用%lsmagic来查询；</p><h3 id="1-8-1-使用-lsmagic查看所有的魔法命令"><a href="#1-8-1-使用-lsmagic查看所有的魔法命令" class="headerlink" title="1.8.1 使用%lsmagic查看所有的魔法命令"></a>1.8.1 使用%lsmagic查看所有的魔法命令</h3><pre><code>%lsmagic</code></pre><pre><code>Available line magics:%alias  %alias_magic  %autocall  %automagic  %autosave  %bookmark  %cat  %cd  %clear  %colors  %config  %connect_info  %cp  %debug  %dhist  %dirs  %doctest_mode  %ed  %edit  %env  %gui  %hist  %history  %killbgscripts  %ldir  %less  %lf  %lk  %ll  %load  %load_ext  %loadpy  %logoff  %logon  %logstart  %logstate  %logstop  %ls  %lsmagic  %lx  %macro  %magic  %man  %matplotlib  %mkdir  %more  %mv  %notebook  %page  %pastebin  %pdb  %pdef  %pdoc  %pfile  %pinfo  %pinfo2  %popd  %pprint  %precision  %profile  %prun  %psearch  %psource  %pushd  %pwd  %pycat  %pylab  %qtconsole  %quickref  %recall  %rehashx  %reload_ext  %rep  %rerun  %reset  %reset_selective  %rm  %rmdir  %run  %save  %sc  %set_env  %store  %sx  %system  %tb  %time  %timeit  %unalias  %unload_ext  %who  %who_ls  %whos  %xdel  %xmodeAvailable cell magics:%%!  %%HTML  %%SVG  %%bash  %%capture  %%debug  %%file  %%html  %%javascript  %%js  %%latex  %%perl  %%prun  %%pypy  %%python  %%python2  %%python3  %%ruby  %%script  %%sh  %%svg  %%sx  %%system  %%time  %%timeit  %%writefileAutomagic is ON, % prefix IS NOT needed for line magics.</code></pre><h3 id="1-8-2-使用-magic查看各个命令的说明"><a href="#1-8-2-使用-magic查看各个命令的说明" class="headerlink" title="1.8.2 使用%magic查看各个命令的说明"></a>1.8.2 使用%magic查看各个命令的说明</h3><pre><code>%magic</code></pre><h3 id="1-8-3-查看具体命令的说明，可以通过在命令后添加-如："><a href="#1-8-3-查看具体命令的说明，可以通过在命令后添加-如：" class="headerlink" title="1.8.3 查看具体命令的说明，可以通过在命令后添加?, 如："></a>1.8.3 查看具体命令的说明，可以通过在命令后添加?, 如：</h3><pre><code>%alias?</code></pre><h3 id="1-8-4-常用的命令总结"><a href="#1-8-4-常用的命令总结" class="headerlink" title="1.8.4 常用的命令总结"></a>1.8.4 常用的命令总结</h3><h4 id="1-8-4-1-matplotlib-inline-将matplotlib画出的图直接显示在Notebook之中-不以单独窗口显示"><a href="#1-8-4-1-matplotlib-inline-将matplotlib画出的图直接显示在Notebook之中-不以单独窗口显示" class="headerlink" title="1.8.4.1 %matplotlib inline :将matplotlib画出的图直接显示在Notebook之中,不以单独窗口显示"></a>1.8.4.1 %matplotlib inline :将matplotlib画出的图直接显示在Notebook之中,不以单独窗口显示</h4><pre><code>%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltplt.plot(np.arange(10))</code></pre><h4 id="1-8-4-2-timeit-timeit-为代码执行计时"><a href="#1-8-4-2-timeit-timeit-为代码执行计时" class="headerlink" title="1.8.4.2 %timeit %%timeit #为代码执行计时"></a>1.8.4.2 %timeit %%timeit #为代码执行计时</h4><pre><code>import numpy as np%timeit np.sin(24)The slowest run took 31.04 times longer than the fastest. This could mean that an intermediate result is being cached.1000000 loops, best of 3: 737 ns per loop</code></pre><pre><code>%%timeitx=np.sin(20)np.cos(-x)The slowest run took 42.58 times longer than the fastest. This could mean that an intermediate result is being cached.100000 loops, best of 3: 1.65 µs per loop</code></pre><h4 id="1-8-4-3-writefile-后面紧接着一个file-name-py-表示在jupyter-notebook里面创建一个py文件，后面cell里面的内容为py文件内容"><a href="#1-8-4-3-writefile-后面紧接着一个file-name-py-表示在jupyter-notebook里面创建一个py文件，后面cell里面的内容为py文件内容" class="headerlink" title="1.8.4.3 %%writefile #后面紧接着一个file_name.py,表示在jupyter notebook里面创建一个py文件，后面cell里面的内容为py文件内容"></a>1.8.4.3 %%writefile #后面紧接着一个file_name.py,表示在jupyter notebook里面创建一个py文件，后面cell里面的内容为py文件内容</h4><pre><code>%%writefile test_peace.pyimport numpy as npprint(np.random.randint(1,5))Writing test_peace.py</code></pre><p>在当前路径下会生成一个test_peace.py的文件，内容就是cell里面的内容</p><h4 id="1-8-4-4-run-后面紧接着一个相对地址的file-name-py，表示运行一个py文件"><a href="#1-8-4-4-run-后面紧接着一个相对地址的file-name-py，表示运行一个py文件" class="headerlink" title="1.8.4.4 %run #后面紧接着一个相对地址的file_name.py，表示运行一个py文件"></a>1.8.4.4 %run #后面紧接着一个相对地址的file_name.py，表示运行一个py文件</h4><pre><code>%run test_peace.py</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pulsar Data Analysis</title>
      <link href="/2021/03/07/20210307-pulsar-data-analysis/"/>
      <url>/2021/03/07/20210307-pulsar-data-analysis/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Data-format"><a href="#Data-format" class="headerlink" title="Data format"></a>Data format</h2><h3 id="Baseband"><a href="#Baseband" class="headerlink" title="Baseband"></a>Baseband</h3><h3 id="EPN"><a href="#EPN" class="headerlink" title="EPN"></a>EPN</h3><h3 id="PSRFITS"><a href="#PSRFITS" class="headerlink" title="PSRFITS"></a>PSRFITS</h3><p>The “PSRFITS” format supports mean pulse profile (‘fold-mode’) and streamed (‘search-mode’) multi-channel full-polarisation data. A PSRFITS format file consists of a primary header-data unit (HDU) followed by a series of binary extension HDUs, in which are stored specific information about an observation. </p><p>Usually, there are three types of pulsar data products are available:</p><h4 id="Fold-mode-observations"><a href="#Fold-mode-observations" class="headerlink" title="Fold-mode observations"></a>Fold-mode observations</h4><p>Fold-mode observations are recorded at the telescope for a particular known pulsar, where the data are stacked or ‘folded’ at the rotation period of the pulsar, to form a pulse profile averaged over the length of the observation.</p><p>Files of this type have the extension ‘.rf’. All fold-mode files are also processed by averaging over frequency channels, polarisation and time - files of this type have the extension ‘.FTp’.</p><h4 id="Search-mode-observations"><a href="#Search-mode-observations" class="headerlink" title="Search-mode observations"></a>Search-mode observations</h4><p>Search-mode observations are essentially comprised of a multi-channel full-polarisation data stream for the length of the observation.</p><p>Files of this type have the extension ‘.sf’.</p><h4 id="Calibration-files"><a href="#Calibration-files" class="headerlink" title="Calibration files"></a>Calibration files</h4><p>Before and after an observation, a signal from a linear noise diode is injected into the feed. This allows the associated pulsar observation to be polarimetrically calibrated.</p><p>Files of this type have the extension ‘.cf’. </p><h2 id="Psrchive"><a href="#Psrchive" class="headerlink" title="Psrchive"></a>Psrchive</h2><p>Checking that it’s working:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> psrchive <span class="token keyword">as</span> pr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Fundamental-data-classes"><a href="#Fundamental-data-classes" class="headerlink" title="Fundamental data classes:"></a>Fundamental data classes:</h3><blockquote><p><strong>Profile</strong> is a single pulse profile – data as a function of pulse phase only.</p></blockquote><blockquote><p><strong>Integration</strong> is a set of pulse profiles recorded simultaneously – usually<br>profiles as a function of frequency channel and/or polarization.</p></blockquote><blockquote><p><strong>Archive</strong> is a set of Integration as a function of time. Represents a<br>single data file.</p></blockquote><table>    <tbody><tr>        <td>            <center>                <img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/profile.png" width="400"> Fig 1, Profile            </center>        </td>        <td>            <center>                <img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/integration.png" width="400"> Fig 2, Integration            </center>        </td>        <td>            <center>                <img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/archive.png" width="400"> Fig 3, Archive            </center>        </td>    </tr></tbody></table><h3 id="Accessing-data-with-these-classes"><a href="#Accessing-data-with-these-classes" class="headerlink" title="Accessing data with these classes"></a>Accessing data with these classes</h3><h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive:"></a>Archive:</h4><p>An Archive object represents a single data file, and contains a collection of Integration objects, also known as subintegrations. </p><pre><code>arch = pr.Archive_load('file.fits')arch.get_source()# '1744-1134'</code></pre><p>The <strong>get_data()</strong> method is an extra Python function that returns the raw data from the file as a NumPy array: </p><pre><code>data = arch.get_data()data.shape# (10, 4, 2048, 256)</code></pre><p>The dimensions of the data array are subintegration, polarization, channel, and profile bin. Important note: The get_data() function returns a copy of the Archive data. So changes made to the returned array will not be reflected in the Archive, and vice-versa.</p><p>Integrations within an Archive can be accessed in Python by indexing the Archive object use <strong>archive.get_Integration(isub)</strong> or <strong>archive[isub]</strong> methods. So the following two lines are equivalent: </p><pre><code>subint = arch.get_Integration(0)#等价subint = arch[0]</code></pre><h4 id="Integration"><a href="#Integration" class="headerlink" title="Integration:"></a>Integration:</h4><p>An Integration object represents a collection of pulse profiles recorded simultaneously, typically from a number of frequency channels and polarization states (Stokes parameters): </p><pre><code>subint.get_duration()# 60.230205439999999subint.get_nchan()# 2048</code></pre><p>The existing <strong>baseline_stats()</strong> and <strong>cal_levels()</strong> methods have been modified for Python to return tuples of arrays, for example: </p><pre><code>(b_mean, b_var) = subint.baseline_stats()b_mean.shape# (4, 2048)</code></pre><p>An Integration object contains a number of pulse profiles that can be accessed via  <strong>integration.get_Profile(ipol,ichan)</strong>: </p><pre><code>prof = subint.get_Profile(0,0)</code></pre><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile:"></a>Profile:</h4><p>A Profile object represents a single pulse profile. The <strong>profile.get_amps()</strong> method returns the profile data as a NumPy array: </p><pre><code>pdata = prof.get_amps()pdata.shape# (256,)</code></pre><p>In contrast to the <strong>arch.get_data()</strong> example above, the pdata array here points into the actual C++ data structure. So changes made to the array values will be reflected in the underlying Profile object.</p><p>The profile data values can also be read and/or altered by indexing the Profile object directly, for example: </p><pre><code>pdata[16]# 91.366058prof[16]#91.366058349609375prof[16] = 500.0pdata[16]# 500.0</code></pre><h4 id="Shortcut-to-get-all-data"><a href="#Shortcut-to-get-all-data" class="headerlink" title="Shortcut to get all data:"></a>Shortcut to get all data:</h4><p>Use <strong>archive.get_data()</strong> to return entire <strong>(Nsub, Npol, Nchan, Nbin)</strong> data cube as a NumPy array.</p><p>Examples:</p><pre><code>import psrchive as primport matplotlib.pyplot as pltarch = psrchive.Archive_load('file.fits') data = arch[0].get_Profile(0,200).get_amps()print(data.shape)# (1024,)plt.plot(data)</code></pre><div align="center"><img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/profile_example1.png" alt="" width="550"></div>```import psrchive as primport matplotlib.pyplot as plt<p>arch = psrchive.Archive_load(‘file.fits’)<br>data = arch.get_data()<br>print(data.shape)</p><h1 id="64-4-25-1024"><a href="#64-4-25-1024" class="headerlink" title="(64,4.25,1024)"></a>(64,4.25,1024)</h1><p>plt.plot(data[0,0,200:],’g’)</p><pre><code>&lt;div align="center"&gt;&lt;img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/profile_example2.png" alt="" width="550"&gt;&lt;/div&gt;####  Important: view and copyOne data access subtlety / gotcha:    **profile.get_amps()** returns a **view** of the original data    **archive.get_data()** returns a **copy** of the original dataThis means that if you want to modify the data in a file you need to change  the values in the results of profile.get_amps()Modified data files can be saved to disk using    **archive.unload(“new_filename”)**#### Plot profileArchive has a large number of methods (functions) for performing  common data processing steps.Common examples: dedisperse(), remove_baseline(), fscrunch(),  tscrunch(), pscrunch(), convert_state(), …archive.execute(“[psrsh code…]”) will run any psrsh command on  the archive.</code></pre><p>import psrchive as pr<br>import matplotlib.pyplot as plt</p><p>arch = psrchive.Archive_load(‘file.fits’)<br>arch.dedisperse()<br>arch.fscrunch()<br>arch.pscrunch()<br>arch.remove_baseline()<br>data = a[0].get_Profiel(0,0).get_amps()<br>plt.plot(data)</p><pre><code>&lt;div align="center"&gt;&lt;img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/preprocess.png" alt="" width="550"&gt;&lt;/div&gt;Looping over profiles, extracting data:</code></pre><p>import psrchive as pr</p><p>arch = psrchive.Archive_load(‘file.fits’) </p><p>for isub in range(a.get_nsubint())<br>    i = a[isub]<br>        for ichan in range(a.get_nchan()):<br>            print isub,ichan,i.get_Profiel(0,ichan).get_amps()[0]</p><pre><code>####  MJDThe MJD class is also now available in Python to deal with high-precision date/time values. Return values for date/time functions such as **Integration.get_epoch()** were previously converted to doubles for convenience.  To reproduce the old behavior and get a double-precision MJD value, use the **MJD.in_days()** method, for example:</code></pre><p>mjd_dbl = arch.get_Integration(0).get_start_time().in_days()</p><pre><code>####  Generating TOAs with Arrival TimeThe ArrivalTime class can be used to generate pulse times of arrival (TOAs) directly in Python, as an alternative to using the command-line utility pat.  Here is an example illustrating the basic usage:</code></pre><p>import psrchive</p><p>arrtim = psrchive.ArrivalTime()<br>arrtim.set_shift_estimator(‘PGS’)        # Set algorithm (see ‘pat -A’ help)<br>arrtim.set_format(‘Tempo2’)              # set TOA format<br>arrtim.set_format_flags(‘IPTA’)          # set some TOA flags<br>arrtim.set_attributes([‘chan’,’subint’]) # More TOA flags</p><h1 id="Load-template-profile"><a href="#Load-template-profile" class="headerlink" title="Load template profile"></a>Load template profile</h1><p>std = psrchive.Archive_load(‘J1713+0747.Rcvr1_2.GUPPI.9y.x.sum.sm’)<br>std.pscrunch()<br>arrtim.set_standard(std)</p><h1 id="Load-observation-profiles"><a href="#Load-observation-profiles" class="headerlink" title="Load observation profiles"></a>Load observation profiles</h1><p>obs = psrchive.Archive_load(‘guppi_55616_J1713+0747_0009.12y.x.ff’)<br>obs.pscrunch()<br>arrtim.set_observation(obs)</p><h1 id="Result-is-a-tuple-of-TOA-strings"><a href="#Result-is-a-tuple-of-TOA-strings" class="headerlink" title="Result is a tuple of TOA strings:"></a>Result is a tuple of TOA strings:</h1><p>toas = arrtim.get_toas()</p><pre><code>####  Simple ExampleIn this example, we recreate the helpful "pav -GTdp" plot using python, and demonstrate some common psrchive functionality:</code></pre><p>#! /usr/bin/env python<br>import pylab<br>import psrchive<br>arch = psrchive.Archive_load(‘1744_0001_0001.fits’)<br>arch.bscrunch_to_nbin(256)<br>arch.dedisperse()<br>arch.fscrunch_to_nchan(512)<br>arch.remove_baseline()<br>arch.convert_state(‘Stokes’)<br>data = arch.get_data()<br>freq_lo = arch.get_centre_frequency() - arch.get_bandwidth()/2.0<br>freq_hi = arch.get_centre_frequency() + arch.get_bandwidth()/2.0<br>pylab.imshow(data[:,0,:,:].mean(0),extent=(0,1,freq_lo,freq_hi))<br>pylab.xlabel(‘Pulse phase’)<br>pylab.ylabel(‘Frequency (MHz)’)<br>pylab.savefig(‘python_plot_example.png’)</p><pre><code>This results in the following plot: &lt;div align="center"&gt;&lt;img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/frequency.png" alt="" width="550"&gt;&lt;/div&gt;#### 3 TimingMost use cases only need  Archive, Integration,  and Profile classes.But some of the PSRCHIVE  algorithm classes are also  included in the Python  interface.For example,  ProfileShiftFit for doing  template-matching:No very comprehesive list of  these unfortunately.Browse  the C++ class docs, let me  know if you want something  added.</code></pre><p>import psrchive as pr<br>import matplotlib.pyplot as plt</p><p>a = psrchive.Archive_load(‘file.fits’).total()<br>s = psrchive.Archive_load(‘file.std’)<br>aprof = a[0].get_Profile(0,0)<br>sprof = s[0].get_Profile(0,0)</p><p>psf = pr.ProfileShiftFit()<br>psf.set_standard(sprof)<br>psr.set_Profile(aprof)<br>psr.get_shifts()</p><p>subplot(211); plot(aprof.get_a,ps())<br>subplot(212); plot(sprof.get_a,ps())</p><pre><code>&lt;div align="center"&gt;&lt;img src="https://github.com/AstronDog/blog-pic/raw/master/20200110psrpy/advance.png" alt="" width="550"&gt;&lt;/div&gt;### Archive Functions#### Public Member Functions##### Archivevoid **bscrunch** (unsigned nscrunch)     Integrate pulse profiles in phase. More...     void **pscrunch** ()     Integrate profiles in polarization. More...void **fscrunch** (unsigned nscrunch=0)     Integrate profiles in frequency. More...void **tscrunch** (unsigned nscrunch=0)     Integrate profiles in time. More...     void **remove_chan** (unsigned first, unsigned last)     Delete the specified inclusive channel range from the Archive.      #### Signal::Basis void**get_basis** () const     Convenience interface to Receiver::get_basis.void **dedisperse** ()     Rotate the Profiles to remove dispersion delays b/w chans. More...     void defaraday ()     Correct the Faraday rotation of Q into U. More...#### PhaseWeight void **baseline** () const     Return a new PhaseWeight instance with the baseline phase bins masked.void **remove_baseline** ()     Remove the baseline from all profiles.void **uniform_weight** (float new_weight=1.0)     Set the weight of each profile to the given number.      void **bscrunch_to_nbin** (unsigned new_nbin)     Call bscrunch with the appropriate value. More...void **fscrunch_to_nchan** (unsigned new_nchan)     Call fscrunch with the appropriate value. More...void **tscrunch_to_nsub** (unsigned new_nsub)     Call tscrunch with the appropriate value. More...MJD **start_time** () const     Return the MJD at the start of the first sub-integration.MJD **end_time** () const     Return the MJD at the end of the last sub-integration.double **integration_length** () const     Returns the total time integrated into all Integrations (in seconds) ### Common AttributesThese pure virtual methods provide access to the common attributes stored by all derived classes.virtual std::string **get_telescope** () const =0     Get the name of the telescope used.virtual void **set_telescope** (const std::string &amp;code)=0     Set the name of the telescope used.virtual Signal::State **get_state** () const =0     Get the state of the profile data.virtual void **set_state** (Signal::State state)=0     Set the state of the profile data.virtual Signal::Scale **get_scale** () const =0     Get the scale in which flux density is measured.virtual void **set_scale** (Signal::Scale scale)=0     Set the scale in which flux density is measured.virtual Signal::Source **get_type** () const =0     Get the observation type (psr, cal)virtual void **set_type** (Signal::Source type)=0     Set the observation type (psr, cal)virtual std::string **get_source** () const =0     Get the source name.virtual void **set_source** (const std::string &amp;source)=0     Set the source name.virtual sky_coord **get_coordinates** () const =0     Get the coordinates of the source.virtual void **set_coordinates** (const sky_coord &amp;coordinates)=0     Set the coordinates of the source.virtual double **get_centre_frequency** () const =0     Get the centre frequency of the observation.virtual void **set_centre_frequency** (double cf)=0     Set the centre frequency of the observation.virtual double **get_bandwidth** () const =0     Get the overall bandwidth of the observation.virtual void **set_bandwidth** (double bw)=0     Set the overall bandwidth of the observation.virtual double **get_dispersion_measure** () const =0     Get the dispersion measure (in ${\rm pc\, cm}^{-3}$)virtual void **set_dispersion_measure** (double dm)=0     Set the dispersion measure (in ${\rm pc\, cm}^{-3}$)virtual bool **get_dedispersed** () const =0     Inter-channel dispersion delay has been removed.virtual void **set_dedispersed** (bool done=true)=0     Set the value to be returned by get_dedispersed.virtual double **get_rotation_measure** () const =0     Get the rotation measure (in ${\rm rad\, m}^{-2}$)virtual void **set_rotation_measure** (double rm)=0     Set the rotation measure (in ${\rm rad\, m}^{-2}$)virtual bool **get_faraday_corrected** () const =0     Data has been corrected for ISM faraday rotation.virtual void **set_faraday_corrected** (bool done=true)=0     Set the value to be returned by get_ism_rm_corrected.virtual bool **get_poln_calibrated** () const =0     Data has been calibrated for polarimetric response of instrument.virtual void **set_poln_calibrated** (bool done=true)=0     Set the value to be returned by get_poln_calibrated.#### Dimension AttributesThese pure virtual methods are used by the Archive class to set the dimension attributes stored by the derived classes.virtual unsigned **get_nbin** () const =0     Get the number of pulsar phase bins used.virtual unsigned **get_nchan** () const =0     Get the number of frequency channels used.virtual unsigned **get_npol** () const =0     Get the number of polarizations.virtual void **set_nbin** (unsigned numbins)=0     Set the number of pulsar phase bins.virtual void **set_nchan** (unsigned numchan)=0     Set the number of frequency channels.virtual void **set_npol** (unsigned numpol)=0     Set the number of polarization measurements. virtual void **resize** (unsigned nsubint, unsigned npol=0, unsigned nchan=0, unsigned nbin=0)     Resize the Integration vector with new_Integration instances. More...virtual void **erase** (unsigned isubint)     Remove the specified sub-integration.## Astropy## Pypulse## pdat## Pint## References[ANTF](https://www.atnf.csiro.au/observers/data/ppdu_guide.html)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
            <tag> Software </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gnuplot</title>
      <link href="/2021/03/06/20210306-gnuplot/"/>
      <url>/2021/03/06/20210306-gnuplot/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Gnuplot"><a href="#Gnuplot" class="headerlink" title="Gnuplot"></a>Gnuplot</h1><h1 id="BASH"><a href="#BASH" class="headerlink" title="BASH"></a>BASH</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF Treatment</title>
      <link href="/2021/03/05/20210305-pdf-process/"/>
      <url>/2021/03/05/20210305-pdf-process/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Ubuntu下PDF文件处理"><a href="#Ubuntu下PDF文件处理" class="headerlink" title="Ubuntu下PDF文件处理"></a>Ubuntu下PDF文件处理</h1><h2 id="1-gs命令"><a href="#1-gs命令" class="headerlink" title="1. gs命令"></a>1. gs命令</h2><p>linux下可以直接用命令进行PDF的原生操作</p><p>使用命令：gs（GhostScript）</p><p>官网：<a href="https://www.ghostscript.com/">https://www.ghostscript.com/</a></p><p>安装该命令：<code>sudo apt-get install gs</code></p><h3 id="1-1-合并多个PDF为1个"><a href="#1-1-合并多个PDF为1个" class="headerlink" title="1.1 合并多个PDF为1个"></a>1.1 合并多个PDF为1个</h3><pre><code>gs -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=target.pdf -dBATCH 1.pdf 2.pdf ... n.pdf</code></pre><h3 id="1-2-单个PDF压缩"><a href="#1-2-单个PDF压缩" class="headerlink" title="1.2 单个PDF压缩"></a>1.2 单个PDF压缩</h3><pre><code>gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/prepress -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf-dPDFSETTINGS 参数描述：/prepress ：质量最好，文件最大/printer ：打印模式，推荐压缩/ebook ： 电子书模式，适合文本/screen ：文件最小，不推荐 </code></pre><h2 id="2-pdftk命令"><a href="#2-pdftk命令" class="headerlink" title="2. pdftk命令"></a>2. pdftk命令</h2><p>官网：<a href="http://www.pdflabs.com/docs/install-pdftk/">http://www.pdflabs.com/docs/install-pdftk/</a><br>安装该命令：<code>sudo snap install pdftk</code></p><h3 id="2-1-pdf文件合并"><a href="#2-1-pdf文件合并" class="headerlink" title="2.1 pdf文件合并"></a>2.1 pdf文件合并</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk in1.pdf in2.pdf <span class="token function">cat</span> output out.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-多个不同页面合并"><a href="#2-2-多个不同页面合并" class="headerlink" title="2.2 多个不同页面合并"></a>2.2 多个不同页面合并</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk A<span class="token operator">=</span>1.pdf B<span class="token operator">=</span>2.pdf C<span class="token operator">=</span>pdf <span class="token function">cat</span> A1-2 B2-3 C3 output abc.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-旋转第一页"><a href="#2-3-旋转第一页" class="headerlink" title="2.3 旋转第一页"></a>2.3 旋转第一页</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk in.pdf <span class="token function">cat</span> 1E 2-end output out.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-加密（128位）"><a href="#2-4-加密（128位）" class="headerlink" title="2.4 加密（128位）"></a>2.4 加密（128位）</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf owner_pw pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-加访问密码"><a href="#2-5-加访问密码" class="headerlink" title="2.5 加访问密码"></a>2.5 加访问密码</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf user_pw pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-6-解密"><a href="#2-6-解密" class="headerlink" title="2.6 解密"></a>2.6 解密</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf input_pw pass output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-7-解压"><a href="#2-7-解压" class="headerlink" title="2.7 解压"></a>2.7 解压</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf uncompress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-8-压缩"><a href="#2-8-压缩" class="headerlink" title="2.8 压缩"></a>2.8 压缩</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf compress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-9-修复"><a href="#2-9-修复" class="headerlink" title="2.9 修复"></a>2.9 修复</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-10-切割"><a href="#2-10-切割" class="headerlink" title="2.10 切割"></a>2.10 切割</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf <span class="token function">cat</span> 1-end output b.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-11-分解成单页"><a href="#2-11-分解成单页" class="headerlink" title="2.11 分解成单页"></a>2.11 分解成单页</h3><pre class="line-numbers language-bash"><code class="language-bash">pdftk a.pdf burst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-Imagemagick命令"><a href="#3-Imagemagick命令" class="headerlink" title="3. Imagemagick命令"></a>3. Imagemagick命令</h2><p>官网：<a href="http://www.imagemagick.org/">http://www.imagemagick.org</a></p><p>安装方法：<code>sudo apt-get install imagemagick</code></p><h3 id="3-1-PDF-TO-JPG"><a href="#3-1-PDF-TO-JPG" class="headerlink" title="3.1 PDF TO JPG"></a>3.1 PDF TO JPG</h3><p><code>convert -verbose -colorspace RGB -resize 1800 -interlace none -density 300 -quality 100 XXX.pdf XXX.jpg</code></p><p>参数：<br>-resize 1800：设置输出图片的宽度为1800像素，清晰度高了很多<br>-density 300：打印分辨率为300<br>-quality 100：JPG的质量为100%</p><h3 id="3-2-JPG-TO-PDF"><a href="#3-2-JPG-TO-PDF" class="headerlink" title="3.2 JPG TO PDF"></a>3.2 JPG TO PDF</h3><p>转换单个JPG：<code>convert x.jpg x.pdf</code><br>转换多个JPG为1个PDF：<code>convert *.jpg x.pdf</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Command</title>
      <link href="/2021/03/04/20210304-linux-command/"/>
      <url>/2021/03/04/20210304-linux-command/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>可以保持任务在远程连接断开之后，依然在保持执行。</p><h3 id="格式及状态"><a href="#格式及状态" class="headerlink" title="格式及状态"></a>格式及状态</h3><p>一般是格式是：id.windowName，id是系统自己分配的，windowName是创建时候自己命名的。</p><p>后面有状态detach（离线）或者attach（在线）或者dead（死进程）,离线在线代表的是是否有人再使用。</p><p>如果有时候在有个screen中，由于网络原因断开各种原因，会导致下次进来，screen状态是 attach，这个时候要回到该screen，就必须让其先离线,然后在进入。</p><p>如果是状态为dead，那么用screen -wipe id清理。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="创建会话："><a href="#创建会话：" class="headerlink" title="创建会话："></a>创建会话：</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">screen</span> -S session_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="进入会话："><a href="#进入会话：" class="headerlink" title="进入会话："></a>进入会话：</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">screen</span> -r session_id or session_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="回到主screen"><a href="#回到主screen" class="headerlink" title="回到主screen"></a>回到主screen</h4><p>（让某个screen后台运行）</p><pre class="line-numbers language-bash"><code class="language-bash">press <span class="token string">"ctrl + a"</span> and <span class="token keyword">then</span> press <span class="token string">"d"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看所有会话："><a href="#查看所有会话：" class="headerlink" title="查看所有会话："></a>查看所有会话：</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">screen</span> -ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="让某个screen离线"><a href="#让某个screen离线" class="headerlink" title="让某个screen离线"></a>让某个screen离线</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">screen</span> -d <span class="token function">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="关闭会话："><a href="#关闭会话：" class="headerlink" title="关闭会话："></a>关闭会话：</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">screen</span> -X -S screen_id quit<span class="token comment" spellcheck="true"># 或者进入screen后输入 </span><span class="token keyword">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="嵌套会话"><a href="#嵌套会话" class="headerlink" title="嵌套会话"></a>嵌套会话</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#就是 Screen 会话中的 Screen 会话</span>Ctrl a+c 快捷键来启动一个新的 Screen 会话Ctrl a+n 快捷键切换至下一个 Screen 会话Ctrl a+p 快捷键切换至上一个 Screen 会话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pdftk"><a href="#pdftk" class="headerlink" title="pdftk"></a>pdftk</h2><p>“pdftk” 代表 “PDF 工具包”（PDF tool kit），可以实现包括合并、拆分、旋转、加密和解密、添加水印、压缩和解压缩等功能。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ sudo apt-get install pdftk</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><pre><code>#普通合并pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf#制定页面合并 (将one.pdf的前7页，two.pdf的前5页，one.pdf的第8页按先后顺序合并成combined.pdf)pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf</code></pre><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><pre><code>#拆分PDF的每一页为一个新文件 并按照指定格式设定文件名$ pdftk input.pdf burst output new_%d.pdf</code></pre><h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><pre><code>#提取1-15页为一个文件$ pdftk input.pdf cat 1-15 output new.pdf#提取第1至3，第5，第6至10页，并合并为一个pdf文件$ pdftk input.pdf cat 1-3 5 6-10 output combined.pdf</code></pre><h4 id="删除某页"><a href="#删除某页" class="headerlink" title="删除某页"></a>删除某页</h4><pre><code>#去除第 13 页,其余的保存为新PDF$ pdftk in.pdf cat 1-12 14-end output out1.pdf</code></pre><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><pre><code>#去除第 13 页,其余的保存为新PDF$ pdftk in.pdf cat 1-12 14-end output out1.pdf</code></pre><h4 id="加密、解密"><a href="#加密、解密" class="headerlink" title="加密、解密"></a>加密、解密</h4><pre><code>#加密（128位）pdftk a.pdf output b.pdf owner_pw pass#加访问密码pdftk a.pdf output b.pdf user_pw pass#解密pdftk a.pdf input_pw pass output b.pdf</code></pre><h4 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h4><pre><code>#解压pdftk a.pdf output b.pdf uncompress#压缩pdftk a.pdf output b.pdf compress</code></pre><h4 id="分解成单页"><a href="#分解成单页" class="headerlink" title="分解成单页"></a>分解成单页</h4><pre><code>pdftk a.pdf burst</code></pre><h2 id="grep和egrep命令"><a href="#grep和egrep命令" class="headerlink" title="grep和egrep命令"></a>grep和egrep命令</h2><p>grep 代表“全局正则表达式打印”，用于将<strong>正则表达式</strong>与<strong>文件</strong>或<strong>输入流中</strong>的文本进行匹配。 它搜索您在命令行上指定的文本的 PATTERN，并为您输出结果。用于过滤/搜索的特定字符。可使用<strong>正则表达式</strong>配合多种命令使用。</p><h3 id="命令格式如下："><a href="#命令格式如下：" class="headerlink" title="命令格式如下："></a>命令格式如下：</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># grep [OPTIONS] PATTERN [FILE...]</span><span class="token comment" spellcheck="true">#在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="主要选项-options"><a href="#主要选项-options" class="headerlink" title="主要选项[options]:"></a>主要选项[options]:</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">grep</span> --help可查看-E: 使用扩展正则表达式-c：只输出匹配行的计数。-i：不区分大小写。-h：查询多文件时不显示文件名。-l：查询多文件时只输出包含匹配字符的文件名。-n：显示匹配行及行号。-r：在多级目录中对文本进行递归搜索-s：不显示不存在或无匹配文本的错误信息。-v：显示不包含匹配文本的所有行。--color<span class="token operator">=</span>auto ：可以将找到的关键词部分加上颜色的显示。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pattern正则表达式主要参数"><a href="#pattern正则表达式主要参数" class="headerlink" title="pattern正则表达式主要参数:"></a>pattern正则表达式主要参数:</h3><pre class="line-numbers language-bash"><code class="language-bash">    ^    <span class="token comment" spellcheck="true"># 锚定行的开始 如：'^grep'匹配所有以grep开头的行。    </span>    $    <span class="token comment" spellcheck="true"># 锚定行的结束 如：'grep$' 匹配所有以grep结尾的行。</span>    <span class="token keyword">.</span>    <span class="token comment" spellcheck="true"># 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    </span>    *    <span class="token comment" spellcheck="true"># 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    </span>    .*   <span class="token comment" spellcheck="true"># 一起用代表任意字符。   </span>    +    <span class="token comment" spellcheck="true">#匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</span>    ?    <span class="token comment" spellcheck="true">#匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    </span>    <span class="token punctuation">[</span>^<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span>    \<span class="token punctuation">(</span><span class="token punctuation">..</span>\<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 标记匹配字符，如'\(love\)'，love被标记为1。    </span>    \<span class="token operator">&lt;</span>      <span class="token comment" spellcheck="true"># 锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。    </span>    \<span class="token operator">></span>      <span class="token comment" spellcheck="true"># 锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。    </span>    x\<span class="token punctuation">{</span>m\<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    </span>    x\<span class="token punctuation">{</span>m,\<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true"># 重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    </span>    x\<span class="token punctuation">{</span>m,n\<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   </span>    \w    <span class="token comment" spellcheck="true"># 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   </span>    \W    <span class="token comment" spellcheck="true"># \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span>    \b    <span class="token comment" spellcheck="true"># 单词锁定符，如: '\bgrep\b'只匹配grep。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><p>sed 是 stream editor 的缩写，中文称之为“流编辑器”。</p><p>sed 命令是一个面向行处理的工具，它以“行”为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出（STDOUT）。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sed</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">'command'</span> file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token function">sed</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> -f scriptfile file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre class="line-numbers language-bash"><code class="language-bash">-e<span class="token operator">&lt;</span>script<span class="token operator">></span>或--expression<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>：以选项中的指定的script来处理输入的文本文件；-f<span class="token operator">&lt;</span>script文件<span class="token operator">></span>或--file<span class="token operator">=</span><span class="token operator">&lt;</span>script文件<span class="token operator">></span>：以选项中指定的script文件来处理输入的文本文件；-h或--help：显示帮助；-n或--quiet或——silent：仅显示script处理后的结果；-V或--version：显示版本信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre class="line-numbers language-bash"><code class="language-bash">a\ 在当前行下面插入文本。i\ 在当前行上面插入文本。c\ 把选定的行改为新的文本。d 删除，删除选择的行。D 删除模板块的第一行。s 替换指定字符h 拷贝模板块的内容到内存中的缓冲区。H 追加模板块的内容到内存中的缓冲区。g 获得内存缓冲区的内容，并替代当前模板块中的文本。G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。l 列表不能打印字符的清单。n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。p 打印模板块的行。P<span class="token punctuation">(</span>大写<span class="token punctuation">)</span> 打印模板块的第一行。q 退出Sed。b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。r <span class="token function">file</span> 从file中读行。t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。w <span class="token function">file</span> 写并追加模板块到file末尾。  W <span class="token function">file</span> 写并追加模板块的第一行到file末尾。  <span class="token operator">!</span> 表示后面的命令对所有没有被选定的行发生作用。  <span class="token operator">=</span> 打印当前行号码。  <span class="token comment" spellcheck="true"># 把注释扩展到下一个换行符以前。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sed替换标记"><a href="#sed替换标记" class="headerlink" title="sed替换标记"></a>sed替换标记</h3><pre class="line-numbers language-bash"><code class="language-bash">g 表示行内全面替换。  p 表示打印行。  w 表示把行写入一个文件。  x 表示互换模板块中的文本和缓冲区中的文本。  y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）\1 子串匹配标记<span class="token operator">&amp;</span> 已匹配字符串标记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>1. sed -i '/preSql/d' a.txt－－－删除匹配到preSql的行2. sed -i '1d' a.txt－－－删除第一行3. sed -i '3~2d' a.txt－－－从第三行开始,每隔一行删除4. sed -i '4,8d' a.txt－－－删除从第４行到第８行5. sed -i '$d'  a.txt－－－删除最后一行6. sed '/^$/d' a.txt－－－删除所有空行7. sed -i  '/Website Design/,$d' a.txt－－－从匹配行到末尾行8. sed -i  '/Storage/,+2d' a.txt－－－删除匹配行和之后两行</code></pre><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><h3 id="命令格式和选项"><a href="#命令格式和选项" class="headerlink" title="命令格式和选项"></a>命令格式和选项</h3><h4 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">awk</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">'script'</span> var<span class="token operator">=</span>value file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token function">awk</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> -f scriptfile var<span class="token operator">=</span>value file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h4><pre class="line-numbers language-bash"><code class="language-bash">-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:-v var<span class="token operator">=</span>value   赋值一个用户定义变量，将外部变量传递给awk-f scripfile  从脚本文件中读取awk命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>log.txt文本内容如下：</p><pre><code>2 this is a test3 Are you like awkThis's a test10 There are orange,apple,mongo</code></pre><p>用法一：</p><pre><code>awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号</code></pre><p>实例：</p><pre><code># 每行按空格或TAB分割，输出文本中的1、4项 $ awk '{print $1,$4}' log.txt --------------------------------------------- 2 a 3 like This's 10 orange,apple,mongo # 格式化输出 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt --------------------------------------------- 2        a 3        like This's 10       orange,apple,mongo </code></pre><p>用法二：</p><pre><code>awk -F  #-F相当于内置变量FS, 指定分割字符</code></pre><p>实例：</p><pre><code># 使用","分割 $  awk -F, '{print $1,$2}'   log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This's a test 10 There are orange apple # 或者使用内建变量 $ awk 'BEGIN{FS=","} {print $1,$2}'     log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This's a test 10 There are orange apple # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割 $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt --------------------------------------------- 2 this test 3 Are awk This's a 10 There apple</code></pre><p>用法三：</p><pre><code>awk -v  # 设置变量</code></pre><p>实例：</p><pre><code> $ awk -va=1 '{print $1,$1+a}' log.txt --------------------------------------------- 2 3 3 4 This's 1 10 11 $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt --------------------------------------------- 2 3 2s 3 4 3s This's 1 This'ss 10 11 10s</code></pre><p>用法四：</p><pre><code>awk -f {awk脚本} {文件名}</code></pre><p>实例：</p><pre><code> $ awk -f cal.awk log.txt</code></pre><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=, +=, -=, *=, /=, %=, ^=, **=</td><td align="center">赋值</td></tr><tr><td align="center">?:</td><td align="center">C条件表达式</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">~ 和 !~</td><td align="center">匹配正则表达式和不匹配正则表达式</td></tr><tr><td align="center">&lt;, &lt;=, &gt;, &gt;=, !=, ==</td><td align="center">关系运算符</td></tr><tr><td align="center">空格</td><td align="center">连接</td></tr><tr><td align="center">+, -</td><td align="center">加，减</td></tr><tr><td align="center">*, /, %</td><td align="center">乘，除与求余</td></tr><tr><td align="center">+, -, !</td><td align="center">一元加，减和逻辑非</td></tr><tr><td align="center">^ <em>,</em>*</td><td align="center">求幂</td></tr><tr><td align="center">++, –</td><td align="center">增加或减少，作为前缀或后缀</td></tr><tr><td align="center">$</td><td align="center">字段引用</td></tr><tr><td align="center">in</td><td align="center">数组成员</td></tr></tbody></table><p>过滤第一列大于2的行</p><pre><code>$ awk '$1&gt;2' log.txt    #命令#输出3 Are you like awkThis's a test10 There are orange,apple,mongo</code></pre><p>过滤第一列等于2的行</p><pre><code>$ awk '$1==2 {print $1,$3}' log.txt    #命令#输出2 is</code></pre><p>过滤第一列大于2并且第二列等于’Are’的行</p><pre><code>$ awk '$1&gt;2 &amp;&amp; $2=="Are" {print $1,$2,$3}' log.txt    #命令#输出3 Are you</code></pre><hr><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">$n</td><td align="center">当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td align="center">$0</td><td align="center">完整的输入记录</td></tr><tr><td align="center">ARGC</td><td align="center">命令行参数的数目</td></tr><tr><td align="center">ARGIND</td><td align="center">命令行中当前文件的位置(从0开始算)</td></tr><tr><td align="center">ARGV</td><td align="center">包含命令行参数的数组</td></tr><tr><td align="center">CONVFMT</td><td align="center">数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td></tr><tr><td align="center">ERRNO</td><td align="center">最后一个系统错误的描述</td></tr><tr><td align="center">FIELDWIDTHS</td><td align="center">字段宽度列表(用空格键分隔)</td></tr><tr><td align="center">FILENAME</td><td align="center">当前文件名</td></tr><tr><td align="center">FNR</td><td align="center">各文件分别计数的行号</td></tr><tr><td align="center">FS</td><td align="center">字段分隔符(默认是任何空格)</td></tr><tr><td align="center">IGNORECASE</td><td align="center">如果为真，则进行忽略大小写的匹配</td></tr><tr><td align="center">NF</td><td align="center">一条记录的字段的数目</td></tr><tr><td align="center">NR</td><td align="center">已经读出的记录数，就是行号，从1开始</td></tr><tr><td align="center">OFMT</td><td align="center">数字的输出格式(默认值是%.6g)</td></tr><tr><td align="center">OFS</td><td align="center">输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td></tr><tr><td align="center">ORS</td><td align="center">输出记录分隔符(默认值是一个换行符)</td></tr><tr><td align="center">RLENGTH</td><td align="center">由match函数所匹配的字符串的长度</td></tr><tr><td align="center">RS</td><td align="center">记录分隔符(默认是一个换行符)</td></tr><tr><td align="center">RSTART</td><td align="center">由match函数所匹配的字符串的第一个位置</td></tr><tr><td align="center">SUBSEP</td><td align="center">数组下标分隔符(默认值是/034)</td></tr></tbody></table><pre><code>$ awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txtFILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS---------------------------------------------log.txt    2    1         5    1log.txt    2    2         5    2log.txt    2    3         3    3log.txt    2    4         4    4$ awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txtFILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS---------------------------------------------log.txt    2    1    '    1    1log.txt    2    2    '    1    2log.txt    2    3    '    2    3log.txt    2    4    '    1    4# 输出顺序号 NR, 匹配文本行号$ awk '{print NR,FNR,$1,$2,$3}' log.txt---------------------------------------------1 1 2 this is2 2 3 Are you3 3 This's a test4 4 10 There are# 指定输出分割符$  awk '{print $1,$2,$5}' OFS=" $ "  log.txt---------------------------------------------2 $ this $ test3 $ Are $ awkThis's $ a $10 $ There $</code></pre><hr><h3 id="使用正则，字符串匹配"><a href="#使用正则，字符串匹配" class="headerlink" title="使用正则，字符串匹配"></a>使用正则，字符串匹配</h3><pre><code># 输出第二列包含 "th"，并打印第二列与第四列$ awk '$2 ~ /th/ {print $2,$4}' log.txt---------------------------------------------this a</code></pre><p><strong>~ 表示模式开始。// 中是模式。</strong></p><pre><code># 输出包含 "re" 的行$ awk '/re/ ' log.txt---------------------------------------------3 Are you like awk10 There are orange,apple,mongo</code></pre><hr><h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><pre><code>$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt---------------------------------------------2 this is a testThis's a test</code></pre><hr><h3 id="模式取反"><a href="#模式取反" class="headerlink" title="模式取反"></a>模式取反</h3><pre><code>$ awk '$2 !~ /th/ {print $2,$4}' log.txt---------------------------------------------Are likeaThere orange,apple,mongo$ awk '!/th/ {print $2,$4}' log.txt---------------------------------------------Are likeaThere orange,apple,mongo</code></pre><hr><h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。</p><ul><li>BEGIN{ 这里面放的是执行前的语句 }</li><li>END {这里面放的是处理完所有的行后要执行的语句 }</li><li>{这里面放的是处理每一行时要执行的语句}</li></ul><p>假设有这么一个文件（学生成绩表）：</p><pre><code>$ cat score.txtMarry   2143 78 84 77Jack    2321 66 78 45Tom     2122 48 77 71Mike    2537 87 97 95Bob     2415 40 57 62</code></pre><p>我们的 awk 脚本如下：</p><pre><code>$ cat cal.awk#!/bin/awk -f#运行前BEGIN {    math = 0    english = 0    computer = 0     printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"    printf "---------------------------------------------\n"}#运行中{    math+=$3    english+=$4    computer+=$5    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5}#运行后END {    printf "---------------------------------------------\n"    printf "  TOTAL:%10d %8d %8d \n", math, english, computer    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR}</code></pre><p>我们来看一下执行结果：</p><pre><code>$ awk -f cal.awk score.txtNAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL---------------------------------------------Marry  2143     78       84       77      239Jack   2321     66       78       45      189Tom    2122     48       77       71      196Mike   2537     87       97       95      279Bob    2415     40       57       62      159---------------------------------------------  TOTAL:       319      393      350AVERAGE:     63.80    78.60    70.00</code></pre><hr><h3 id="另外一些实例"><a href="#另外一些实例" class="headerlink" title="另外一些实例"></a>另外一些实例</h3><p>AWK 的 hello world 程序为：</p><pre><code>BEGIN { print "Hello, world!" }</code></pre><p>计算文件大小</p><pre><code>$ ls -l *.txt | awk '{sum+=$5} END {print sum}'--------------------------------------------------666581</code></pre><p>从文件中找出长度大于 80 的行：</p><pre><code>awk 'length&gt;80' log.txt</code></pre><p>打印九九乘法表</p><pre><code>seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'</code></pre><h2 id="column命令"><a href="#column命令" class="headerlink" title="column命令"></a>column命令</h2><p>column命令的作用是将其输入格式化为多个列。在列之前填充行。输入可以来自文件，或默认情况下来自标准输入。除非使用-e选项，否则将忽略空行。 </p><h3 id="命令格式和选项-1"><a href="#命令格式和选项-1" class="headerlink" title="命令格式和选项"></a>命令格式和选项</h3><h4 id="语法形式-1"><a href="#语法形式-1" class="headerlink" title="语法形式"></a>语法形式</h4><pre class="line-numbers language-bash"><code class="language-bash">column <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="常用命令选项-1"><a href="#常用命令选项-1" class="headerlink" title="常用命令选项"></a>常用命令选项</h4><pre class="line-numbers language-bash"><code class="language-bash">-s sep指定一组字符，用于分隔-t选项的列-t确定输入包含的列数并创建表-n禁用将多个相邻分隔符合并为单个分隔符行为-c columns输出格式化为显示columns列宽-x在填充行之前填充列-e不要忽略空白行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Talent Programme</title>
      <link href="/2020/09/15/20200915-talent-programme/"/>
      <url>/2020/09/15/20200915-talent-programme/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="科技部-中科院"><a href="#科技部-中科院" class="headerlink" title="科技部,中科院"></a>科技部,中科院</h1><h2 id="青年千人"><a href="#青年千人" class="headerlink" title="青年千人"></a>青年千人</h2><h2 id="中科院“百人计划”C类（青年俊才）"><a href="#中科院“百人计划”C类（青年俊才）" class="headerlink" title="中科院“百人计划”C类（青年俊才）"></a>中科院“百人计划”C类（青年俊才）</h2><h3 id="申请条件"><a href="#申请条件" class="headerlink" title="申请条件"></a>申请条件</h3><ol><li><p>具有博士学位，在海外知名大学、科研机构等学习或工作3年（含）以上；特别优秀者海外学习及工作年限可适当放宽；</p></li><li><p>在本研究领域已崭露头角，做出过具有突出创新思想的研究成果；</p></li><li><p>具有优良的科技创新潜质和较好的团队协作能力；</p></li><li><p>申报时取得博士学位时间未超过5年；</p></li><li><p>恪守学术道德，学风正派、诚实守信、严谨治学。</p></li></ol><h3 id="提供待遇-中科大"><a href="#提供待遇-中科大" class="headerlink" title="提供待遇(中科大)"></a>提供待遇(中科大)</h3><ol><li>通过校优秀人才引进学术委员会审议，纳入学校“特任研究员”岗位进行管理；</li><li>报到时学校提供不少于100万元的科研启动经费；</li><li>到位工作2年内，中科院给予C类候选人人才专项经费80万元；</li><li>通过院择优支持评审后，院给予C类入选者人才专项经费200万元，基建经费60万元，其中基建费可用于自行购买商品住房；<br>4．若在聘期内入选教育部“长江学者奖励计划”特聘教授，或获得“国家杰出青年科学基金”，将自动获得学校固定教职，转为教授岗位（正高级专业技术职务）；</li><li>入校即可享受校内周转房；</li><li>学校安排子女入学入托。</li></ol><h2 id="优青"><a href="#优青" class="headerlink" title="优青"></a>优青</h2><h3 id="申请条件-1"><a href="#申请条件-1" class="headerlink" title="申请条件"></a>申请条件</h3><p>(1)遵守中华人民共和国法律法规及科学基金的各项管理规定，具有良好的科学道德，自觉践行新时代科学家精神；</p><p>(2)申请当年1月1日男性未满38周岁[1982年1月1日(含)以后出生]，女性未满40周岁[1980年1月1日(含)以后出生]；</p><p>(3)具有高级专业技术职务(职称)或者博士学位；</p><p>(4)具有承担基础研究课题或者其他从事基础研究的经历；</p><p>(5)与境外单位没有正式聘用关系；</p><p>(6)保证资助期内每年在依托单位从事研究工作的时间在9个月以上。</p><h3 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h3><h1 id="浙江"><a href="#浙江" class="headerlink" title="浙江"></a>浙江</h1><h2 id="“青年高层次人才计划”"><a href="#“青年高层次人才计划”" class="headerlink" title="“青年高层次人才计划”"></a>“青年高层次人才计划”</h2><h3 id="申请条件："><a href="#申请条件：" class="headerlink" title="申请条件："></a>申请条件：</h3><ol><li>年龄不超过35周岁（截止2020年）</li><li>海外博士学历</li><li>博士毕业后海外持续工作（含博后）3年及以上</li><li>未全职在国内工作或在国内工作不超过一年</li></ol><h3 id="提供待遇"><a href="#提供待遇" class="headerlink" title="提供待遇"></a>提供待遇</h3><p>如申请成功可获得省级青年专家头衔，并有250万起的政府补助，同时可优先申报国家级青年人才计划 。</p><ol><li><p>住房保障: 对于省级青年高层次人才购买商品住房的，一次性给予80万元购房补贴；或给予省级青年人才每年5万元租房补贴，租房补贴发放时间不超过10年，已享受的租房补贴在购买商品住房时予以扣减。</p></li><li><p>子女入学: 对全职到岗的省级青年高层次人才子女，在义务教育阶段就读国内私立学校的，每年按学费的30%，给予最高5万元的补助；入读区内公办学校的，由教育部门优先统筹安排。</p></li><li><p>落户办理: 省级青年高层次人才可申请在本地落户。</p></li><li><p>其他: 省级青年高层次人才可享受一年一次的健康体检、两年一次的疗休养以及各类专题培训。</p></li></ol><h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><p>浙江大学</p><p>(宁波大学)</p><h1 id="江苏"><a href="#江苏" class="headerlink" title="江苏"></a>江苏</h1><h2 id="江苏省“双创计划”-之双创博士—–世界名校类别"><a href="#江苏省“双创计划”-之双创博士—–世界名校类别" class="headerlink" title="江苏省“双创计划” 之双创博士—–世界名校类别"></a>江苏省“双创计划” 之双创博士—–世界名校类别</h2><h3 id="申请条件-2"><a href="#申请条件-2" class="headerlink" title="申请条件"></a>申请条件</h3><p>1．申报人应具有博士学位，其中境外学位需提供教育部留学服务中心学历认证；年龄一般不超过35周岁（1985年1月1日后出生）。<br>2．申报人为2019年1月1日至12月31日之间首次到江苏工作，以单位实际发放工资时间为准（须提供申报单位代扣代缴个人所得税完税证明和个人工资银行流水）。<br>3．全职在江苏工作，原则上要求正式进编，缴纳事业单位养老保险。如申报单位实行人员总量管理，须出具说明，提供长期聘用合同和社保缴费清单。外籍人才不能进编、缴纳保险的，须提供长期聘用合同、出入境记录。<br>4．已获得国家重大人才工程A类以及省“双创计划”和“江苏特聘教授”“江苏特聘医学专家”资助的人才，不得申报；不得与2020年省“双创人才”同时申报。<br>5. 到我省高校、科研院所、医院工作的世界名校博士须全职全时在申报单位工作。世界名校名录以《泰晤士高等教育》世界大学排名、QS世界大学排名、《美国新闻与世界报道》世界大学排名、上海交大世界大学学术排名公布的2019年世界200强高校和不列入排名范围的中国科学院大学为准，符合其中之一即可。世界名校类遴选采用认定制。</p><h3 id="提供待遇-1"><a href="#提供待遇-1" class="headerlink" title="提供待遇"></a>提供待遇</h3><p>对入选的双创博士，两年内省级财政给予总共15万元的创新创业资金资助。</p><h2 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h2><p>南京大学</p><p>南京航空航天大学</p><p>东南大学,南京理工大学,</p><p>中国矿业大学</p><p>河海大学</p><p>南京农业大学</p><p>南京师范大学</p><p>中国药科大学</p><h2 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h2><p>苏州大学</p><h2 id="无锡"><a href="#无锡" class="headerlink" title="无锡"></a>无锡</h2><p>江南大学</p><h1 id="湖北"><a href="#湖北" class="headerlink" title="湖北"></a>湖北</h1><h2 id="湖北省青年百人"><a href="#湖北省青年百人" class="headerlink" title="湖北省青年百人"></a>湖北省青年百人</h2><h3 id="申请条件：-1"><a href="#申请条件：-1" class="headerlink" title="申请条件："></a>申请条件：</h3><ol><li><p>属自然科学、工程技术或金融领域，年龄不超过40周岁（1978年6月1日后出生）；</p></li><li><p>具有海外知名高校或海外高校世界一流学科博士学位，或在国内知名高校取得博士学位后有连续3年及以上海外科研工作经历（不包括在国内单位保留人事关系、保留职位且领取薪酬的海外工作经历）；</p></li><li><p>自然科学和工程技术类申报人需具有海外知名高校、科研机构、世界500强或其他国际知名企业及研发机构正式教学或科研职位任职经历；金融类申报人需具有海外知名高校、国际经济组织、专业机构或海外知名金融机构全职工作经历;</p></li><li><p>在2015年6月1日后回国（来华）工作（服务），且2018年8月31日前签订工作（意向）合同。入选后全职在鄂工作3年以上；</p></li><li><p>自然科学和工程技术类申报人需在海外主持或作为核心成员参与过科研项目，取得同行专家认可的科研成果，具有成为该领域学术或技术带头人的发展潜力；金融类申报人需具有国际通用的经济类金融方向职称或职业资格;</p></li><li><p>申报单位为高等学校、科研机构、国有企业和国有金融机构。</p></li></ol><p>在海外取得博士学位、业绩特别突出或为我省急需紧缺的人才，可适当放宽海外任职要求，申报时需在附件材料中提供破格申报说明。国外高校毕业、来华从事博士后研究的非华裔人员，出站一年内可申报青年百人项目。</p><h2 id="楚天学者计划-每年50人"><a href="#楚天学者计划-每年50人" class="headerlink" title="楚天学者计划(每年50人)"></a>楚天学者计划(每年50人)</h2><p>全省每年招聘楚天学子50名，聘期为五年。</p><h3 id="申请条件：-2"><a href="#申请条件：-2" class="headerlink" title="申请条件："></a>申请条件：</h3><ol><li><p>道德高尚，学风严谨，富有合作精神；</p></li><li><p>在世界排名前300位的大学获博士学位，或在前述高校和国外著名研究机构任职1年以上并获突出成果；</p></li><li><p>年龄不超过40周岁；</p></li><li><p>在受聘高校全职工作。</p></li></ol><h3 id="提供待遇-2"><a href="#提供待遇-2" class="headerlink" title="提供待遇"></a>提供待遇</h3><ol><li><p>楚天学子每人每年岗位津贴人民币10万元，基本薪酬不低于28万元/年</p></li><li><p>协助解决子女入学，协助解决配偶工作。</p></li><li><p>按实际需要提供科研经费，理工医类不低于50万元，其他类不低于15万元。</p></li></ol><p>武汉大学</p><p>华中科技大学</p><p>武汉理工大学</p><p>华中师范大学</p><p>中南财经政法大学</p><p>华中农业大学</p><p>中国地质大学(武汉)</p><h1 id="安徽"><a href="#安徽" class="headerlink" title="安徽"></a>安徽</h1><h2 id="安徽省百人"><a href="#安徽省百人" class="headerlink" title="安徽省百人"></a>安徽省百人</h2><h3 id="申请条件-3"><a href="#申请条件-3" class="headerlink" title="申请条件"></a>申请条件</h3><ol><li><p>一般应在海外取得博士学位，年龄不超过55岁；入选后应全职（每年不少于9个月），在我省连续工作不少于3年。 </p></li><li><p>为在国外著名高校、科研院所担任高级专业技术职务的专家学者。 </p></li><li><p>应在申报年度1月1日之后回国来皖工作，已与我校签订正式工作合同。</p></li><li><p>在国外著名高校、科研院所担任高级专业技术职务的专家学者，或在国际知名企业和金融机构担任高级职务的专业技术人才和经营管理人才。</p></li></ol><p>同时，还需具备下列条件之一：</p><p> 1）依托重点创新项目引进的，需在重大专项涉及的领域，能够解决关键技术和工艺的操作性难题，或拥有市场开发前景的自主创新产品；或者在海外承担过与重大专项相关的重大项目，具有较强的产品开发能力。</p><p> 2）依托重点学科和重点实验室引进的，需具有国际领先、国内先进研究水平，近5年在国际核心刊物上发表过具有重要影响的学术论文；获得国际、国内重要科技奖项（省级科学技术二等奖以上），掌握重要实验技能或科学工程建设关键技术。</p><h3 id="提供待遇-3"><a href="#提供待遇-3" class="headerlink" title="提供待遇"></a>提供待遇</h3><p>  安徽省给予入选者每人50万元的生活补贴。</p><h2 id="青年皖江学者"><a href="#青年皖江学者" class="headerlink" title="青年皖江学者"></a>青年皖江学者</h2><h3 id="申请条件-4"><a href="#申请条件-4" class="headerlink" title="申请条件"></a>申请条件</h3><ol><li><p>在申报认定的近3年自主培养的，或近1年内引进的，引进的必须与引进学校签订不少于3年的全职正式合同；</p></li><li><p>年龄原则上在35周岁以下（1983年1月1日以后出生）。特别优秀的，可适当放宽年龄要求；</p></li><li><p>在国（境）外或国内高水平大学取得博士学位，并具有2年以上国（境）外工作经历或国（境）外高水平大学、科研机构或高科技企业研发机构博士后经历。具有独特专长（技艺技能）且在行业具有一定影响力的优秀人才，可适当放宽学历学位等方面要求；</p></li><li><p>在国（境）外高水平大学、科研机构或高科技企业研发机构等有正式教学或科研职位；或在国内高水平大学、科研机构或高科技企业研发机构等担任副高级及以上专业技术职务；</p></li><li><p>在学术上崭露头角，具有很好的科研基础，创新能力强，发展潜力大。</p></li></ol><h3 id="提供待遇-4"><a href="#提供待遇-4" class="headerlink" title="提供待遇"></a>提供待遇</h3><p>（1）提供科研启动费：自然科学类50 万元，人文社科类15万元。 </p><p>（2）提供安家费和购房补贴40万元。 </p><p>（3）聘为教授或研究员，享受相关的工资待遇，首聘期另享受10万元/  年的人才津贴。 </p><p>（4）聘为博士生导师，每年给予博士研究生和硕士研究生招生指标。 </p><p>（5）提供良好的办公和科研等工作条件，配备工作助手。 </p><p>（6）解决配偶工作，协助解决子女入学</p><p>中国科学技术大学</p><p>合肥工业大学</p><p>安徽大学</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leisure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
            <tag> Career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex Formula</title>
      <link href="/2020/04/30/20200430-formula/"/>
      <url>/2020/04/30/20200430-formula/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Latex中的数学公式"><a href="#Latex中的数学公式" class="headerlink" title="Latex中的数学公式"></a>Latex中的数学公式</h1><h2 id="1-包的引用"><a href="#1-包的引用" class="headerlink" title="1. 包的引用"></a>1. 包的引用</h2><p>要使用amsmath或者mathtools包，请在文档的起始处包括：</p><pre class="line-numbers language-bash"><code class="language-bash">\usepackage <span class="token punctuation">{</span>amsmath<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\usepackage</span> <span class="token punctuation">{</span>mathtools<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>mathtools</strong>包会自动加载<strong>amsmath</strong>包，因此如果<strong>mathtools</strong>被使用，就不必再添加<code>\usepackage {amsmath}</code>。</p><h2 id="2-常用符号"><a href="#2-常用符号" class="headerlink" title="2. 常用符号"></a>2. 常用符号</h2><h3 id="2-1-直接使用的符号"><a href="#2-1-直接使用的符号" class="headerlink" title="2.1 直接使用的符号"></a>2.1 直接使用的符号</h3><p>数学有很多符号！有一组符号可以直接从键盘访问：</p><pre class="line-numbers language-xml"><code class="language-xml">+ - = ! / ( ) [ ] &lt; > | ' :  *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-三角函数"><a href="#2-2-三角函数" class="headerlink" title="2.2 三角函数"></a>2.2 三角函数</h3><table><thead><tr><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th></tr></thead><tbody><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csin" alt="\sin"></td><td align="center"><code>\sin</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Carcsin" alt="\arcsin"></td><td align="center"><code>\arcsin</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csinh" alt="\sinh"></td><td align="center"><code>\sinh</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csec" alt="\sec"></td><td align="center"><code>\sec</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccos" alt="\cos"></td><td align="center"><code>\cos</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Carccos" alt="\arccos"></td><td align="center"><code>\arccos</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccosh" alt="\cosh"></td><td align="center"><code>\cosh</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccsc" alt="\csc"></td><td align="center"><code>\csc</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctan" alt="\tan"></td><td align="center"><code>\tan</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Carctan" alt="\arctan"></td><td align="center"><code>\arctan</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctanh" alt="\tanh"></td><td align="center"><code>\tanh</code></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccot" alt="\cot"></td><td align="center"><code>\cot</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coperatorname%20%7Barccot%7D" alt="\operatorname {arccot}"></td><td align="center"><code>\arccot</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccoth" alt="\coth"></td><td align="center"><code>\coth</code></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="2-3-数学模式重音符"><a href="#2-3-数学模式重音符" class="headerlink" title="2.3 数学模式重音符"></a>2.3 数学模式重音符</h3><table><thead><tr><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th></tr></thead><tbody><tr><td align="center"><code>a''</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=a%27%27" alt="a''"></td><td align="center"><code>\hat{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Chat%7Ba%7D" alt="\hat{a}"></td><td align="center"><code>a'</code>or <code>a^{\prime}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=a%27" alt="a'"></td></tr><tr><td align="center"><code>\grave{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D" alt="\grave{a}"></td><td align="center"><code>\acute{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D" alt="\acute{a}"></td><td align="center"><code>\dot{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D" alt="\dot{a}"></td></tr><tr><td align="center"><code>\not{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnot%7Ba%7D" alt="\not{a}"></td><td align="center"><code>\mathring{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D" alt="\mathring{a}"></td><td align="center"><code>\overrightarrow{AB}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coverrightarrow%7BAB%7D" alt="\overrightarrow{AB}"></td></tr><tr><td align="center"><code>a'''</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=a%27%27%27" alt="a'''"></td><td align="center"><code>\bar{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D" alt="\bar{a}"></td><td align="center"><code>\overleftarrow{AB}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coverleftarrow%7BAB%7D" alt="\overleftarrow{AB}"></td></tr><tr><td align="center"><code>\ddot{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D" alt="\ddot{a}"></td><td align="center"><code>a''''</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=a%27%27%27%27" alt="a''''"></td><td align="center"><code>\overline{aaa}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coverline%7Baaa%7D" alt="\overline{aaa}"></td></tr><tr><td align="center"><code>\check{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D" alt="\check{a}"></td><td align="center"><code>\breve{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D" alt="\breve{a}"></td><td align="center"><code>\stackrel\frown{AAA}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cstackrel%5Cfrown%7BAAA%7D" alt="\stackrel\frown{AAA}"></td></tr><tr><td align="center"><code>\dddot{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdddot%7Ba%7D" alt="\dddot{a}"></td><td align="center"><code>\ddddot{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cddddot%7Ba%7D" alt="\ddddot{a}"></td><td align="center"><code>\widehat{AAA}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwidehat%7BAAA%7D" alt="\widehat{AAA}"></td></tr><tr><td align="center"><code>\tilde{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D" alt="\tilde{a}"></td><td align="center"><code>\underline{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cunderline%7Ba%7D" alt="\underline{a}"></td><td align="center"><code>\widetilde{AAA}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwidetilde%7BAAA%7D" alt="\widetilde{AAA}"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"><code>\vec{a}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D" alt="\vec{a}"></td><td align="center"><code>\widehat{AAA}</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwidehat%7BAAA%7D" alt="\widehat{AAA}"></td></tr></tbody></table><h3 id="2-4-希腊字母"><a href="#2-4-希腊字母" class="headerlink" title="2.4 希腊字母"></a>2.4 希腊字母</h3><p>希腊字母通常用于数学，它们在<em>数学模式</em>输入很简单。你只需要在反斜杠后输入字母的名称：如果第一个字母是小写的，你会得到一个小写的希腊字母，如果第一个字母是大写，那么你将获得一个大写字母。</p><table><thead><tr><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th></tr></thead><tbody><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BA%7D" alt="\mathrm {A}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math.svg" alt="\alpha"></td><td align="center"><code>A</code> and <code>\alpha</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BN%7D" alt="\mathrm {N}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180822703.svg" alt="\nu"></td><td align="center"><code>N</code> and <code>\nu</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BB%7D" alt="\mathrm {B}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180822839.svg" alt="\beta"></td><td align="center"><code>B</code> and <code>\beta</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180822877.svg" alt="\Xi"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180822931.svg" alt="\xi"></td><td align="center"><code>\Xi</code> and <code>\xi</code></td></tr><tr><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180822975.svg" alt="\Gamma"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823032.svg" alt="\gamma"></td><td align="center"><code>Gamma</code> and <code>\gamma</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BO%7D" alt="\mathrm {O}"> and <img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7Bo%7D" alt="\mathrm {o}"></td><td align="center"><code>O and o</code></td></tr><tr><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823170.svg" alt="\Delta"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823222.svg" alt="\delta"></td><td align="center"><code>Delta</code> and <code>\delta</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823308.svg" alt="Pi">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823361.svg" alt="\pi"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823410.svg" alt="\varpi"></td><td align="center"><code>\Pi</code>,<code>\pi</code> and <code>\varpi</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BE%7D" alt="\mathrm {E}">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823598.svg" alt="\epsilon"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824081.svg" alt="\varepsilon"></td><td align="center"><code>E</code>,<code>\epsilon</code> and <code>\varepsilon</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BP%7D" alt="\mathrm {P}">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823751.svg" alt="\rho"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824204.svg" alt="\varrho"></td><td align="center"><code>P</code>,<code>\rho</code> and <code>\varrho</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BZ%7D" alt="\mathrm {Z}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180823942.svg" alt="\zeta"></td><td align="center"><code>Z</code> and <code>\zeta</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824602.svg" alt="\Sigma">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824272.svg" alt="\sigma"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824355.svg" alt="\varsigma"></td><td align="center"><code>Sigma</code>,<code>\sigma</code> and <code>\varsigma</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BH%7D" alt="\mathrm {H}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824918.svg" alt="\eta"></td><td align="center"><code>H</code> and <code>\eta</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BT%7D" alt="\mathrm {T}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825048.svg" alt="\tau"></td><td align="center"><code>T</code> and <code>\tau</code></td></tr><tr><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824768.svg" alt="\Theta">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180824816.svg" alt="\theta"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825401.svg" alt="\vartheta"></td><td align="center"><code>\Theta</code>,<code>\theta</code> and <code>\vartheta</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825002.svg" alt="\Upsilon"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825100.svg" alt="\upsilon"></td><td align="center"><code>\Upsilon</code> and <code>\upsilon</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BI%7D" alt="\mathrm {I}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825206.svg" alt="\iota"></td><td align="center"><code>I</code> and <code>\iota</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825251.svg" alt="\Phi">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825300.svg" alt="\phi">, and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825348.svg" alt="\varphi"></td><td align="center"><code>\Phi</code>,<code>\phi</code> and <code>\varphi</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BK%7D" alt="\mathrm {K}">, <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825936.svg" alt="\kappa"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825978.svg" alt="\varkappa"></td><td align="center"><code>K</code>,<code>\kappa</code> and <code>\varkappa</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BX%7D" alt="\mathrm {X}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825642.svg" alt="\chi"></td><td align="center"><code>X</code> and <code>\chi</code></td></tr><tr><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825666.svg" alt="\Lambda"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825829.svg" alt="\lambda"></td><td align="center"><code>Lambda</code> and <code>\lambda</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180825879.svg" alt="\Psi"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180826083.svg" alt="\psi"></td><td align="center"><code>\Psi</code> and <code>\psi</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmathrm%20%7BM%7D" alt="\mathrm {M}"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180826409.svg" alt="\mu"></td><td align="center"><code>M</code> and <code>\mu</code></td><td align="center"><img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180826405.svg" alt="\Omega"> and <img src="/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.assets/math-1588180826407.svg" alt="\omega"></td><td align="center"><code>\Omega</code> and <code>\omega</code></td></tr></tbody></table><h3 id="2-5-二元运算符"><a href="#2-5-二元运算符" class="headerlink" title="2.5 二元运算符"></a>2.5 二元运算符</h3><table><thead><tr><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center"><code>&lt;</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%3C" alt="<"></td><td align="center"><code>&gt;</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%3E" alt=">"></td><td align="center"><code>=</code></td><td align="center"><img src="https://math.jianshu.com/math?formula==" alt="="></td><td align="center"><code>\parallel</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cparallel" alt="\parallel"></td><td align="center">`\nparallel``</td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnparallel" alt="\nparallel"></td></tr><tr><td align="center"><code>\leq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td><td align="center"><code>\geq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td><td align="center"><code>\doteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdoteq" alt="\doteq"></td><td align="center"><code>\asymp</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Casymp" alt="\asymp"></td><td align="center"><code>\bowtie</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbowtie" alt="\bowtie"></td></tr><tr><td align="center"><code>\ll</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cll" alt="\ll"></td><td align="center"><code>\gg</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cgg" alt="\gg"></td><td align="center"><code>\equiv</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td><td align="center"><code>\vdash</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cvdash" alt="\vdash"></td><td align="center"><code>\dashv</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdashv" alt="\dashv"></td></tr><tr><td align="center"><code>\subset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td><td align="center"><code>\supset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csupset" alt="\supset"></td><td align="center"><code>\approx</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td><td align="center"><code>\in</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td><td align="center"><code>\ni</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cni" alt="\ni"></td></tr><tr><td align="center"><code>\subseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csubseteq" alt="\subseteq"></td><td align="center"><code>\supseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csupseteq" alt="\supseteq"></td><td align="center"><code>\cong</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccong" alt="\cong"></td><td align="center"><code>\smile</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csmile" alt="\smile"></td><td align="center"><code>\frown</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cfrown" alt="\frown"></td></tr><tr><td align="center"><code>\nsubseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnsubseteq" alt="\nsubseteq"></td><td align="center"><code>\nsupseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnsupseteq" alt="\nsupseteq"></td><td align="center"><code>\simeq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csimeq" alt="\simeq"></td><td align="center"><code>\models</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmodels" alt="\models"></td><td align="center"><code>\notin</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td></tr><tr><td align="center"><code>\sqsubset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqsubset" alt="\sqsubset"></td><td align="center"><code>\sqsupset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqsupset" alt="\sqsupset"></td><td align="center"><code>\sim</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csim" alt="\sim"></td><td align="center"><code>\perp</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cperp" alt="\perp"></td><td align="center"><code>\mid</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmid" alt="\mid"></td></tr><tr><td align="center"><code>\sqsubseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqsubseteq" alt="\sqsubseteq"></td><td align="center"><code>\sqsupseteq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqsupseteq" alt="\sqsupseteq"></td><td align="center"><code>\propto</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cpropto" alt="\propto"></td><td align="center"><code>\prec</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cprec" alt="\prec"></td><td align="center"><code>\succ</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csucc" alt="\succ"></td></tr><tr><td align="center"><code>\preceq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cpreceq" alt="\preceq"></td><td align="center"><code>\succeq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csucceq" alt="\succeq"></td><td align="center"><code>\neq</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td><td align="center"><code>\sphericalangle</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csphericalangle" alt="\sphericalangle"></td><td align="center"><code>\measuredangle</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmeasuredangle" alt="\measuredangle"></td></tr></tbody></table><h3 id="2-6-二元关系运算符"><a href="#2-6-二元关系运算符" class="headerlink" title="2.6 二元关系运算符"></a>2.6 二元关系运算符</h3><table><thead><tr><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center"><code>\pm</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td><td align="center"><code>\cap</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccap" alt="\cap"></td><td align="center"><code>\diamond</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdiamond" alt="\diamond"></td><td align="center"><code>\oplus</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coplus" alt="\oplus"></td></tr><tr><td align="center"><code>\mp</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmp" alt="\mp"></td><td align="center"><code>\cup</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccup" alt="\cup"></td><td align="center"><code>\bigtriangleup</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbigtriangleup" alt="\bigtriangleup"></td><td align="center"><code>\ominus</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cominus" alt="\ominus"></td></tr><tr><td align="center"><code>\times</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td><td align="center"><code>\uplus</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cuplus" alt="\uplus"></td><td align="center"><code>\bigtriangledown</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbigtriangledown" alt="\bigtriangledown"></td><td align="center"><code>\otimes</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cotimes" alt="\otimes"></td></tr><tr><td align="center"><code>\div</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td><td align="center"><code>\sqcap</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqcap" alt="\sqcap"></td><td align="center"><code>\triangleleft</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctriangleleft" alt="\triangleleft"></td><td align="center"><code>\oslash</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Coslash" alt="\oslash"></td></tr><tr><td align="center"><code>\ast</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cast" alt="\ast"></td><td align="center"><code>\sqcup</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csqcup" alt="\sqcup"></td><td align="center"><code>\triangleright</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctriangleright" alt="\triangleright"></td><td align="center"><code>\odot</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Codot" alt="\odot"></td></tr><tr><td align="center"><code>\star</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cstar" alt="\star"></td><td align="center"><code>\vee</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cvee" alt="\vee"></td><td align="center"><code>\bigcirc</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbigcirc" alt="\bigcirc"></td><td align="center"><code>\circ</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccirc" alt="\circ"></td></tr><tr><td align="center"><code>\dagger</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdagger" alt="\dagger"></td><td align="center"><code>\wedge</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwedge" alt="\wedge"></td><td align="center"><code>\bullet</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbullet" alt="\bullet"></td><td align="center"><code>\setminus</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csetminus" alt="\setminus"></td></tr><tr><td align="center"><code>\ddagger</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cddagger" alt="\ddagger"></td><td align="center"><code>\cdot</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td><td align="center"><code>\wr</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwr" alt="\wr"></td><td align="center"><code>\amalg</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Camalg" alt="\amalg"></td></tr></tbody></table><h3 id="2-7-集合与逻辑运算符"><a href="#2-7-集合与逻辑运算符" class="headerlink" title="2.7 集合与逻辑运算符"></a>2.7 集合与逻辑运算符</h3><table><thead><tr><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th></tr></thead><tbody><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cexists" alt="\exists"></td><td align="center"><code>\exists</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Crightarrow" alt="\rightarrow"></td><td align="center"><code>\rightarrow</code> or <code>\to</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnexists" alt="\nexists"></td><td align="center"><code>\nexists</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cleftarrow" alt="\leftarrow"></td><td align="center"><code>\leftarrow</code> or <code>\gets</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cforall" alt="\forall"></td><td align="center"><code>\forall</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cmapsto" alt="\mapsto"></td><td align="center"><code>\mapsto</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cneg" alt="\neg"></td><td align="center"><code>\neg</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cimplies" alt="\implies"></td><td align="center"><code>\implies</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td><td align="center"><code>\subset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5CRightarrow" alt="\Rightarrow"></td><td align="center"><code>\Rightarrow</code> or <code>\implies</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Csupset" alt="\supset"></td><td align="center"><code>\supset</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cleftrightarrow" alt="\leftrightarrow"></td><td align="center"><code>\leftrightarrow</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ciff" alt="\iff"></td><td align="center"><code>\iff</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td><td align="center"><code>\in</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td><td align="center"><code>\notin</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5CLeftrightarrow" alt="\Leftrightarrow"></td><td align="center"><code>\Leftrightarrow</code> (等价符的首选（(iff))</td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cni" alt="\ni"></td><td align="center"><code>\ni</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ctop" alt="\top"></td><td align="center"><code>\top</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cland" alt="\land"></td><td align="center"><code>\land</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbot" alt="\bot"></td><td align="center"><code>\bot</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Clor" alt="\lor"></td><td align="center"><code>\lor</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"> 与 <img src="https://math.jianshu.com/math?formula=%5Cvarnothing" alt="\varnothing"></td><td align="center"><code>\emptyset</code> 与 <code>\varnothing</code></td></tr></tbody></table><h3 id="2-8-分隔符"><a href="#2-8-分隔符" class="headerlink" title="2.8 分隔符"></a>2.8 分隔符</h3><table><thead><tr><th>符号</th><th>脚本</th><th>符号</th><th>脚本</th><th>符号</th><th>脚本</th><th>符号</th><th>脚本</th></tr></thead><tbody><tr><td><img src="https://math.jianshu.com/math?formula=%5C%7B" alt="\{"></td><td><code>\{</code></td><td><img src="https://math.jianshu.com/math?formula=%5C%7D" alt="\}"></td><td><code>\}</code></td><td><img src="https://math.jianshu.com/math?formula=%5Clangle" alt="\langle"></td><td><code>\langle</code></td><td><img src="https://math.jianshu.com/math?formula=%5Crangle" alt="\rangle"></td><td><code>\rangle</code></td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Cuparrow" alt="\uparrow"></td><td><code>\uparrow</code></td><td><img src="https://math.jianshu.com/math?formula=%5CUparrow" alt="\Uparrow"></td><td><code>\Uparrow</code></td><td><img src="https://math.jianshu.com/math?formula=%5Clceil" alt="\lceil"></td><td><code>\lceil</code></td><td><img src="https://math.jianshu.com/math?formula=%5Crceil" alt="\rceil"></td><td><code>\rceil</code></td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Cdownarrow" alt="\downarrow"></td><td><code>\downarrow</code></td><td><img src="https://math.jianshu.com/math?formula=%5CDownarrow" alt="\Downarrow"></td><td><code>\Downarrow</code></td><td><img src="https://math.jianshu.com/math?formula=%5Clfloor" alt="\lfloor"></td><td><code>\lfloor</code></td><td><img src="https://math.jianshu.com/math?formula=%5Crfloor" alt="\rfloor"></td><td><code>\rfloor</code></td></tr></tbody></table><h3 id="2-9-其它符号"><a href="#2-9-其它符号" class="headerlink" title="2.9 其它符号"></a>2.9 其它符号</h3><table><thead><tr><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th><th align="center">符号</th><th align="center">脚本</th></tr></thead><tbody><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cpartial" alt="\partial"></td><td align="center"><code>\partial</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cimath" alt="\imath"></td><td align="center"><code>\imath</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5CRe" alt="\Re"></td><td align="center"><code>\Re</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cnabla" alt="\nabla"></td><td align="center"><code>\nabla</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Caleph" alt="\aleph"></td><td align="center"><code>\aleph</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Ceth" alt="\eth"></td><td align="center"><code>\eth</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cjmath" alt="\jmath"></td><td align="center"><code>\jmath</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5CIm" alt="\Im"></td><td align="center"><code>\Im</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5CBox" alt="\Box"></td><td align="center"><code>\Box</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cbeth" alt="\beth"></td><td align="center"><code>\beth</code></td></tr><tr><td align="center"><img src="https://math.jianshu.com/math?formula=%5Chbar" alt="\hbar"></td><td align="center"><code>\hbar</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cell" alt="\ell"></td><td align="center"><code>\ell</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cwp" alt="\wp"></td><td align="center"><code>\wp</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></td><td align="center"><code>\infty</code></td><td align="center"><img src="https://math.jianshu.com/math?formula=%5Cgimel" alt="\gimel"></td><td align="center"><code>\gimel</code></td></tr></tbody></table><h2 id="3-常用表达"><a href="#3-常用表达" class="headerlink" title="3. 常用表达"></a>3. 常用表达</h2><h3 id="3-1-分数和二项式"><a href="#3-1-分数和二项式" class="headerlink" title="3.1 分数和二项式"></a>3.1 分数和二项式</h3><p> <code>\frac{n!}{k!(n-k)!} = \binom{n}{k}</code> | <img src="https://math.jianshu.com/math?formula=%5Cfrac%7Bn!%7D%7Bk!(n-k)!%7D%20=%20%5Cbinom%7Bn%7D%7Bk%7D" alt="\frac{n!}{k!(n-k)!} = \binom{n}{k}"></p><p>您可以在分数中嵌入分数:<br> <code>\frac{\frac{1}{x} + \frac{1}{y}}{yz}</code> | <img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cfrac%7B1%7D%7Bx%7D%20+%20%5Cfrac%7B1%7D%7By%7D%7D%7By%20-%20z%7D" alt="\frac{\frac{1}{x} + \frac{1}{y}}{y - z}"></p><p>请注意，当出现在另一个分数内部或内联文本中<img src="https://math.jianshu.com/math?formula=%5Cfrac%7Ba%7D%7Bb%7D" alt="\frac{a}{b}">时 ，分数明显小于显示的数学公式。的<code>\tfrac</code>和<code>\dfrac</code>命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>强制使用的各自的风格，<code>\textstyle</code>和<code>\displaystyle</code>。类似地，<code>\tbinom</code>和<code>\dbinom</code>命令排版二项式系数。</p><p>对于相对简单的分数，特别是在文本中，使用<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#Powers_and_indices">指数和脚标</a>可能在美学上更令人愉悦：<br> <code>^ 3 / _ 7</code> | <img src="https://math.jianshu.com/math?formula=%5E%203%20/%20_%207" alt="^ 3 / _ 7"></p><h3 id="3-2-连续分数"><a href="#3-2-连续分数" class="headerlink" title="3.2 连续分数"></a>3.2 连续分数</h3><p>应使用<code>\cfrac</code>命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>编写连续分数：</p><pre class="line-numbers language-ruby"><code class="language-ruby">\<span class="token keyword">begin</span> <span class="token punctuation">{</span>equation<span class="token punctuation">}</span>   x <span class="token operator">=</span> a _ <span class="token number">0</span> <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>a _ <span class="token number">1</span>          <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>a _ <span class="token number">2</span>          <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>a _ <span class="token number">3</span> <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>a _ <span class="token number">4</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> \<span class="token keyword">end</span> <span class="token punctuation">{</span>equation<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%20%7Bequation%7D%20x%20=%20a%20_%200%20+%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%201%20+%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%202%20+%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%203%20+%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%204%7D%20%7D%20%7D%20%7D%20%5Cend%20%7Bequation%7D" alt="\begin {equation} x = a _ 0 + \cfrac {1} {a _ 1 + \cfrac {1} {a _ 2 + \cfrac {1} {a _ 3 + \cfrac {1} {a _ 4} } } } \end {equation}"></p><h3 id="3-3-两个数字的乘法"><a href="#3-3-两个数字的乘法" class="headerlink" title="3.3 两个数字的乘法"></a>3.3 两个数字的乘法</h3><p>为了使乘法在视觉上类似于分数，可以使用嵌套数组，例如，一个在另一个之下写入的数字的乘法。</p><pre class="line-numbers language-swift"><code class="language-swift">\begin<span class="token punctuation">{</span>equation<span class="token punctuation">}</span>\frac<span class="token punctuation">{</span>    \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">{</span>r<span class="token punctuation">}</span>      \<span class="token keyword">left</span><span class="token punctuation">(</span> x_1 x_2 \<span class="token keyword">right</span><span class="token punctuation">)</span>\\      \times \<span class="token keyword">left</span><span class="token punctuation">(</span> x<span class="token string">'_1 x'</span><span class="token number">_2</span> \<span class="token keyword">right</span><span class="token punctuation">)</span>    \end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">{</span>    \<span class="token keyword">left</span><span class="token punctuation">(</span> y_1y_2y_3y_4 \<span class="token keyword">right</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>\end<span class="token punctuation">{</span>equation<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20%5Cfrac%7B%20%5Cbegin%7Barray%7D%5Bb%5D%7Br%7D%20%5Cleft(%20x_1%20x_2%20%5Cright)%5C%5C%20%5Ctimes%20%5Cleft(%20x%27_1%20x%27_2%20%5Cright)%20%5Cend%7Barray%7D%20%7D%7B%20%5Cleft(%20y_1y_2y_3y_4%20%5Cright)%20%7D%20%5Cend%7Bequation%7D" alt="\begin{equation} \frac{ \begin{array}[b]{r} \left( x_1 x_2 \right)\\ \times \left( x'_1 x'_2 \right) \end{array} }{ \left( y_1y_2y_3y_4 \right) } \end{equation}"></p><h3 id="3-4-根"><a href="#3-4-根" class="headerlink" title="3.4 根"></a>3.4 根</h3><p>该<code>\sqrt</code>命令创建一个围绕表达式的平方根。它接受方括号（[和]）中指定的可选参数来改变幅度：<br> <code>\sqrt{\frac{a}{b}}</code> | <img src="https://math.jianshu.com/math?formula=%5Csqrt%7B%5Cfrac%7Ba%7D%7Bb%7D%7D" alt="\sqrt{\frac{a}{b}}"><br> <code>\sqrt[n]{1+x+x^2+x^3+\dots+x^n}</code> | <img src="https://math.jianshu.com/math?formula=%5Csqrt%5Bn%5D%7B1+x+x%5E2+x%5E3+%5Cdots+x%5En%7D" alt="\sqrt[n]{1+x+x^2+x^3+\dots+x^n}"></p><h3 id="3-5-求和和积分"><a href="#3-5-求和和积分" class="headerlink" title="3.5 求和和积分"></a>3.5 求和和积分</h3><p><code>\sum</code>和<code>\int</code>命令分别插入之和积分符号，在使用插入符号（指定限度<code>^</code>）和下划线（<code>_</code>）。<code>sums</code>的典型表示法是：</p><p><code>\sum_{i=1}^{10} t_i</code> | </p><p>积分的限制遵循相同的符号。使用直立d表示积分变量也很重要，在数学模式下，通过<code>\mathrm{}</code>命令获得积分变量，并使用小空格将其与被积函数分开，这可以通过<code>\, command</code>获得。<br> <code>\int_0^\infty \mathrm{e}^{-x}\,\mathrm{d}x</code> | <img src="https://math.jianshu.com/math?formula=%5Cint_0%5E%5Cinfty%20%5Cmathrm%7Be%7D%5E%7B-x%7D%5C,%5Cmathrm%7Bd%7Dx" alt="\int_0^\infty \mathrm{e}^{-x}\,\mathrm{d}x"></p><p>还有许多其他“大”命令以类似的方式运行：</p><table><thead><tr><th><code>\sum</code></th><th><img src="https://math.jianshu.com/math?formula=%5Csum" alt="\sum"></th><th><code>\prod</code></th><th><img src="https://math.jianshu.com/math?formula=%5Cprod" alt="\prod"></th><th><code>\coprod</code></th><th><img src="https://math.jianshu.com/math?formula=%5Ccoprod" alt="\coprod"></th></tr></thead><tbody><tr><td><code>\bigoplus</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigoplus" alt="\bigoplus"></td><td><code>\bigotimes</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigotimes" alt="\bigotimes"></td><td><code>\bigodot</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigodot" alt="\bigodot"></td></tr><tr><td><code>\bigcup</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td><td><code>\bigcap</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td><td><code>\biguplus</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbiguplus" alt="\biguplus"></td></tr><tr><td><code>\bigsqcup</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigsqcup" alt="\bigsqcup"></td><td><code>\bigvee</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigvee" alt="\bigvee"></td><td><code>\bigwedge</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cbigwedge" alt="\bigwedge"></td></tr><tr><td><code>\int</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cint" alt="\int"></td><td><code>\oint</code></td><td><img src="https://math.jianshu.com/math?formula=%5Coint" alt="\oint"></td><td><code>\iint</code></td><td><img src="https://math.jianshu.com/math?formula=%5Ciint" alt="\iint"></td></tr><tr><td><code>\iiint</code></td><td>$$\iiint</td><td><code>\iiiint</code></td><td><code>\idotsint</code></td><td><img src="https://math.jianshu.com/math?formula=%5Ciiiint" alt="\iiiint"></td><td><img src="https://math.jianshu.com/math?formula=%5Cidotsint" alt="\idotsint"></td></tr></tbody></table><p>有关更多整数符号（包括 Computer Modern 字体中默认未包含的符号），请尝试使用<code>esint</code>包。<code>\substack</code>命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>允许使用的<code>\\</code>写多行的限制：</p><pre class="line-numbers language-undefined"><code class="language-undefined">\sum_{\substack{   0<i<m \\   0<j<n  }}  P(i,j)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Csum_%7B%5Csubstack%7B%200%3Ci%3Cm%20%5C%5C%200%3Cj%3Cn%20%7D%7D%20P(i,j)" alt="\sum_{\substack{ 0<i<m \\ 0<j<n }} P(i,j)"></p><p>如果要在符号的上方和下方指定积分限制（类似求和），请使用以下<code>\limits</code>命令：<br> <code>\int\limits_a^b</code> | <img src="https://math.jianshu.com/math?formula=%5Cint%5Climits_a%5Eb" alt="\int\limits_a^b"></p><h3 id="3-6-括号，括号和分隔符"><a href="#3-6-括号，括号和分隔符" class="headerlink" title="3.6 括号，括号和分隔符"></a>3.6 括号，括号和分隔符</h3><p><em><a href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#Braces_spanning_multiple_lines">高等数学</a>章节中描述了如何在多线方程中使用大括号。</em></p><p>在处理除了琐碎的方程式之外的任何事情时，使用诸如括号之类的分隔符很快就变得很重要。如果没有它们，公式就会变得含糊不清。此外，特殊类型的数学结构（如矩阵）通常依赖于分隔符来包围它们。</p><p>LaTeX中有多种分隔符可供使用：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> b <span class="token punctuation">]</span><span class="token punctuation">,</span> \<span class="token punctuation">{</span> c \<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">|</span> d <span class="token operator">|</span><span class="token punctuation">,</span> \<span class="token operator">|</span> e \<span class="token operator">|</span><span class="token punctuation">,</span>\langle f \rangle<span class="token punctuation">,</span> \lfloor g \rfloor<span class="token punctuation">,</span>\lceil h \rceil<span class="token punctuation">,</span> \ulcorner i \urcorner<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>$( a ), [ b ], { c }, | d |, | e |, \langle f \rangle, \lfloor g \rfloor, \lceil h \rceil, \ulcorner i \urcorner$</p><p>其中\lbrack和\rbrack可用于代替[与]。<br>自动调整大小</p><p>通常，数学特征的大小不同，在这种情况下，表达式周围的分隔符应相应地变化。这可以通过自动的完成\left，\right和\middle命令。任何以前的分隔符都可以与这些分隔符结合使用:<br>\left(\frac{x^2}{y^3}\right) | \left(\frac{x^2}{y^3}\right)<br>P\left(A=2\middle|\frac{A^2}{B}&gt;4\right) | P\left(A=2\middle|\frac{A^2}{B}&gt;4\right)</p><p>如果只需要表达式一侧的分隔符，则可以使用句点（.）表示另一侧的不可见分隔符。<br>\left.\frac{x^3}{3}\right|_0^1 | \left.\frac{x^3}{3}\right|_0^1</p><pre><code>具体含义不懂，以后用到再学习吧！</code></pre><p>手动调整大小</p><p>在某些情况下，由\left和\right命令生成的大小可能不合适，或者您可能只是希望更精细地控制分隔符大小。在这种情况下，\big，\Big，\bigg和\Bigg可以使用调节器命令：<br>( \big( \Big( \bigg( \Bigg( | ( \big( \Big( \bigg( \Bigg(</p><p>在处理嵌套分隔符时，这些命令主要有用。例如，排版时:</p><p><code>\frac{\mathrm d}{\mathrm d x} \big( k g(x) \big)</code> | <img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cmathrm%20d%7D%7B%5Cmathrm%20d%20x%7D%20%5Cbig(%20k%20g(x)%20%5Cbig)" alt="\frac{\mathrm d}{\mathrm d x} \big( k g(x) \big)"></p><p>当方程太大，离开页面末尾时，手动调整大小也很有用，并且必须使用align命令将其分成两行。虽然命令<code>\left.</code>和<code>\right.</code>可以用来平衡每行分隔符，这可能会导致错误的分隔符的大小。此外，如果<code>\underbrace</code>在分隔符之间出现或类似的命令，则可以使用手动大小调整来避免过大的分隔符。</p><h3 id="3-7-矩阵和数组"><a href="#3-7-矩阵和数组" class="headerlink" title="3.7 矩阵和数组"></a>3.7 矩阵和数组</h3><p>可以使用矩阵环境[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>创建基本矩阵：与其他类似于表的结构一样，条目由行指定，列使用＆符号（<code>&amp;</code>）分隔，新行以双反斜杠（<code>\\</code>） 分隔:</p><pre class="line-numbers language-ruby"><code class="language-ruby">\<span class="token punctuation">[</span> \<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>  a <span class="token operator">&amp;</span> b <span class="token operator">&amp;</span> c \\  d <span class="token operator">&amp;</span> e <span class="token operator">&amp;</span> f \\  g <span class="token operator">&amp;</span> h <span class="token operator">&amp;</span> i \<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>\<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9144768-10601a74ede0c993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/670" alt="img"></p><p>要指定表格中列的对齐方式，请使用加星标的版本[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-mathtools-5">5]</a>：</p><pre class="line-numbers language-ruby"><code class="language-ruby">\<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>  <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\  <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">4</span> \<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span> <span class="token operator">=</span> \<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token operator">*</span><span class="token punctuation">}</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>  <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\  <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">4</span> \<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token operator">*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9144768-2914e55906aa3fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848" alt="img"></p><p>默认情况下，对齐是c，但它可以是在数组环境中有效的任何列类型。</p><p>但是，矩阵通常用某种分隔符括起来，虽然可以使用<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#Automatic_sizing"><code>\left</code>和<code>\right</code>命令</a>，但还有各种其他预定义环境自动包含分隔符：</p><p><img src="https://upload-images.jianshu.io/upload_images/9144768-bd0289b828e8f72a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/790" alt="img"></p><p>在写下任意大小的矩阵时，通常使用水平，垂直和对角线三点（称为<a href="https://en.wikipedia.org/wiki/ellipsis">椭圆</a>）来填充某些列和行。这些可以使用来指定<code>\cdots</code>，<code>\vdots</code>并<code>\ddots</code>分别为：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token constant">A_</span><span class="token punctuation">{</span>m<span class="token punctuation">,</span>n<span class="token punctuation">}</span> <span class="token operator">=</span>  \<span class="token keyword">begin</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>  a_<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \cdots <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span> \\  a_<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \cdots <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span> \\  \vdots  <span class="token operator">&amp;</span> \vdots  <span class="token operator">&amp;</span> \ddots <span class="token operator">&amp;</span> \vdots  \\  a_<span class="token punctuation">{</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span>m<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \cdots <span class="token operator">&amp;</span> a_<span class="token punctuation">{</span>m<span class="token punctuation">,</span>n<span class="token punctuation">}</span>  \<span class="token keyword">end</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=A_%7Bm,n%7D%20=%20%5Cbegin%7Bpmatrix%7D%20a_%7B1,1%7D%20&amp;%20a_%7B1,2%7D%20&amp;%20%5Ccdots%20&amp;%20a_%7B1,n%7D%20%5C%5C%20a_%7B2,1%7D%20&amp;%20a_%7B2,2%7D%20&amp;%20%5Ccdots%20&amp;%20a_%7B2,n%7D%20%5C%5C%20%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%20a_%7Bm,1%7D%20&amp;%20a_%7Bm,2%7D%20&amp;%20%5Ccdots%20&amp;%20a_%7Bm,n%7D%20%5Cend%7Bpmatrix%7D" alt="A_{m,n} = \begin{pmatrix} a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\ a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{m,1} &amp; a_{m,2} &amp; \cdots &amp; a_{m,n} \end{pmatrix}"></p><p>在某些情况下，您可能希望更精细地控制每列中的对齐，或者希望在列或行之间插入行。这可以通过使用可以实现阵列的环境，这在本质上是一个数学模式版本<a href="https://en.wikibooks.org/wiki/LaTeX/Tables#The_tabular_environment"><code>tabular</code>环境</a>，这需要对列进行预先指定：</p><pre class="line-numbers language-cpp"><code class="language-cpp">\begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token operator">|</span>c<span class="token punctuation">}</span>  <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">2</span> \\   \hline  <span class="token number">3</span> <span class="token operator">&amp;</span> <span class="token number">4</span> \end<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Cc%7D%201%20&amp;%202%20%5C%5C%20%5Chline%203%20&amp;%204%20%5Cend%7Barray%7D" alt="\begin{array}{c|c} 1 &amp; 2 \\ \hline 3 &amp; 4 \end{array}"></p><p>您可能会看到AMS矩阵类环境在与分数一起使用时没有留下足够的空间，从而产生类似于此的输出：<br> <img src="https://math.jianshu.com/math?formula=M%20=%20%5Cbegin%7Bbmatrix%7D%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20&amp;%200%20%5C%5C%5B0.3em%5D%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%200%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20%5C%5C%5B0.3em%5D%200%20&amp;%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20%5Cend%7Bbmatrix%7D" alt="M = \begin{bmatrix} \frac{5}{6} &amp; \frac{1}{6} &amp; 0 \[0.3em] \frac{5}{6} &amp; 0 &amp; \frac{1}{6} \[0.3em] 0 &amp; \frac{5}{6} &amp; \frac{1}{6} \end{bmatrix}"></p><p>要解决此问题，请使用可选参数向\命令添加其他前导空格：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token constant">M</span> <span class="token operator">=</span> \<span class="token keyword">begin</span><span class="token punctuation">{</span>bmatrix<span class="token punctuation">}</span>       \frac<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \frac<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token number">0</span>           \\<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span>3em<span class="token punctuation">]</span>       \frac<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token number">0</span>           <span class="token operator">&amp;</span> \frac<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> \\<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span>3em<span class="token punctuation">]</span>       <span class="token number">0</span>           <span class="token operator">&amp;</span> \frac<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \frac<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span>     \<span class="token keyword">end</span><span class="token punctuation">{</span>bmatrix<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=M%20=%20%5Cbegin%7Bbmatrix%7D%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20&amp;%200%20%5C%5C%5B0.3em%5D%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%200%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20%5C%5C%5B0.3em%5D%200%20&amp;%20%5Cfrac%7B5%7D%7B6%7D%20&amp;%20%5Cfrac%7B1%7D%7B6%7D%20%5Cend%7Bbmatrix%7D" alt="M = \begin{bmatrix} \frac{5}{6} &amp; \frac{1}{6} &amp; 0 \[0.3em] \frac{5}{6} &amp; 0 &amp; \frac{1}{6} \[0.3em] 0 &amp; \frac{5}{6} &amp; \frac{1}{6} \end{bmatrix}"></p><p>如果矩阵上需要<code>border</code>或<code>indices</code>，则普通TeX提供宏 <code>\bordermatrix</code>:</p><pre class="line-numbers language-undefined"><code class="language-undefined">M = \bordermatrix{~ & x & y \cr                  A & 1 & 0 \cr                  B & 0 & 1 \cr}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9144768-1ad636e14c6aacd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/933" alt="img"></p><h3 id="3-8-运行文本的矩阵"><a href="#3-8-运行文本的矩阵" class="headerlink" title="3.8 运行文本的矩阵"></a>3.8 运行文本的矩阵</h3><p>要插入一个小矩阵，而不是增加包含它的行中的前导，请使用<code>smallmatrix</code>环境：</p><pre class="line-numbers language-a"><code class="language-a">$\bigl(\begin{smallmatrix}a&b \\ c&d\end{smallmatrix} \bigr)$to not increase leading in a portion of text.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>A matrix in text must be set smaller:<br> <img src="https://math.jianshu.com/math?formula=%5Cbigl(%5Cbegin%7Bsmallmatrix%7D%20a&amp;b%20%5C%5C%20c&amp;d%20%5Cend%7Bsmallmatrix%7D%20%5Cbigr)" alt="\bigl(\begin{smallmatrix} a&amp;b \\ c&amp;d \end{smallmatrix} \bigr)"><br> to not increase leading in a portion of text.</p><h3 id="3-9-向方程式添加文本"><a href="#3-9-向方程式添加文本" class="headerlink" title="3.9 向方程式添加文本"></a>3.9 向方程式添加文本</h3><p>数学环境与文本表示中的文本环境不同。以下是尝试在数学环境中表示文本的示例：<br> <code>50 apples \times 100 apples = lots of apples^2</code> | <img src="https://math.jianshu.com/math?formula=50%20apples%20%5Ctimes%20100%20apples%20=%20lots%20of%20apples%5E2" alt="50 apples \times 100 apples = lots of apples^2"></p><p>有两个值得注意的问题：单词或数字之间没有空格，字母用斜体表示，比正常情况更多。这两个问题都是数学公式模式引起的，因为它们被视为一个数学表达式：空格被忽略（LaTeX根据自己的数学公式规则），每个字符都是一个单独的元素（所以不像正常文本那样紧密排列）。</p><p>有许多方法可以正确添加文本。典型的方法是使用命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>包装文本（类似的命令是，虽然这会导致下标问题，并且具有较少描述性的名称）。让我们看看上面的等式代码被调整后会发生什么： <code>\text{...}``\mbox{...}</code><br> <code>50 \text{apples} \times 100 \text{apples} = \text{lots of apples}^2</code> | <img src="https://math.jianshu.com/math?formula=50%20%5Ctext%7Bapples%7D%20%5Ctimes%20100%20%5Ctext%7Bapples%7D%20=%20%5Ctext%7Blots%20of%20apples%7D%5E2" alt="50 \text{apples} \times 100 \text{apples} = \text{lots of apples}^2"></p><p>文字看起来更好。但是，数字和单词之间没有空隙。不幸的是，您需要明确添加这些。有许多方法可以在数学元素之间添加空格，但为了简单起见，我们可以简单地在\text命令中插入空格字符。<br> <code>50 \text{ apples} \times 100 \text{ apples} = \text{lots of apples}^2</code> | <img src="https://math.jianshu.com/math?formula=50%20%5Ctext%7B%20apples%7D%20%5Ctimes%20100%20%5Ctext%7B%20apples%7D%20=%20%5Ctext%7Blots%20of%20apples%7D%5E2" alt="50 \text{ apples} \times 100 \text{ apples} = \text{lots of apples}^2"></p><h3 id="3-10-格式化文本"><a href="#3-10-格式化文本" class="headerlink" title="3.10 格式化文本"></a>3.10 格式化文本</h3><p>使用<code>\text</code>可以获得基本的结果。然而，有一种替代方案可以提供更多的灵活性。你可能还记得引进的<a href="https://en.wikibooks.org/wiki/LaTeX/Fonts#Font_styles">font formatting commands</a>,<br> ，如<code>\textrm</code>，<code>\textit</code>，<code>\textbf</code>，等这些命令相应格式化参数，例如，<code>\textbf{bold text}</code>给出了<strong>粗体字</strong>。这些命令在数学环境中同样有效的包含文本。这里的额外好处是，您可以更好地控制字体格式，而不仅仅是用<code>\text</code>使用标准文本。<br> <code>50 \textrm{ apples} \times 100 \textbf{ apples} = \textit{lots of apples}^2</code> | <img src="https://math.jianshu.com/math?formula=50%20%5Ctextrm%7B%20apples%7D%20%5Ctimes%20100%20%5Ctextbf%7B%20apples%7D%20=%20%5Ctextit%7Blots%20of%20apples%7D%5E2" alt="50 \textrm{ apples} \times 100 \textbf{ apples} = \textit{lots of apples}^2"></p><h3 id="3-11-格式化数学符号"><a href="#3-11-格式化数学符号" class="headerlink" title="3.11 格式化数学符号"></a>3.11 格式化数学符号</h3><p>我们现在可以格式化文字; 如何格式化数学表达式？有一组格式化命令非常类似于刚刚使用的字体格式化，除了它们专门针对数学模式中的文本（需要amsfonts）</p><p><img src="https://upload-images.jianshu.io/upload_images/9144768-e3d4386dba005ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>简叔基本不起作用</p><p>这些格式化命令可以围绕整个等式，而不仅仅是文本元素：它们只格式化字母，数字和大写希腊语，其他数学命令不受影响。</p><p>要使用粗体小写的希腊字母或其他符号，请使用<code>\boldsymbol</code>命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a> ; 这仅在当前字体中存在符号的粗体版本时才有效。作为最后的手段，有<code>\pmb</code>命令[<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics#cite_note-amsmath-3">3]</a>（poor man’s bold）：这会打印出略微不同的多个版本。<br> <code>\boldsymbol{\beta} = (\beta_1,\beta_2,\dotsc,\beta_n)</code> | <img src="https://math.jianshu.com/math?formula=%5Cboldsymbol%7B%5Cbeta%7D%20=%20(%5Cbeta_1,%5Cbeta_2,%5Cdotsc,%5Cbeta_n)" alt="\boldsymbol{\beta} = (\beta_1,\beta_2,\dotsc,\beta_n)"></p><p>要在数学模式下<a href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#Changing_font_size">更改字体的大小</a>，请参阅<a href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#Changing_font_size">更改字体大小</a>。</p><h3 id="3-12-控制水平间距"><a href="#3-12-控制水平间距" class="headerlink" title="3.12 控制水平间距"></a>3.12 控制水平间距</h3><p>LaTeX显然非常擅长排版数学 - 这是LaTeX扩展的核心TeX系统的主要目标之一。但是，它并不总是依赖于以您的方式准确地解释公式。当存在含糊不清的表达时，它必须做出某些假设。结果往往是略微不正确的水平间距。这样的输出仍然令人满意，但任何完美主义者无疑都希望微调他们的公式以确保间距正确。这些通常是非常微妙的调整。</p><p>某些情况下，LaTeX正确地完成了它的工作，但你只是想添加一些空间，也许是为了添加某种评论。例如，在下面的等式中，最好确保在数学和文本之间存在适当的空间量。</p><pre class="line-numbers language-csharp"><code class="language-csharp">\<span class="token punctuation">[</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span>  \begin<span class="token punctuation">{</span>cases<span class="token punctuation">}</span>    n<span class="token operator">/</span><span class="token number">2</span>       <span class="token operator">&amp;</span> \quad \text<span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">}</span> n \text<span class="token punctuation">{</span> <span class="token keyword">is</span> even<span class="token punctuation">}</span>\\    <span class="token operator">-</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>  <span class="token operator">&amp;</span> \quad \text<span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">}</span> n \text<span class="token punctuation">{</span> <span class="token keyword">is</span> odd<span class="token punctuation">}</span>  \end<span class="token punctuation">{</span>cases<span class="token punctuation">}</span>\<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9144768-488db96d16663c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>image.png</p><p>此代码在Miktex 2.9中产生错误，并且不会产生右侧所示的结果。使用<code>\mathrm</code>而不仅仅是<code>\text</code>。</p><p>（请注意，此特定示例可以通过<a href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#The_cases_environment">高级数学</a>章节中描述的amsmath包提供的案例构造以更优雅的代码表示。）</p><p>LaTeX定义了两个命令，可以在文档（不仅仅是数学）中的任何位置使用，以插入一些水平空间。他们是<code>\quad</code>和<code>\qquad</code></p><p>A <code>\quad</code>是等于当前字体大小的空格。所以，如果你使用的是11pt字体，那么提供的空间<code>\quad</code>也将是11pt（当然是水平的。）这个<code>\qquad</code>数量的两倍。从上面示例的代码中可以看出，<code>\quad</code>s用于在数学和文本之间添加一些分隔。</p><p>好的，所以回到文档开头提到的微调。一个很好的例子是显示<em>y</em>相对于<em>x</em>的不定积分的简单方程：<br> <img src="https://math.jianshu.com/math?formula=%5Cint%20y%20%5C,%20%5Cmathrm%20%7Bd%7Dx" alt="\int y \, \mathrm {d}x"></p><p><code>\int y \mathrm{d}x</code> | <img src="https://math.jianshu.com/math?formula=%5Cint%20y%20%5Cmathrm%7Bd%7Dx" alt="\int y \mathrm{d}x"></p><p>但是，这并没有给出正确的结果。LaTeX不尊重代码中留下的空白区域，表示y和d x是独立的实体。相反，它完全混淆了它们。\quad在这种情况下，A 显然是过度的 - 需要在这种类型的实例中使用一些小空间，这就是LaTeX提供的：</p><table><thead><tr><th>命令</th><th>描述</th><th>尺寸</th></tr></thead><tbody><tr><td><code>\,</code></td><td>小空格</td><td>3/18的quad</td></tr><tr><td><code>\:</code></td><td>中等空格</td><td>4/18的quad</td></tr><tr><td><code>\;</code></td><td>大空格</td><td>4/18的quad</td></tr><tr><td><code>\!</code></td><td>负空格</td><td>-3/18的quad</td></tr></tbody></table><p>注意，如果需要，您可以在序列中使用多个命令以获得更大的空间。</p><p>那么，要纠正当前的问题：</p><p><code>\int y\, \mathrm{d}x</code> | <img src="https://math.jianshu.com/math?formula=%5Cint%20y%5C,%20%5Cmathrm%7Bd%7Dx" alt="\int y\, \mathrm{d}x"><br> <code>\int y\: \mathrm{d}x</code> | <img src="https://math.jianshu.com/math?formula=%5Cint%20y%5C:%20%5Cmathrm%7Bd%7Dx" alt="\int y\: \mathrm{d}x"><br> <code>\int y\; \mathrm{d}x</code> | <img src="https://math.jianshu.com/math?formula=%5Cint%20y%5C;%20%5Cmathrm%7Bd%7Dx" alt="\int y\; \mathrm{d}x"></p><p>负空间可能看起来像是一件奇怪的事情，但是，如果没有一些用处它就不会存在！采用以下示例：</p><pre class="line-numbers language-swift"><code class="language-swift">\<span class="token keyword">left</span><span class="token punctuation">(</span>    \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span>      n \\      r    \end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  \<span class="token keyword">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> \frac<span class="token punctuation">{</span>n<span class="token operator">!</span><span class="token punctuation">}</span><span class="token punctuation">{</span>r<span class="token operator">!</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%20n%20%5C%5C%20r%20%5Cend%7Barray%7D%20%5Cright)%20=%20%5Cfrac%7Bn!%7D%7Br!(n-r)!%7D" alt="\left( \begin{array}{c} n \\ r \end{array} \right) = \frac{n!}{r!(n-r)!}"></p><p>用于表示二项式系数的类似矩阵的表达式被填充。括号与实际内容之间的空间太大。这可以通过在左括号后和右括号之前添加一些负空格来轻松纠正。</p><pre class="line-numbers language-swift"><code class="language-swift">\<span class="token keyword">left</span><span class="token punctuation">(</span>\<span class="token operator">!</span>    \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span>      n \\      r    \end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  \<span class="token operator">!</span>\<span class="token keyword">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> \frac<span class="token punctuation">{</span>n<span class="token operator">!</span><span class="token punctuation">}</span><span class="token punctuation">{</span>r<span class="token operator">!</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://math.jianshu.com/math?formula=%5Cleft(%5C!%20%5Cbegin%7Barray%7D%7Bc%7D%20n%20%5C%5C%20r%20%5Cend%7Barray%7D%20%5C!%5Cright)%20=%20%5Cfrac%7Bn!%7D%7Br!(n-r)!%7D" alt="\left(\! \begin{array}{c} n \\ r \end{array} \!\right) = \frac{n!}{r!(n-r)!}"></p><p>在任何情况下，应尽可能避免手动添加一些空格：它使源代码更复杂，并且它违背了“所见即所得”的基本原则。最好的办法是使用您想要的所有空格定义一些命令，然后，当您使用命令时，您不必添加任何其他空格。稍后，如果您改变主意关于水平空格的长度，您可以轻松地更改它，仅修改您之前定义的命令。让我们用一个例子：你想要的 <em>d</em> 的 <em>dx</em> 中不可分割的是在罗马字体和狭小的空间从休息了。可以定义如下命令<code>\int x \</code>, <code>\mathrm{d} x</code>来要键入类似的积分：</p><pre><code>\newcommand{\dd}{\mathop{}\,\mathrm{d}}</code></pre><p>在您的文件的序言中。我们选择的<code>\dd</code>只是因为它提醒它取代它的“d”并且输入速度很快。这样做，你的积分代码就变成了<code>\int x \dd x\dd</code>。现在，每当你写一个积分时，你只需要使用而不是“d”，你的所有积分都将具有相同的风格。如果你改变主意，你只需要改变序言中的定义，所有的积分都会相应改变。</p><h3 id="3-13-手动指定公式样式"><a href="#3-13-手动指定公式样式" class="headerlink" title="3.13 手动指定公式样式"></a>3.13 手动指定公式样式</h3><p>要使用文本样式手动显示公式的片段，请使用大括号括起片段并使用片段作为前缀\textstyle。大括号是必需的，因为\textstyle宏会更改渲染器的状态，以文本样式呈现所有后续数学。大括号将此状态更改限制为仅包含在其中的片段。例如，要仅使用总和符号中的文本样式，就可以输入</p><pre class="line-numbers language-ruby"><code class="language-ruby">\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>   <span class="token constant">C</span><span class="token operator">^</span>i_j <span class="token operator">=</span> <span class="token punctuation">{</span>\textstyle \sum_k<span class="token punctuation">}</span> <span class="token constant">A</span><span class="token operator">^</span>i_k <span class="token constant">B</span><span class="token operator">^</span>k_j\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与命令相同的东西看起来像这样:</p><pre><code>\newcommand{\tsum}[1]{{\textstyle \sum_{#1}}}</code></pre><p>注意额外的括号。围绕表达式只有一组是不够的。这将导致<code>\tsum k</code>使用文本样式显示所有数学后。</p><p>要使用显示样式显示公式的一部分，请执行相同的操作，但请<code>\displaystyle</code>改用。</p><h3 id="3-14-在公式中引入点"><a href="#3-14-在公式中引入点" class="headerlink" title="3.14 在公式中引入点"></a>3.14 在公式中引入点</h3><p>amsmath还定义了<code>\dots</code>命令，即现有的泛化<code>\ldots</code>。您可以<code>\dots</code>在文本和数学模式下使用，LaTeX将用三个点“…”替换它，但它将根据上下文决定是将它放在底部（如<code>\ldots</code>）还是居中（如<code>\cdots</code>）。</p><p>LaTeX为您提供了几个在公式中插入点（椭圆）的命令。如果您必须键入省略元素的大矩阵，这可能特别有用。首先，这里是LaTeX提供的与点相关的主要命令：</p><table><thead><tr><th>代码</th><th>输出</th><th>附注</th></tr></thead><tbody><tr><td><code>\dots</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cdots" alt="\dots"></td><td>通用点（省略号），用于文本（外部公式）。它根据上下文自动管理自身前后的空白，这是一个更高级别的命令。</td></tr><tr><td><code>\ldots</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cldots" alt="\ldots"></td><td>输出类似于前一个，但没有自动空白管理; 它工作在较低的水平。</td></tr><tr><td><code>\cdots</code></td><td><img src="https://math.jianshu.com/math?formula=%5Ccdots" alt="\cdots"></td><td>这些点相对于字母的高度居中。还有二进制乘法运算符，<code>\cdot</code>如下所述。</td></tr><tr><td><code>\vdots</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cvdots" alt="\vdots"></td><td>垂直点</td></tr><tr><td><code>\ddots</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cddots" alt="\ddots"></td><td>对角点</td></tr><tr><td><code>\iddots</code></td><td></td><td>反对角点（需要mathdots包）</td></tr><tr><td><code>\hdotsfor{n}</code></td><td></td><td>要在矩阵中使用，它会创建一行跨越 <em>n</em> 列的点。</td></tr></tbody></table><p>而不是使用<code>\ldots</code>和<code>\cdots</code>，您应该使用面向语义的命令。它可以使您的文档在运行中适应不同的惯例，以防万一（例如）您必须将其提交给坚持在这方面遵循家庭传统的出版商。各种类型的默认处理遵循美国数学协会的惯例。</p><table><thead><tr><th>代码</th><th>输出</th><th>附注</th></tr></thead><tbody><tr><td><code>A_1,A_2,\dotsc,</code></td><td><img src="https://math.jianshu.com/math?formula=A_1,A_2,%5Cdotsc," alt="A_1,A_2,\dotsc,"></td><td>用“逗号点”</td></tr><tr><td><code>A_1+\dotsb+A_N</code></td><td><img src="https://math.jianshu.com/math?formula=A_1+%5Cdotsb+A_N" alt="A_1+\dotsb+A_N"></td><td>用于“带二元运算符/关系的点”</td></tr><tr><td><code>A_1 \dotsm A_N</code></td><td><img src="https://math.jianshu.com/math?formula=A_1%20%5Cdotsm%20A_N" alt="A_1 \dotsm A_N"></td><td>为“乘法点”</td></tr><tr><td><code>\int_a^b \dotsi</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cint_a%5Eb%20%5Cdotsi" alt="\int_a^b \dotsi"></td><td>为“积分点</td></tr><tr><td><code>A_1\dotso A_N</code></td><td><img src="https://math.jianshu.com/math?formula=A_1%5Cdotso%20A_N" alt="A_1\dotso A_N"></td><td>为“其他点”（以上都不是</td></tr></tbody></table><p>本文根据<a href="https://www.jianshu.com/p/05987743d27c">Stone_Stan4d</a>进行修改，仅限自用！如有涉及侵权，请联系本人进行删除。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> Formula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calibration</title>
      <link href="/2020/03/27/20200327-calibration/"/>
      <url>/2020/03/27/20200327-calibration/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>This section discusses general calibration and calibration strategies when preparing for VLA observations. Specific calibration during  post-processing—not depending on data taken during the observations—such as improved antenna positions, opacity and ionospheric corrections, are not discussed here. Note, however, that there is specific guidance with respect to the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/set-up">8/3-Bit Attenuation and Setup Scans</a> that are required in observing scripts (scheduling blocks).</p><p>If you are looking for the listing of VLA calibrators, go to the <a href="https://science.nrao.edu/facilities/vla/observing/callist">VLA Calibrator List</a>.</p><h2 id="Calibration-Basics"><a href="#Calibration-Basics" class="headerlink" title="Calibration Basics"></a>Calibration Basics</h2><p><strong>What is calibration?</strong></p><p>The main goal of calibration is to be able to correct for effects  that may interfere with the scientific outcome of a measurement (an  observation) due to the instrument and/or local temporary conditions so  that these measurements can be compared to other measurements (at other  times, other instruments, other frequencies, etc.) and theoretical  predictions.</p><p>Calibration starts in the device design stage and ends in the final  data presentation. Calibration can refer not only to calibration of the  data, but also to the instrument as a whole or its separate components.  The amount of calibration typically depends on the observing program and the science goal. Some calibrations need to be done once as their  solution is fairly constant over time, while other calibrations need to  be repeated regularly to capture changing properties over time. For  radio astronomy, and in particular interferometry, the following general calibration steps can be identified: calibration of the instrument by  observatory staff, calibration of the current observing conditions by  the observer, and calibration of scientific results by the data  analyzer. Some common calibration examples:</p><ul><li>Calibration of the antenna (receiver frequencies, receiver system  temperatures, optics), antenna positions, timing, and correlator  visibilities is done by observatory staff.</li><li>Calibration of instrumental delay, instrumental polarization,  spectral bandpass response, absolute flux density scale, and other  possible properties—assumed to be constant during the observation—should be taken by the observer, typically once or twice during the entire  observation for each observed frequency and correlator configuration.</li><li>Calibration of antenna pointing, delay, attenuator and requantizer  settings, and other possible properties assumed to be only slowly  varying during the observation should be performed by the observer,  typically once every hour or so during the observation, or, for example, when switching frequency bands.</li><li>Calibration of antenna gains, atmospheric phase fluctuations, and  other possible properties expected to vary more rapidly with observing  conditions and geometry during the observation should be performed more  frequently than the time scale over which the property changes.</li><li>Calibration of the position of a source with respect to another  source, calibration of a frequency to a line-of-sight velocity,  calibration of a polarization angle to a reference angle, calibration of the flux density scale of a single source in one observation to another observation of the same source, etc.</li></ul><p>The taking of calibration data to be evaluated in the online system  or in post-processing happens before, during, and after the observation  and also may be applied before, during, and after the observation. Note  that most calibration applied before and during the observation, e.g.,  antenna pointing, take effect during the observation and the calibration must be correct as it cannot be adjusted after acquisition.</p><p>It should be understood that calibration is an important part of the  observation and must be thoughtfully included in the observation  preparation and time request in the proposal. The key point of planning  and including calibration is that if the observations are not properly  calibrated, the science goal will not be achieved.</p><p><strong>When to calibrate?</strong></p><p>Calibration should be performed, at the very least, more frequently than the time scale over which the property changes <em>and</em> before that change becomes too large to be compensated for. Nearly  constant properties should be calibrated at the start of an observation, when changes from a previous observation by another observer are to be  expected. If the constant property can be applied in post-processing,  this calibration can also be taken at the end of the observation. Time  or geometry dependent changes should be monitored at regular intervals  so that the change can unambiguously be interpolated over the  observation. Planned, abrupt changes in the observation, such as a  frequency change or observing a different part of the sky, would trigger calibration. Last, but not least, a very specific science goal may need a calibration that is not among the standard calibrations described  here. The calibration strategy is the responsibility of the observer,  but NRAO staff is available for individual advice through the <a href="https://science.nrao.edu/observing/helpdesk">NRAO Helpdesk</a>.</p><p>Typical calibration intervals are once during the observation for flux density, bandpass/delay, and polarization angle (per frequency setting and per  correlator configuration). It is prudent to at least break up the flux  density calibration scan into two or more separate scans, as this is the only calibration for which there is no good alternative if it happens  to be corrupted.</p><p>Typical intervals for complex gain (amplitude  and phase) calibration are dependent on the weather conditions and  baseline length. On longer baselines (i.e., on longer uv-distances and  therefore more important for high frequency observing), the phase change on the interferometer will be more rapid and requires more frequent  calibration than at the lower observing frequencies. An exception at low frequencies is when the Sun affects the ionosphere and rapid changes  can be expected near sunset and sunrise. Otherwise, the largest effect  on phase change is in the troposphere. The gain calibration uses the  assumption that the calibration toward the sky, in which the calibrator  source is observed, can be interpolated over time and viewing angle and  resembles the same atmospheric conditions toward the sky of the target  source. The further away the calibrator from the target, and the longer  the intervals of the calibration measurement, the less strict this  assumption will hold. It can happen that calibration consumes more than  half of the allocated observing time in order to achieve the scientific  goal. Fortunately, this may only be necessary at the highest  frequencies, in the largest array configurations, and in bad weather  conditions. With the introduction of dynamic scheduling at the VLA, this latter variable has been largely eliminated and gain calibration has  been easier to plan (see below).</p><p>Typical calibration intervals for attenuator settings are at the  beginning of an observation. Requantizer gains need to be redetermined  after a change of tuning, including when returning to the original  observational setup.</p><p>Calibration intervals for antenna pointing are largely dependent on  the geometry of the observation. As a rule-of-thumb, after tracking for  about an hour, the direction of the solutions of the antenna pointing  calibration will have changed significantly from where the target  position is now—on the order of 20°—warranting a new pointing solution.  During the day, because of temperature changes that affect antenna  optics, pointing should be repeated roughly every 30 to 40 minutes.  Also, when slewing a large distance from the target to a flux density or a bandpass calibrator (over 20° in AZ and/or EL), the antenna pointing will need an updated solution.</p><p><strong>How to calibrate?</strong></p><p>To ensure that the instrument is delivering the expected measure, the easiest method of calibration is to insert a known signal at the input  and analyze the resulting signal at the output. The calibration  measurement will yield, after some massaging, the corrections that need  to be applied to the output signal to obtain the true representation of  the input signal. The uncorrected output signal is also known as the  instrumental response for the given input signal. As determining the  response directly is not always possible, alternatives may be available. These alternatives require, however, certain trade-offs and choices to  be made by the observer depending on the science goals. Observatory  staff can advise, and a first attempt is made below. For very specific  questions, please ask the <a href="https://science.nrao.edu/observing/helpdesk">NRAO Helpdesk</a>.</p><p>A typical calibration signal for the instrumental response of an  individual antenna signal path is a pulse (the firing of a noise diode  in the receiver) and standard instrumental calibration procedures are  available. A typical calibration signal for the total observational  response of an interferometer is to observe a point source: a signal  that can be considered a simple, single, isolated object with a known  constant flux density, polarization as function of frequency, and  absolute sky position. As these objects are very rare for high-angular  resolution and high-sensitivity interferometers like the VLA,  alternatives that dominate the response (not necessarily constant in  flux density) and that are near point-like are common trade-offs for any radio interferometer. Many of these calibrator sources are given in the <a href="https://science.nrao.edu/facilities/vla/observing/callist">VLA Calibrator List</a>.</p><p>Then, depending on the signal property to calibrate, one would choose an  adequate calibrator source for the property and insert it at the  appropriate place in the observing schedule. This calibration is defined for a certain point in time for certain conditions and needs to be  redone when it starts to become invalid. Performing a calibration on the target field—a field where obtaining the measured properties are the  goal of the observation—generally is not a good idea. As a reasonable  approximation in general, therefore, it is assumed that for the  calibration performed near in time and near that field on the sky <em>also</em> holds for the target field and thus can be interpolated over the target observation. NRAO tries to provide guidance for when these assumptions  hold for different sets of observations, but the observer should always  be aware that certain conditions for successful interpolation of  calibration may not apply.</p><p>Specific suggestions for different VLA calibrations and how to schedule them are listed elsewhere in the Guide to Observing (<a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/hifreq">High Frequency Strategy</a>, <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/lofreq">Low Frequency Strategy</a>, and <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/vlofreq">Very Low Frequency Strategy</a>), and the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/opt">OPT Manual</a>. In this section the focus is on general, non-frequency specific,  calibration during the observation by the observer. When making a  schedule, consider the hints given here and elsewhere in the  documentation. Do not hesitate to contact the <a href="https://science.nrao.edu/observing/helpdesk">NRAO Helpdesk</a> for assistance or further information.</p><h2 id="VLA-Calibration-by-the-Observer"><a href="#VLA-Calibration-by-the-Observer" class="headerlink" title="VLA Calibration by the Observer"></a>VLA Calibration by the Observer</h2><p>When seen from the observer’s perspective, for any standard  observation in each scheduling block, the observer is expected to  include calibration of the absolute (flux density) scale, calibration of the signals at different frequencies relative to each other over the  observing bandwitdh (bandpass), and calibration of the time dependent  effects (complex gain (phase and amplitude)) of changing conditions due  to the atmosphere and instrument. More sophisticated or challenging  experiments may include more specific calibrations as described below.</p><h3 id="Flux-Density-Scale-Calibration"><a href="#Flux-Density-Scale-Calibration" class="headerlink" title="Flux Density Scale Calibration"></a>Flux Density Scale Calibration</h3><p>The correlator, where signals at specific frequencies from the  antennas are combined into visibilities, only processes what it gets fed from the electronics system in terms of relative signal strength and  relative phase. The correlator products, therefore, need to be  readjusted to represent the flux density as measured from the sky  visibilities. At the VLA this means that one observes a calibrator with a postulated (or assumed) known flux density at these frequencies along  with the other observations in the scheduling block. In post-processing, the visibilities are then rescaled for this calibrator to the flux  density for this frequency. Other visibilities in the same observation,  using the same setup, can simply be matched using the relative scale and the absolute flux density of the calibrator.</p><p>The flux density scale adopted for the VLA between 1 and 50 GHz is based on the <a href="http://iopscience.iop.org/article/10.3847/1538-4365/aa6df9">Perley and Butler (2017)</a> standard. This is very close to the traditional Baars et al. scale (<a href="http://adsabs.harvard.edu/abs/1977A%26A....61...99B">1977 A&amp;A 61, 99</a>) between 1 and 15 GHz and includes the Scaife and Heald scale (<a href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?bibcode=2012MNRAS.423L..30S&amp;db_key=AST&amp;link_type=ABSTRACT&amp;high=570ff063fe13730">2012, MNRAS 423, L30</a>) for frequencies below 1 GHz. Distributed versions of AIPS and CASA apply the most recent scale in their SETJY tasks.</p><p>Because of source variability, it is impossible to compile an  accurate and up to date listing of flux densities for all the VLA  calibrators. The values given in the <a href="https://science.nrao.edu/facilities/vla/observing/callist">VLA Calibrator List</a>, therefore, are only approximate and for the epoch they were measured.  We strongly recommend, and some science objectives require,  bootstrapping the flux density of a calibrator by comparing the  calibrator observations with one or several observations of 3C286, 3C48*****, 3C147, or 3C138. Only in compact configurations <em>and</em> at low frequencies, i.e., typically at L- and P-band in C and D configuration, 3C295 or 3C196 may also be used.</p><p>Both AIPS and CASA use model images for the standard flux density  calibration sources (see their respective SETJY documentation) to  account for their structures which are frequency and array configuration dependent. Alternatively, u,v restrictions, or limitations on the  number of antennas, can be used. When using models, the bootstrap  accuracy should be within a couple to a few percent. However, at  frequencies of about 15 GHz and above, there are appreciable changes in  the antenna gains and atmospheric opacity as a function of elevation. By calibrating the target source with a nearby calibrator, much of these  variations can be removed. If the primary flux density calibrator (e.g., 3C286) is observed at a different elevation from the secondary gain  calibrator, however, then the flux density bootstrapping will have a  considerable systematic error. For the higher frequencies, a typical  discrepancy in actual versus measured flux density scale of the order of 20-30% is not unlikely.</p><p>Accurate models are available in both AIPS and CASA for various frequency bands for the calibrators 3C286, 3C48*****, 3C147, and 3C138. However, neither 3C295 nor 3C196 has such models and the VLA CASA  calibration pipeline will fail if these two calibrators are used. Also,  the bright source 3C84 (J0319+4130, not to be confused with 3C48) cannot be used as an absolute flux density calibrator as it is variable, but  it serves well for bandpass and delay calibration.</p><p>See also the flux density scale discussion in the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/oss/performance/fdscale">VLA Observational Status Summary (OSS)</a>.</p><p>*** The flux density  scale calibrator 3C48 has been undergoing a flare since January 2018 or  so. While we have not fully characterized this with the VLA, other  instruments have measured it at some frequencies. At Ku-band the  magnitude of the flare is of order 10%. The effect will be smaller at  lower frequencies (of order 5% at L-band), and might be larger at higher frequencies (of order 20% at Q-band). If you care about the flux  density scale of your observations at that level, you may want to  re-calibrate your data once new time-variable values have been put into  CASA and AIPS.**</p><p> Bandpass and Delay Calibration</p><p>Small impurities in the correlator model, such as an inaccurate  antenna position, timing, etc., cause small deviations from the model  that are noticeable as a time-constant linear phase slope as function of frequency in the correlated data for a single baseline. This phase  slope, known as a <em>delay</em>, is a property of the IF baseband and  the same for all subbands (spectral windows) in a baseband. If the  frequencies in an observation are averaged into a continuum image, an  uncorrected delay causes decorrelation of the continuum signal and is  not a correct representation of the sky. The delay calibration is  determined on a short time interval on a strong source in order to  achieve high signal to noise for the solution without including the time dependent variations.</p><p>Small impurities in the frequency amplitude and phase response as  function of frequency, independent of the delay, also occur and have to  be corrected. These corrections are a property of the passband on top of the response of the baseband, and are a property of the subband and the location of the subband in a baseband. Leaving the <em>bandpass</em>  uncorrected causes incorrect relative amplitudes and phases and does not deliver the correct spectral representation of the sky. Averaging these uncorrected impurities over frequency into a continuum image limits the achievable signal to noise and dynamic range. As for the delay,  bandpass calibration is usually determined on a short time interval on a strong source to achieve high signal to noise for the solution without  including the time dependent variations. Delay and bandpass calibration, therefore, is usually performed using the same calibrator. Hereafter in the text, delay calibration is implicitly included in the bandpass  calibrator or bandpass calibration scan.</p><p>To achieve good results in both spectral line and continuum  observations, the baseband delay and subband bandpass shapes have to be  calibrated for each frequency setup. If very high dynamic range is not  the aim (in many cases for continuum observations, the standard flux  density calibrators are relatively convenient bandpass and delay  calibrators), using flux density calibrators has the big advantage that, for these sources, the known spectral index can be included in the  bandpass amplitude solution. At high frequencies, however, for which the flux density calibrators are weak, other calibrators might provide a  better alternative.</p><p>The typical requirement for bandpass calibration is that it does not  add to the phase or amplitude noise in the image cube, i.e, that the  signal to noise of the bandpass calibration solution is comparable—or  better—than the signal to noise of the flux density of the target. The  requirements, however, are dependent on your science goals and type of  observation. For very bright spectral lines on the order of tens of Jy  in a single spectral channel, this might not be feasible; for other  spectral line cases it is a good rule of thumb. As the noise is  proportional to the inverse of the root of bandwidth times observing  time, and with the channel bandwidth a constant between the scans, the  time spent on the bandpass calibrator (<em>tcal</em>) should be larger than the time spent on the target (<em>tobj</em>) multiplied by the square of the ratio of the target (<em>Sobj</em>) over the flux density calibrator (<em>Scal</em>): tcal &gt; tobj × (Sobj / Scal)2. That is, the brighter the calibrator, the shorter the scan needs to be. Note that instead of a bright bandpass calibrator, it is also possible  to sum all scans of a gain calibrator to obtain sufficient signal to  noise for a bandpass determination. For plain continuum observations  this requirement can be somewhat relaxed to a good solution of a  representation of the bandpass, as the data are averaged over frequency, using a minimum signal to noise at least 5 to approximately 10. If one  is interested in high dynamic range or accurate polarization imaging,  however, this solution typically is not enough and one would have to  adopt the spectral line approach.</p><p>The <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/modes/line">Spectral Line</a> guide describes more details. For further information or other questions contact the <a href="https://science.nrao.edu/observing/helpdesk">NRAO Helpdesk</a>.</p><h3 id="Complex-Gain-Calibration"><a href="#Complex-Gain-Calibration" class="headerlink" title="Complex Gain Calibration"></a>Complex Gain Calibration</h3><p>Where the absolute flux density scale calibration is a static  multiplier, and the bandpass/delay calibration a one-off determination  of the signal path properties assumed to be largely constant for the  observation, the antenna gain calibration (also known as complex gain)  is anticipated to track time variable properties due to changing  conditions of the instrument. Complex gain calibration also tracks  changes with the environment except for antenna pointing (see below),  that, if not corrected for, will be absorbed. Examples of variable  instrumental properties are: receiver power level settings, corruption  of baseband samplers, technicians removing receivers, etc.. The largest  time variable contribution is from the environment and atmosphere:  mostly the ionosphere at low frequencies, the troposphere at high  frequencies, water content/opacity on cloudy days, elevation/opacity due to observing geometry and other occasional phenomena like solar flares, broadcasting satellites, tourist cell phones, digital cameras, etc.  Some of these can be calibrated and corrected for using proper gain  calibration while others, referred to as Radio Frequency Interference  (RFI), cannot and need to be removed (flagged) from the data.</p><p>Gain calibration is normally considered antenna based and assumes  that fluctuations in the antenna gain are due to slowly varying  amplitudes and phases. Slowly here means that the interval of the gain  calibration scans are short enough that the variations can be  interpolated by a relative smooth function which would represent the  true variation at the antenna. Gain phase varies much, much faster than  gain amplitude as most of the time dependent effects affect phase more  than amplitude. Additionally, phase variations scale with baseline  length with more rapid changes on longer projected baselines. The  typical time for such changes to become large enough to require  calibration is referred to as the <em>coherence time</em>, i.e., when  the visibility phase has changed by a radian. This coherence time may be some tens of minutes at short baselines and low frequencies or, in some realistic cases, sub-minute on long baselines for high frequency  observations in non-optimal weather. Because of this huge range and  frequency specific dependence, consult the Cycle Time section at the end of this document.</p><p>Gain calibration is performed as regularly repeated scans on the  complex gain calibrator to measure the change in visibility amplitude  and phase on the gain calibrator. These changes are then interpolated  over the target field scan. Removing the large fluctuations, in effect,  increases the coherence time of the observation; ultimately to longer  than the total target observation duration. All data on the target field scan can then be coherently combined into a single image, which  supposedly would be the goal of the observation. Note that the  calibration solutions sometimes show deviant points with respect to the  solutions of other times for the same antenna. Recall that these are the solutions (or corrections) needed to obtain the point-like input signal and are not necessarily wrong. It is a good indication that something  is happening in the data and, only upon investigation, should one decide whether or not using that point in the interpolation to the target  field. That is, will it improve or destroy the target data, or be  irrelevant in the case of self-calibration (see below)? The discrepant  solution can be deleted to prevent interpolation and thus causes target  data flagging, or be kept for subsequent calibration and imaging.</p><p>Calibration can be considered for three different cases:</p><ul><li>To only capture the slowly varying amplitude fluctuations. The  coherence time to track and interpolate phase over the target field is  irrelevant because the target field contains sufficiently bright  emission to recover the phase fluctuations on time scales shorter than  the coherence time. Typical cases are a targeted, not necessarily  point-like, strong continuum source; a bright maser line at any  observing band; or, e.g., the background continuum field for the large  field of view (primary beam) of the lower frequency bands. As the  information to perform this phase calibration (next to the amplitude  gain calibration) is contained in the target field, this additional  target field calibration is known as <strong>self-calibration</strong> or <strong>selfcal</strong>. Care should be taken in the self-calibration model as, in principle,  absolute phase—and therefore absolute position—is lost in the process.</li><li>To capture the rapid phase variations in addition to the amplitude  variations. Here it is attempted to extend the effective coherence time  as self-calibration is not an option for faint targets or detection  experiments. Also, very extended or complicated source structures, when a selfcal model is not easily obtained, are typical cases for this  traditional gain calibration strategy where the calibrator and target  are observed in alternating scans. The target field phases are tied or  referenced to those of the calibrator, which is known as <strong>phas****e</strong> <strong>referencing</strong>. The cycle times for alternating the scans are dependent on observing  frequency, baseline length, field separation, weather, and elevation.  Suggested times are given in table 4.3.1 (below), where cycle times are  discussed. If, after such calibration, it appears that the target field  matches the requirements for self-calibration, then self-calibration may be applied to further improve the calibration.</li><li>To obtain astrometry. For this one should avoid applying selfcal and utilize a much more careful phase calibration scheme. Some hints on  phase-referencing for astrometry are given below.</li></ul><h3 id="Specialized-Calibration"><a href="#Specialized-Calibration" class="headerlink" title="Specialized Calibration"></a>Specialized Calibration</h3><h4 id="Antenna-Reference-Pointing-Calibration"><a href="#Antenna-Reference-Pointing-Calibration" class="headerlink" title="Antenna Reference Pointing Calibration"></a>Antenna Reference Pointing Calibration</h4><p>When directed to a position in the sky, the individual antennas are commanded to move in azimuth (AZ) and elevation (EL) until they report that they have arrived. The <em>a priori</em> accuracy of pointing at the actual position in the sky is typically  within about 10 arcseconds; but individual antennas may differ up to an  arcminute in AZ and/or EL. and the  deviation depends on many non-constant factors. At the higher  frequencies (above ~15 GHz), this intrinsic pointing error may be a  large fraction of the primary beam (which is one arcminute at 45 GHz,  two arcminutes at 22 GHz, etc.), potentially considerably degrading the  sensitivity of the antenna at the position of interest. It is therefore  important to correct for this possible mechanical error before observing the calibrators (complex gain, bandpass, etc.) and the target field.  Antenna pointing calibration is essential for high-frequency observing  but, as the beam sizes at lower frequencies quickly become many  arcminutes, pointing calibration is typically skipped for the lower  frequencies. One exception is high-dynamic range imaging of large fields where differing antenna beam patterns on the sky will hinder obtaining  accurate source flux densities in the entire field of view and pointing  calibration also at low frequencies may be imperative.</p><p>Simple procedures, referred to as <strong>reference pointing</strong>, are in place to determine the AZ and EL position offsets during the observing program using X-band. Once  determined, these offsets should be applied to the scans following to  take effect immediately; this is an on-line calibration. Pointing  calibration sources (see about choosing one below) can be your default  calibrator sources (for flux density, bandpass and/or complex gain), as  well as your target source if your science goal and target source would  allow that. A pointing calibration scan needs an on-source time of 2m30s to be able to perform a five-point observation around the calibrator to derive solutions.</p><p>The antenna pointing offset will change after some time due to  changes in the dish structure (optics) or because the target field is  being tracked from rise in the East to set in the West. The reference  pointing solution needs to be repeated before the pointing has degraded  to yield less sensitivity. NRAO recommends that pointing be repeated  when the difference from the last pointing calibration direction in AZ or EL coordinate has changed by 20° on the sky, i.e., after about an hour  when tracking a source at the celestial equator assuming nighttime  observing. During daytime observing reference pointing may need to be  repeated every 30-40 minutes due to the thermal deformation of the  dish structure. The recommendation noted earlier also implies that the  pointing calibrator source should be closer than that range from the  target field; NRAO recommends that the pointing calibrator be within of  10° of the target if at all possible. Hence, large slews to a bandpass  or a flux density calibrator, or a different target patch on the sky,  will require a new pointing scan regardless of how long it has been  since the last one was done.</p><h4 id="Polarization-Calibration"><a href="#Polarization-Calibration" class="headerlink" title="Polarization Calibration"></a>Polarization Calibration</h4><p>The VLA observes with two orthogonal receivers. These are right and  left circular polarization (RCP and LCP) for all bands except below 1  GHz where they are X and Y linear polarization. For the total intensity  Stokes parameter <em><strong>I</strong></em>, the correlator produces  the parallel hand correlations (RR and LL or XX and YY) from the signals of the two antennas of each interferometer. They are combined in the  imaging to produce the total intensity <em><strong>I</strong></em> image of the sky; Stokes <em><strong>V</strong></em> may be created from the RCP and LCP difference. Using the default  continuum modes, the cross hand polarization products (RL and LR or XY  and YX) are also produced which allow to map the other Stokes parameters <em><strong>Q</strong></em> and <em><strong>U</strong></em> and combine all data into an image of the polarized sky.</p><p>In order to obtain the correct polarization characteristics, two  calibrations have to be performed. First, because the receivers are  independent and orthogonal but not completely free of impurity, the  leakage (<em><strong>D</strong></em>-term) and relative signal between  the receivers as function of frequency need to be determined in order to properly combine the signals (compare it with the frequency dependence  of amplitude and phase over a bandpass). The polarization vectors should then be tied to an absolute reference with a polarization angle  calibration (compare it with fixing the absolute flux density) using a  source with known polarization characteristics, like 3C286.</p><p>Typical impurities of the receiver feeds are a few percent for the  center of most VLA bands and degrade toward the band edges and away from the pointing center in the image plane. Without any polarization  calibration, an unpolarized source will appear to be polarized at a few  percent level. Without calibration of the R-L phase difference, the  polarization angle is undetermined. It is not difficult to obtain a  reasonably good polarization calibration under most circumstances and,  with the leakage terms being fairly constant over weeks to months, they  can be transferred to other observations with the same spectral setup.  With a modest investment of time spent on calibrators, and a little  effort, the instrumental polarization can be reduced to less than 0.1%.</p><p>More information on polarization, including the most common calibrators, can be found in the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/modes/pol">Polarimetry</a> section.</p><h4 id="Astrometry"><a href="#Astrometry" class="headerlink" title="Astrometry"></a>Astrometry</h4><p>Calibration for astrometry is a bit different with respect to the above, as one does not calibrate the instrument <em>per se</em> but instead calibrates the sky. The usual complex gain calibration  makes use of calibrator sources and, when interpolating the phase  information for the calibrators over the target field scans, one ties  the position of any source in the target field to the assumed (measured) position of the calibrator source. Apart from the peculiar errors  introduced by the interpolation of the calibrator phase to the target,  there is an <em>additional systematic error</em> due to the position  measurement of the calibrator. Unfortunately, this additional systematic error is typically ignored in the literature but is certainly not  negligible if one attempts to do astrometry; proper motions and/or  comparisons with other data that may have used different calibrator  sources.</p><p>To improve on astrometric accuracy, two types of calibration should  be considered. First, one would try to improve on the systematic error  of the calibrator position. An updated position from, e.g., a VLBI  detection, can always be included in post- processing. The <a href="https://science.nrao.edu/facilities/vla/observing/callist">VLA Calibrator List</a> contains a position accuracy indicator of A, B, C or T, where A is the  most accurate (positional accuracy &lt; 0.002 arcseconds or 2 mas) and T should probably be avoided (positional accuracy worse than 0.15  arcseconds) for most science goals. If there is a choice in nearby  calibrator sources—suitable for the array configuration and frequency  band of the observation—it would be prudent to select the source with  the best known position and thus the smallest systematic error.</p><p>The second place of improvement is in the actual interpolation.  Typical gain phase calibration uses repeated observations of a single  nearby calibrator and transfers the interpolated phases to the target  field. One can improve on this interpolation by using a calibrator  closer to the target field or by sampling the interpolated phases more  densely via shorter cycle times or faster switching. Strictly speaking,  even if the interpolation is perfect, it is derived for the direction of the calibrator position and not for the direction of the target field.  There may be a constant residual phase, or a phase wedge that is not  accounted for, introducing an unknown positional offset that, at best,  is only a single time constant vector perpendicular to the unknown  direction of the wind aloft. A possible solution would be to include  more repeated calibrator scans toward suitable calibrators in other  directions with respect to the target field. In post-processing, one may be able to make a more detailed interpolation of the phase and phase  behavior of the target field, provided that the observations are set up  to anticipate such a procedure. It is also useful to include another  calibrator source with a known position and exclude it from the  calibration steps by treating it as a target (also known as the  phase-check source); the position derived as for a normal target field  would yield an indication of the magnitude of remaining errors when  compared to the known position of that phase-check calibrator.</p><h4 id="Observing-the-Sun"><a href="#Observing-the-Sun" class="headerlink" title="Observing the Sun"></a>Observing the Sun</h4><p>As the Sun is very bright, observing the Sun requires special considerations, so please consult the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/oss/performance/solar-observing">Observatory Status Summary</a>, the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/opt/solar-observing">OPT manual</a> and <a href="https://science.nrao.edu/observing/helpdesk">NRAO Helpdesk</a> if observing the Sun is part of your intentions.</p><h4 id="Tipping-scans"><a href="#Tipping-scans" class="headerlink" title="Tipping scans"></a>Tipping scans</h4><p>The atmospheric opacity can be measured by performing so-called <em>Tipping scans</em> during the observation. Tipping scans can be set up for the VLA using  the OPT, but at this moment there is no general way of processing the  measurements and applying the opacity corrections to the data in CASA or AIPS.</p><h2 id="Calibration-Recommendations"><a href="#Calibration-Recommendations" class="headerlink" title="Calibration Recommendations"></a>Calibration Recommendations</h2><p>The main objective of calibration scans in the observation is to  correct for effects, instrumental and observational, that distort the  object or field of interest. The method is to measure the response of  the instrument to a known calibration signal to determine the  corrections needed to retrieve or reconstruct the known signal from the  data. The corrections are then applied with the assumption that the  effects that distort the calibration signal also apply, whether or not  interpolated, to the observations toward the object or field of  interest. As previously mentioned, the different calibrators—flux  density, bandpass, complex gain, and reference pointing—are selected to  optimally perform the measurement requested by the observer. Each of  these calibrations needs a specific property of the calibrator source  that will enable a good calibration. A good pointing calibrator may not  be a good bandpass calibrator and <em>vice versa</em>; a good complex gain calibrator may not be a good flux density calibrator, etc.</p><p>A technique of good calibration sometimes relies on finding the right trade-offs: one calibrator versus the other (e.g. flux density or  source structure versus angular distance), a longer on source time  versus better sampling, etc. The selection of which trade-off to use is a function of the science goal and in general cannot be answered with a  straight single solution by NRAO staff without knowing all the details  of the observing program. Some tips given here, however, might be  helpful in making an informed decision.</p><p>Requirements for good calibration are that it yields sufficient  signal-to-noise to derive an unambiguous and valid calibration solution. The aim is for a signal-to-noise of over 10–20 at the observing  frequency during the solution interval (scan, part of a scan, or total  observing period) for a single (longest) baseline, single polarization,  and relevant spectral coverage. Spectral coverage can range from the  total observing bandwidth, to the individual spectral chunks known as  basebands/IFs or subbands/spectral windows, down to the narrowest  spectral channel (see below about scan length).</p><h3 id="Calibrator-Summary"><a href="#Calibrator-Summary" class="headerlink" title="Calibrator Summary"></a>Calibrator Summary</h3><p>To minimize the impact on the actual observing, consider the  following general statements and descriptions of known (calibration)  signals:</p><ul><li><p>Absolute Flux Density:</p></li><li><ul><li>Select one of the very few standard flux density calibrators: 3C286 if you can, or alternatively 3C48*****, 3C138, or 3C147. Note that for the very low frequencies other sources  may be used and it is therefore wise to check up on the specific  frequency guides listed below for any observation.</li><li>The best flux density calibrator is the one that fits best in the observing schedule and may not be 3C286; 3C48***** and 3C147 in general are good alternatives but 3C138 should be avoided  as it has shown variability (!). Note that 3C295 may be used <em>only</em> for low frequency (P and L band) observations in the more compact array configurations for flux density calibration in the northern part of the sky, i.e., where all other source Declinations are more than 34°.  Similar restrictions hold for 3C196.</li><li>*** The flux density  scale calibrator 3C48 has been undergoing a flare since January 2018 or  so. While we have not fully characterized this with the VLA, other  instruments have measured it at some frequencies. At Ku-band the  magnitude of the flare is of order 10%. The effect will be smaller at  lower frequencies (of order 5% at L-band), and might be larger at higher frequencies (of order 20% at Q-band). If you care about the flux  density scale of your observations at that level, you may want to  re-calibrate your data once new time-variable values have been put into  CASA and AIPS.**</li></ul></li><li><p>Delay and Bandpass:</p></li><li><ul><li>In general, the delay and bandpass calibrator need the same  properties; they just need to be bright at the observing frequency to  obtain calibration solutions with a very high signal-to-noise ratio. The bandpass calibration scan typically can be used for the delay  calibration (where the delay is calibrated and applied before  determining the bandpass corrections).</li><li>One chooses a strong calibrator, not necessarily point-like or near  the target fields, which can be your flux density or pointing calibrator (below). In that case make sure there is an additional bandpass intent  in the flux density calibration scan, or an additional bandpass scan  with appropriate intent directly after the pointing scan.</li></ul></li><li><p>Complex Gain (amplitude and phase):</p></li><li><ul><li>The best complex gain calibrator sources are bright (over a couple  hundred mJy/beam), have a known structure (preferably point-like, with  calibrator codes P or S), and are seen through the same atmosphere as  the target (i.e., are nearby, within less than 10° for high frequency  observations, or within about 15° for low frequency observations).</li><li>If the <a href="https://science.nrao.edu/facilities/vla/observing/callist">VLA Calibrator List</a> does not provide a flux density for the frequency band, which is a  common problem for observing in S, K or Ka-bands, you may be able to use an interpolation from the bordering frequency flux density information: if a calibrator has a flux density in Ku and Q-bands, the Ka and  K-bands flux densities can be interpolated and judged for suitability,  etc. Calibrators at Q-band are typically flat spectrum sources and can  be assumed, if no other information is available at lower frequency  bands, to have approximately a similar flux density at Ka and K-bands  (assuming they are not too variable, which is not necessarily the case).</li><li>If there is no bright complex gain calibrator within a few degrees,  use one that is weaker but closer over one that is brighter but further  away if observing using the higher frequency bands. If observing at the  low and very low frequency bands, where bright sources in the field of  view may be confused, a different source that dominates its field may be a better choice, even if it is located further away.</li></ul></li><li><p>Reference Pointing:</p></li><li><ul><li>Choose a point-like (calibrator code P or S, never a W, X or “?”)  and bright (0.3 Jy/bm or brighter at X-band, the pointing scan observing band) calibrator near the field of interest as pointing corrections are needed for the azimuth and elevation near the target. Pointing sources  should always be near the target field(s), so for the entire observing  run more than one might be needed. Antenna pointing calibration is  recommended at the four highest observing frequencies (Ku, K, Ka, and  Q-bands) as well as for very high dynamic range imaging in the lower  frequencies. A pointing calibration scan needs an on-source time of 2m30s, i.e., this should be the remaining length of the scan  after slewing to the source from the previous scan.</li></ul></li><li><p>Polarimetry:</p></li><li><ul><li>For polarimetry, one either chooses a strongly polarized source from the list of known polarized calibrators, or an unpolarized calibrator  to calibrate the D-terms. For polarization angle one observes a well  known polarization calibrator such as 3C286; see the section on <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/modes/pol">Polarimetry</a> for more details.</li></ul></li><li><p>Astrometry:</p></li><li><ul><li>If the science goal includes astrometry for the target, the best  positional information is obtained with complex gain calibrators that  are near the target source carrying code P in the array configuration of the observation and, in addition, have a positional uncertainty code of A (positional accuracy better than 2 mas).</li></ul></li></ul><h3 id="About-Calibrator-Scans"><a href="#About-Calibrator-Scans" class="headerlink" title="About Calibrator Scans"></a>About Calibrator Scans</h3><p>One will notice that in many cases, the ideal calibration sequence  and ideal calibrator sources cannot be implemented in the schedule  perfectly. Here are some logistical issues that may impact an observing  session and the necessary calibrations:</p><ul><li>If the target and calibrator are on opposite sides of the zenith (on either side of Declination 34), the antenna cable unwrapping can be a  problem. For more information, see the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/dynsched/antenna-wraps">Antenna Wraps</a> section.</li><li>If a bandpass or flux density calibrator is not available at the  start of an observation, choose another calibrator or place these scans  at the end of the observation.</li><li>If the bandpass calibration is corrupted by RFI or missed by some  event during the observation, use the accumulated data on the strongest  complex gain calibrator or any other calibrator for which the  accumulated data gives sufficient signal-to-noise. Alternatively, if the flux density calibrator is strong enough at the given frequency, it can be used as the bandpass calibrator.</li><li>If the complex gain calibrator turns out to be resolved or extended, and not point-like, self-calibrate and image the structure of the  calibrator and use the image—not a point-source approximation—for  complex gain calibration. Alternatively, use the suggested (u,v)-ranges  in the calibration task (which can be found in the calibrator list).</li><li>If the complex gain calibrator source is weak, or the accumulated  scan time was too short, combine the data over all frequencies to obtain sufficient signal-to-noise to derive a complex gain solution.</li></ul><h3 id="Calibrator-Scan-Length"><a href="#Calibrator-Scan-Length" class="headerlink" title="Calibrator Scan Length"></a>Calibrator Scan Length</h3><p>The calibrator scans should be long enough to derive the desired  correction with sufficient accuracy. To ensure a good solution, be  conservative and account for possible loss of data due to flagging  operations (scan start slewing, band edges, RFI).</p><p>The standard way to determine the approximate length of a complex  gain calibrator scan, as well as scans for bandpass and flux density, is first to find the approximate flux density of the calibrator which can  be extracted from the source properties in the Source Catalog Tool (SCT) in the OPT, or from the <a href="https://science.nrao.edu/facilities/vla/observing/callist">list of VLA calibrators</a>. As flux densities may vary over time (except for the standard  calibrators), assume a conservative 10–15% less in flux density for each of the calibrators to be used (e.g., not 2.4 but about 2.1 Jy/beam),  maybe even ~40% less for the higher frequencies. A conservative  signal-to-noise goal of 10 will always yield good calibration solutions. Divide this conservative flux density by 10 (5–10 for bandpass) for  each of the calibrators to estimate the RMS noise to aim for in the  calibration scan. Then bring up the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/propvla/determining">VLA Exposure Calculator</a> and enter in the following items:</p><ul><li><p>Baseband observing frequency center</p></li><li><p>Relevant bandwidth:</p></li><li><ul><li>narrowest subband for gain,</li><li>narrowest single channel for bandpass,</li><li>total baseband width for flux density</li></ul></li><li><p>Number of antennas: <strong>2 (two!)†</strong></p></li><li><p>Number of Polarizations: <strong>Single!</strong></p></li><li><p>Type of Weighting: Robust</p></li><li><p>Elevation and Average Weather as relevant to the scheduling block details</p></li><li><p>Calculation type: Time</p></li><li><p>And for each calibrator RMS Noise: the conservative flux density divided by 10 or down to 5 as derived above</p></li></ul><p>The exposure calculator will reveal the conservative minimum length  of on-source time to spend on a source needed to obtain good  calibration. This time does not account for data loss due to flagging of unusable data, so it is wise to add another 10 seconds or so to make up for this loss. Also realize that scans shorter than about 20 seconds  are not very effective after long slews as it takes upwards of 10  seconds for the antennas to settle down from the motion. For complex  gain calibration the scan has to last for at least 20 seconds after any  necessary slew and while flux density or bandpass calibrator scans  should be at least 40 seconds long, also after any necessary slew.</p><p>Do not skimp on calibration scans since they are important for  adequate calibration. Note that trading in some time on the target to  benefit calibration only results in a small increase in RMS noise in the final image (see the calibration cycle example below).</p><p>**<em>*†*<em>Note:</em></em> The use of 2 antennas in  the exposure calculator should not be interpreted as determining  baseline-based calibration solutions. Standard calibration tasks (e.g.,  CALIB and BPASS in AIPS, <em>gaincal</em> and <em>bandpass</em> in CASA) provide antenna based solutions, and the signal-to-noise of the  solutions will improve with the square root of the number of antennas in the array. However, flux densities of calibrators can vary  significantly over time (sometimes by large amounts). Also, some  calibrators may have structure, or may be resolved, requiring uv-range  limits during calibration, which in turn will impose constraints on the  available antennas to contribute to the calibration solutions.  Therefore, in the above calculation, the most conservative approach is  demonstrated in order to secure a successful calibration for your  observations.</p><h3 id="Calibration-Cycles"><a href="#Calibration-Cycles" class="headerlink" title="Calibration Cycles"></a>Calibration Cycles</h3><p>If the target source is not bright, or has a lot of structure in the  field, self-calibration usually cannot be used. In these common cases,  one typically observes each target source that is bracketed between two  complex gain calibrator scans in order to interpolate the calibration  over the target observations. Most of the time the scan length needed to achieve the required sensitivity on the target is much longer than the  useful interval between the two calibration scans. The sampling needed  to capture the temporal changes due to the atmosphere (etc.) is shorter  than the total observing time on the target. The target scan is  therefore interspersed with calibrator scans and the observing pattern  cycles through the sequence  calibrator—target(s)—calibrator—target(s)—calibrator,etc. This is most  easily achieved by using a repetitive loop containing target scan(s)  bracketed by complex gain calibrator scans (i.e., phase-referencing).</p><p>The sequence of calibrator scan—slew to target(s)—target(s) scan(s)—slew to calibrator is known as <em>cycle time</em> and should be less than the <em>coherence time</em> for the observations. The coherence time depends on observing  frequency, array configuration, angular separation between calibrator  and target and scheduling constraints (minimum elevation/LST start  range, maximum wind speed, and maximum Atmospheric Phase Interferometer  noise). Cycle time should not be confused with bracketing, which is  where the target(s) scan(s) are encapsulated by calibrator scans.  Bracketing of the target source(s) is required for high frequency  observations, and very strongly recommended for low frequency  observations.</p><p>The maximum cycle time should not exceed the coherence time of the  observations. The minimum cycle time is the sum of slew time between  calibrator and target and back (two slews) plus the minimum calibrator  scan length plus <em>epsilon</em> (any duration that this minimum cycle time is shorter than the coherence time). <em>Epsilon</em> in the previous sentence can be used to accumulate observing time on the target.</p><p>Using the default weather constraints for the highest frequency band  in the scheduling block, typical recommended cycle times in minutes are  given in table 3.1 (below). Note that individual scans can be up to 30  minutes, however, it is recommended to split up long scans into 10-15  minutes; e.g., for a cycle time of 30 minutes, use three consecutive 9  minute scans on the target field between the calibrator scans and use  the other 3 minutes for slew, calibrator scan, and slew back. More  information can be found in the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/hifreq">High Frequency Strategy</a> section as for high frequencies, the cycle time is most important to  improve the coherence time because self-calibration on the field in  general is not possible.</p><table><thead><tr><th align="center">**Table 3.1: Cycle times in minutes by configuration and frequency band **</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">VLA Array Configuration</td><td align="center">&lt; 1 GHz</td><td align="center">1–12 GHz</td><td align="center">Ku  (12–18 GHz)</td><td align="center">K  (18–26.5 GHz)</td><td align="center">Ka  (26.5–40 GHz)</td><td align="center">Q  (40–50 GHz)</td></tr><tr><td align="center">A</td><td align="center">30–60</td><td align="center">10–15</td><td align="center">5</td><td align="center">3</td><td align="center">2.2</td><td align="center">1.5</td></tr><tr><td align="center">B</td><td align="center">30–60</td><td align="center">20–25</td><td align="center">7</td><td align="center">4</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">C</td><td align="center">30–60</td><td align="center">30–40</td><td align="center">15</td><td align="center">10</td><td align="center">7</td><td align="center">5</td></tr><tr><td align="center">D</td><td align="center">30–60</td><td align="center">50–60</td><td align="center">20</td><td align="center">12</td><td align="center">9</td><td align="center">6</td></tr></tbody></table><p>If the time needed to ensure a good calibration (calibrator scan  length plus two slews) is a considerable fraction (over ~40%) of the  cycle time, the overhead becomes prohibitively expensive. Either look  for a closer bright source (shorter slew), or tighten the weather  constraints (longer coherence time) in the scheduling block information  tab.</p><p><strong>Calibration Cycle Example</strong></p><p>Data that cannot be calibrated is a waste of the entire observation.  Therefore, care must be taken to make sure that the data can be  calibrated. Also, the easier the calibration solutions can be  determined, the easier the data reduction becomes. As an eye-opener to  those who want to squeeze out the maximum on-source time on a target,  and cut the calibrator scan time or lengthen the cycle time, consider  the following example: observe a single target in a 2-hour loop, 512 MHz total bandwidth centered at 5 GHz, a 200 mJy/beam calibrator, and  without further flagging (which is unrealistic).</p><ul><li><p>calibrator scan length 40sec, cycle time of 24min (target 22min per cycle) uses 5 cycles, 110 minutes on-source</p></li><li><ul><li><strong>12.3</strong> for the expected calibrator signal-to-noise ratio in a calibration scan</li><li><strong>6.5</strong> uJy/bm expected RMS image noise on the target</li></ul></li><li><p>calibrator scan length 100sec, cycle time of 15min (target 12min per cycle) uses 8 cycles, 96min on-source</p></li><li><ul><li><strong>21.3</strong> for the expected calibrator signal-to-noise ratio in a calibration scan</li><li><strong>6.8</strong> uJy/bm expected RMS image noise on the target</li></ul></li></ul><p>In the second case, the RMS image noise is only about 5% more than in the first case; but it is more likely that after flagging of band edges and otherwise bad data—or less careful but much quicker or automated  flagging of the calibrator data—that the second yields better  calibration solutions. Data can still be calibrated in the second case  if a fraction of the data needs to be flagged for whatever reason (as  this additional flagging will not drive the signal-to-noise below 10),  or still yield better interpolations under deteriorating weather  conditions as the cycle time is shorter.</p><h2 id="Further-Information"><a href="#Further-Information" class="headerlink" title="Further Information"></a>Further Information</h2><ul><li><p>More information about the VLA in general can be found in the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/oss">VLA Observational Status Summary</a>.</p></li><li><p>Guidelines at the proposal stage about calibration should be obtained from the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/propvla">Guide to Proposing</a> and the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/proposal-guide">PST Manual</a>.</p></li><li><p>For information on how to use the Observation Preparation Tool, refer to the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/opt">OPT Manual</a>.</p></li><li><p>Refer to the data reduction package manuals, <a href="http://www.aips.nrao.edu/index.shtml">AIPS</a> and <a href="https://casa.nrao.edu/">CASA</a>, for how to calibrate the data.</p></li><li><p>For polarization calibration strategy and techniques, please see the <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/modes/pol">Polarimetry</a> section.</p></li><li><p><a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/hifreq">High Frequency Strategy</a></p></li><li><p><a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/lofreq">Low Frequency Strategy</a></p></li><li><p><a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/topical-guides/vlofreq">Very Low Frequency Strategy</a></p></li></ul><blockquote><p>Content Source: <a href="https://science.nrao.edu/facilities/vla/docs/manuals/obsguide/calibration">NRAO</a> </p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wave Band</title>
      <link href="/2020/01/20/20200120-waveband/"/>
      <url>/2020/01/20/20200120-waveband/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Band"><a href="#Band" class="headerlink" title="Band"></a>Band</h1><table><thead><tr><th align="center">波段名称</th><th align="center">频率范围</th><th align="center">波长范围</th><th align="center">波段名称</th><th align="center">频率范围</th><th align="center">波长范围</th></tr></thead><tbody><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/L%E6%B3%A2%E6%AE%B5">L波段</a></td><td align="center">1 - 2 <a href="https://zh.wikipedia.org/wiki/GHz">GHz</a></td><td align="center">300.00 - 150.00 <a href="https://zh.wikipedia.org/wiki/Mm">mm</a></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/S%E6%B3%A2%E6%AE%B5">S波段</a></td><td align="center">2 - 4 GHz</td><td align="center">150.00 - 75.00 mm</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">C波段</td><td align="center">4 - 8 GHz</td><td align="center">75.00 - 37.50 mm</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/X%E6%B3%A2%E6%AE%B5">X波段</a></td><td align="center">8 - 12 GHz</td><td align="center">37.50 - 25.00 mm</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/Ku%E6%B3%A2%E6%AE%B5">Ku波段</a></td><td align="center">12 - 18 GHz</td><td align="center">25.00 - 16.67 mm</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=K%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">K波段</a></td><td align="center">18 - 27 GHz</td><td align="center">16.67 - 11.11 mm</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=Ka%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">Ka波段</a></td><td align="center">27 - 40 GHz</td><td align="center">11.11 - 7.50 mm</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=Q%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">Q波段</a></td><td align="center">30 - 50 GHz</td><td align="center">10.00 - 6.00 mm</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=U%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">U波段</a></td><td align="center">40 - 60 GHz</td><td align="center">7.50 - 5.00 mm</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=V%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">V波段</a></td><td align="center">50 - 75 GHz</td><td align="center">6.00 - 4.00 mm</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=E%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">E波段</a></td><td align="center">60 - 90 GHz</td><td align="center">5.00 - 3.33 mm</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=W%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">W波段</a></td><td align="center">75 - 110 GHz</td><td align="center">4.00 - 2.73 mm</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=F%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">F波段</a></td><td align="center">90 - 140 GHz</td><td align="center">3.33 - 2.14 mm</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=D%E6%B3%A2%E6%AE%B5&amp;action=edit&amp;redlink=1">D波段</a></td><td align="center">110 - 170 GHz</td><td align="center">2.73 - 1.76 mm</td></tr></tbody></table><table><thead><tr><th align="center"><strong>波段代号</strong></th><th align="center"><strong>频率范围/GHz</strong></th></tr></thead><tbody><tr><td align="center">UHF</td><td align="center">0.30 - 1.12</td></tr><tr><td align="center">L</td><td align="center">1.12 - 1.70</td></tr><tr><td align="center">LS</td><td align="center">1.70 - 2.60</td></tr><tr><td align="center">S</td><td align="center">2.60 - 3.95</td></tr><tr><td align="center">C</td><td align="center">3.95 - 5.85</td></tr><tr><td align="center">XC</td><td align="center">5.85 - 8.20</td></tr><tr><td align="center">X</td><td align="center">8.20 - 12.40</td></tr><tr><td align="center">Ku</td><td align="center">12.40 - 18.00</td></tr><tr><td align="center">K</td><td align="center">18.00 - 26.50</td></tr><tr><td align="center">Ka</td><td align="center">26.50 - 40.00</td></tr><tr><td align="center">Q</td><td align="center">33.00 - 50.00</td></tr><tr><td align="center">U</td><td align="center">40.00 - 60.00</td></tr><tr><td align="center">M</td><td align="center">50.00 - 75.00</td></tr><tr><td align="center">E</td><td align="center">60.00 - 90.00</td></tr><tr><td align="center">F</td><td align="center">90.00 - 140.00</td></tr><tr><td align="center">G</td><td align="center">140.00 - 220.00</td></tr><tr><td align="center">R</td><td align="center">220.00 - 325.00</td></tr></tbody></table><h2 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h2><p><img src="/images/20200120-waveband.assets/Atmospheric_electromagnetic_opacity.svg.png" alt="地球大气对于不同波长电磁辐射的透过率。"></p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"><strong>电磁波谱</strong></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">名字</td><td align="center">波长</td><td align="center">频率 (Hz)</td><td align="center">光子 能量 (eV)</td><td align="center">带宽范围 (Bel)</td></tr><tr><td align="center">伽马射线</td><td align="center">小于 0.01 nm</td><td align="center">多于 15 EHz</td><td align="center">多于 62.1 keV</td><td align="center">无穷</td></tr><tr><td align="center">X射线</td><td align="center">0.01 nm – 10 nm</td><td align="center">30 EHz – 30 PHz</td><td align="center">124 keV – 124 eV</td><td align="center">3</td></tr><tr><td align="center">紫外线</td><td align="center">10 nm – 400 nm</td><td align="center">30 PHz – 750 THz</td><td align="center">124 eV –3 eV</td><td align="center">1.6</td></tr><tr><td align="center">可见光</td><td align="center">390 nm – 750 nm</td><td align="center">770 THz – 400 THz</td><td align="center">3.2 eV – 1.7 eV</td><td align="center">0.3</td></tr><tr><td align="center">红外线</td><td align="center">750 nm – 1 mm</td><td align="center">400 THz – 300 GHz</td><td align="center">1.7 eV – 1.24 meV</td><td align="center">3.1</td></tr><tr><td align="center"><strong>微波</strong></td><td align="center">1 mm – 1 m</td><td align="center">300 GHz – 300 MHz</td><td align="center">1.24 meV – 1.24 $\mu$eV</td><td align="center">3</td></tr><tr><td align="center">无线电短波</td><td align="center">1 m –100 m</td><td align="center">300 MHz – 3 MHz</td><td align="center">1.24 $\mu$ eV – 12.4 feV</td><td align="center">8</td></tr><tr><td align="center">无线电中波</td><td align="center">100 - 1000 m</td><td align="center">3 MHz - 0.3 MHz</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">无线电长波</td><td align="center">1 km- 100,000 km</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>伽马射线 - X射线 - 紫外线 - 可见光 - 红外线 - 太赫兹辐射 -  微波 - 无线电波<br><img src="/images/20200120-waveband.assets/1920px-Frequency_vs._wave_length.svg.png" alt="电磁波谱"></p><p>← 波长越短       波长越长 →<br>← 频率越高       频率越低 → </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash Program</title>
      <link href="/2020/01/11/20200111-bash-program/"/>
      <url>/2020/01/11/20200111-bash-program/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是-shell"><a href="#1-1-什么是-shell" class="headerlink" title="1.1. 什么是 shell"></a>1.1. 什么是 shell</h3><ul><li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li><li>Shell 既是一种命令语言，又是一种程序设计语言。</li><li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li></ul><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="1-2-什么是-shell-脚本"><a href="#1-2-什么是-shell-脚本" class="headerlink" title="1.2. 什么是 shell 脚本"></a>1.2. 什么是 shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p><p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p><h3 id="1-3-Shell-环境"><a href="#1-3-Shell-环境" class="headerlink" title="1.3. Shell 环境"></a>1.3. Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Shell 的解释器种类众多，常见的有：</p><ul><li><a href="https://www.gnu.org/software/bash/">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li><li><a href="https://www.gnu.org/software/bash/">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li><li><a href="https://fishshell.com/">fish</a> - 智能和用户友好的命令行 shell。</li><li><a href="http://xiki.org/">xiki</a> - 使 shell 控制台更友好，更强大。</li><li><a href="http://www.zsh.org/">zsh</a> - 功能强大的 shell 与脚本语言。</li></ul><h4 id="指定脚本解释器"><a href="#指定脚本解释器" class="headerlink" title="指定脚本解释器"></a>指定脚本解释器</h4><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p><p>所以，你应该会在 shell 中，见到诸如以下的注释：</p><ul><li>指定 sh 解释器</li></ul><pre><code>#!/bin/sh</code></pre><ul><li>指定 bash 解释器</li></ul><pre><code>#!/bin/bash</code></pre><blockquote><p><strong>注意</strong></p><p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p><pre><code>#!/usr/bin/env bash</code></pre><p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p></blockquote><h3 id="1-4-模式"><a href="#1-4-模式" class="headerlink" title="1.4. 模式"></a>1.4. 模式</h3><p>shell 有交互和非交互两种模式。</p><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><blockquote><p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p></blockquote><p>看到形如下面的东西，说明 shell 处于交互模式下：</p><pre><code>user@host:~$</code></pre><p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p><h4 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h4><blockquote><p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p></blockquote><p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p><p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p><p>可以使用下面的命令让 shell 以非交互模式运行：</p><pre><code>sh /path/to/script.shbash /path/to/script.shsource /path/to/script.sh./path/to/script.sh</code></pre><p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p><p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p><p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p><pre><code>chmod +x /path/to/script.sh #使脚本具有执行权限/path/to/test.sh</code></pre><p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/helloworld.sh">helloworld.sh</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/usr/bin/env bash</span><span class="token keyword">echo</span> <span class="token string">"Hello, world!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="2-1-解释器"><a href="#2-1-解释器" class="headerlink" title="2.1. 解释器"></a>2.1. 解释器</h3><p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p><p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p><pre><code># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好#!/bin/bash#!/usr/bin/env bash</code></pre><h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2. 注释"></a>2.2. 注释</h3><p>注释可以说明你的代码是什么作用，以及为什么这样写。</p><p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p><ul><li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li><li>多行注释 - 以 <code>:&lt; 开头，到 </code>EOF` 结束。</li></ul><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/comment-demo.sh">comment-demo.sh</a></p><pre><code>#--------------------------------------------# shell 注释示例# author：zp#--------------------------------------------# echo '这是单行注释'########## 这是分割线 ##########:&lt;&lt;EOFecho '这是多行注释'echo '这是多行注释'echo '这是多行注释'EOF</code></pre><h3 id="2-3-echo"><a href="#2-3-echo" class="headerlink" title="2.3. echo"></a>2.3. echo</h3><p>echo 用于字符串的输出。</p><p>输出普通字符串：</p><pre><code>echo "hello, world"# Output: hello, world</code></pre><p>输出含变量的字符串：</p><pre><code>echo "hello, \"zp\""# Output: hello, "zp"</code></pre><p>输出含变量的字符串：</p><pre><code>name=zpecho "hello, \"${name}\""# Output: hello, "zp"</code></pre><p>输出含换行符的字符串：</p><pre><code># 输出含换行符的字符串echo "YES\nNO"#  Output: YES\nNOecho -e "YES\nNO" # -e 开启转义#  Output:#  YES#  NO</code></pre><p>输出含不换行符的字符串：</p><pre><code>echo "YES"echo "NO"#  Output:#  YES#  NOecho -e "YES\c" # -e 开启转义 \c 不换行echo "NO"#  Output:#  YESNO</code></pre><p>输出重定向至文件</p><pre><code>echo "test" &gt; test.txt</code></pre><p>输出执行结果</p><pre><code>echo `pwd`#  Output:(当前目录路径)</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/echo-demo.sh">echo-demo.sh</a></p><h3 id="2-4-printf"><a href="#2-4-printf" class="headerlink" title="2.4. printf"></a>2.4. printf</h3><p>printf 用于格式化输出字符串。</p><p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/printf-demo.sh">printf-demo.sh</a></p><pre><code># 单引号printf '%d %s\n' 1 "abc"#  Output:1 abc# 双引号printf "%d %s\n" 1 "abc"#  Output:1 abc# 无引号printf %s abcdef#  Output: abcdef(并不会换行)# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出printf "%s\n" abc def#  Output:#  abc#  defprintf "%s %s %s\n" a b c d e f g h i j#  Output:#  a b c#  d e f#  g h i#  j# 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替printf "%s and %d \n"#  Output:#   and 0# 格式化输出printf "%-10s %-8s %-4s\n" 姓名 性别 体重kgprintf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876#  Output:#  姓名     性别   体重kg#  郭靖     男      66.12#  杨过     男      48.65#  郭芙     女      47.99</code></pre><h4 id="printf-的转义符"><a href="#printf-的转义符" class="headerlink" title="printf 的转义符"></a>printf 的转义符</h4><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td><code>\b</code></td><td>后退</td></tr><tr><td><code>\c</code></td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><code>\f</code></td><td>换页（formfeed）</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车（Carriage return）</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>一个字面上的反斜杠字符</td></tr><tr><td><code>\ddd</code></td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><code>\0ddd</code></td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p><p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p><h3 id="3-1-变量命名原则"><a href="#3-1-变量命名原则" class="headerlink" title="3.1. 变量命名原则"></a>3.1. 变量命名原则</h3><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>等号两侧不能有空格</li><li>不能使用标点符号。</li><li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li></ul><h3 id="3-2-声明变量"><a href="#3-2-声明变量" class="headerlink" title="3.2. 声明变量"></a>3.2. 声明变量</h3><p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p><pre><code>word="hello"echo ${word}# Output: hello</code></pre><h3 id="3-3-只读变量"><a href="#3-3-只读变量" class="headerlink" title="3.3. 只读变量"></a>3.3. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><pre><code>rword="hello"echo ${rword}readonly rword# rword="bye"  # 如果放开注释，执行时会报错</code></pre><h3 id="3-4-删除变量"><a href="#3-4-删除变量" class="headerlink" title="3.4. 删除变量"></a>3.4. 删除变量</h3><p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><pre><code>dword="hello"  # 声明变量echo ${dword}  # 输出变量值# Output: hellounset dword    # 删除变量echo ${dword}# Output: （空）</code></pre><h3 id="3-5-变量类型"><a href="#3-5-变量类型" class="headerlink" title="3.5. 变量类型"></a>3.5. 变量类型</h3><ul><li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li><li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li></ul><p>常见的环境变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$HOME</code></td><td>当前用户的用户目录</td></tr><tr><td><code>$PATH</code></td><td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td></tr><tr><td><code>$PWD</code></td><td>当前工作目录</td></tr><tr><td><code>$RANDOM</code></td><td>0 到 32767 之间的整数</td></tr><tr><td><code>$UID</code></td><td>数值类型，当前用户的用户 ID</td></tr><tr><td><code>$PS1</code></td><td>主要系统输入提示符</td></tr><tr><td><code>$PS2</code></td><td>次要系统输入提示符</td></tr></tbody></table><p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04">这里</a> 有一张更全面的 Bash 环境变量列表。</p><h3 id="3-6-变量示例源码"><a href="#3-6-变量示例源码" class="headerlink" title="3.6. 变量示例源码"></a>3.6. 变量示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/variable-demo.sh">variable-demo.sh</a></p><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h3 id="4-1-单引号和双引号"><a href="#4-1-单引号和双引号" class="headerlink" title="4.1. 单引号和双引号"></a>4.1. 单引号和双引号</h3><p>shell 字符串可以用单引号 <code>''</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p><ul><li>单引号的特点<ul><li>单引号里不识别变量</li><li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li>双引号的特点<ul><li>双引号里识别变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><p>综上，推荐使用双引号。</p><h3 id="4-2-拼接字符串"><a href="#4-2-拼接字符串" class="headerlink" title="4.2. 拼接字符串"></a>4.2. 拼接字符串</h3><pre><code># 使用单引号拼接name1='white'str1='hello, '${name1}''str2='hello, ${name1}'echo ${str1}_${str2}# Output:# hello, white_hello, ${name1}# 使用双引号拼接name2="black"str3="hello, "${name2}""str4="hello, ${name2}"echo ${str3}_${str4}# Output:# hello, black_hello, black</code></pre><h3 id="4-3-获取字符串长度"><a href="#4-3-获取字符串长度" class="headerlink" title="4.3. 获取字符串长度"></a>4.3. 获取字符串长度</h3><pre><code>text="12345"echo ${#text}# Output:# 5</code></pre><h3 id="4-4-截取子字符串"><a href="#4-4-截取子字符串" class="headerlink" title="4.4. 截取子字符串"></a>4.4. 截取子字符串</h3><pre><code>text="12345"echo ${text:2:2}# Output:# 34</code></pre><p>从第 3 个字符开始，截取 2 个字符</p><h3 id="4-5-查找子字符串"><a href="#4-5-查找子字符串" class="headerlink" title="4.5. 查找子字符串"></a>4.5. 查找子字符串</h3><pre><code>#!/usr/bin/env bashtext="hello"echo `expr index "${text}" ll`# Execute: ./str-demo5.sh# Output:# 3</code></pre><p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p><h3 id="4-6-字符串示例源码"><a href="#4-6-字符串示例源码" class="headerlink" title="4.6. 字符串示例源码"></a>4.6. 字符串示例源码</h3><p><strong>⌨️ 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/string-demo.sh">string-demo.sh</a></p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><p>bash 只支持一维数组。</p><p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1. 创建数组"></a>5.1. 创建数组</h3><pre><code># 创建数组的不同方式nums=([2]=2 [0]=0 [1]=1)colors=(red yellow "dark blue")</code></pre><h3 id="5-2-访问数组元素"><a href="#5-2-访问数组元素" class="headerlink" title="5.2. 访问数组元素"></a>5.2. 访问数组元素</h3><ul><li><strong>访问数组的单个元素：</strong></li></ul><pre><code>echo ${nums[1]}# Output: 1</code></pre><ul><li><strong>访问数组的所有元素：</strong></li></ul><pre><code>echo ${colors[*]}# Output: red yellow dark blueecho ${colors[@]}# Output: red yellow dark blue</code></pre><p>上面两行有很重要（也很微妙）的区别：</p><p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p><pre><code>printf "+ %s\n" ${colors[*]}# Output:# + red# + yellow# + dark# + blue</code></pre><p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p><pre><code>printf "+ %s\n" "${colors[*]}"# Output:# + red yellow dark blue</code></pre><p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>${colors[@]}</code></p><pre><code>printf "+ %s\n" "${colors[@]}"# Output:# + red# + yellow# + dark blue</code></pre><p>在引号内，<code>${colors[@]}</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p><ul><li><strong>访问数组的部分元素：</strong></li></ul><pre><code>echo ${nums[@]:0:2}# Output:# 0 1</code></pre><p>在上面的例子中，<code>${array[@]}</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p><h3 id="5-3-访问数组长度"><a href="#5-3-访问数组长度" class="headerlink" title="5.3. 访问数组长度"></a>5.3. 访问数组长度</h3><pre><code>echo ${#nums[*]}# Output:# 3</code></pre><h3 id="5-4-向数组中添加元素"><a href="#5-4-向数组中添加元素" class="headerlink" title="5.4. 向数组中添加元素"></a>5.4. 向数组中添加元素</h3><p>向数组中添加元素也非常简单：</p><pre><code>colors=(white "${colors[@]}" green black)echo ${colors[@]}# Output:# white red yellow dark blue green black</code></pre><p>上面的例子中，<code>${colors[@]}</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p><h3 id="5-5-从数组中删除元素"><a href="#5-5-从数组中删除元素" class="headerlink" title="5.5. 从数组中删除元素"></a>5.5. 从数组中删除元素</h3><p>用<code>unset</code>命令来从数组中删除一个元素：</p><pre><code>unset nums[0]echo ${nums[@]}# Output:# 1 2</code></pre><h3 id="5-6-数组示例源码"><a href="#5-6-数组示例源码" class="headerlink" title="5.6. 数组示例源码"></a>5.6. 数组示例源码</h3><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos/array-demo.sh">array-demo.sh</a></p><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1. 算术运算符"></a>6.1. 算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $x + $y</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $x - $y</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $x * $y</code> 结果为 200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $y / $x</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $y % $x</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td><code>x=$y</code> 将把变量 y 的值赋给 x。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $x == $y ]</code> 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $x != $y ]</code> 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo.sh">operator-demo.sh</a></p><pre><code>x=10y=20echo "x=${x}, y=${y}"val=`expr ${x} + ${y}`echo "${x} + ${y} = $val"val=`expr ${x} - ${y}`echo "${x} - ${y} = $val"val=`expr ${x} \* ${y}`echo "${x} * ${y} = $val"val=`expr ${y} / ${x}`echo "${y} / ${x} = $val"val=`expr ${y} % ${x}`echo "${y} % ${x} = $val"if [[ ${x} == ${y} ]]then  echo "${x} = ${y}"fiif [[ ${x} != ${y} ]]then  echo "${x} != ${y}"fi#  Execute: ./operator-demo.sh#  Output:#  x=10, y=20#  10 + 20 = 30#  10 - 20 = -10#  10 * 20 = 200#  20 / 10 = 2#  20 % 10 = 0#  10 != 20</code></pre><h3 id="6-2-关系运算符"><a href="#6-2-关系运算符" class="headerlink" title="6.2. 关系运算符"></a>6.2. 关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 true。</td><td><code>[ $a -eq $b ]</code>返回 false。</td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 true。</td><td><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo2.sh">operator-demo2.sh</a></p><pre><code>x=10y=20echo "x=${x}, y=${y}"if [[ ${x} -eq ${y} ]]; then   echo "${x} -eq ${y} : x 等于 y"else   echo "${x} -eq ${y}: x 不等于 y"fiif [[ ${x} -ne ${y} ]]; then   echo "${x} -ne ${y}: x 不等于 y"else   echo "${x} -ne ${y}: x 等于 y"fiif [[ ${x} -gt ${y} ]]; then   echo "${x} -gt ${y}: x 大于 y"else   echo "${x} -gt ${y}: x 不大于 y"fiif [[ ${x} -lt ${y} ]]; then   echo "${x} -lt ${y}: x 小于 y"else   echo "${x} -lt ${y}: x 不小于 y"fiif [[ ${x} -ge ${y} ]]; then   echo "${x} -ge ${y}: x 大于或等于 y"else   echo "${x} -ge ${y}: x 小于 y"fiif [[ ${x} -le ${y} ]]; then   echo "${x} -le ${y}: x 小于或等于 y"else   echo "${x} -le ${y}: x 大于 y"fi#  Execute: ./operator-demo2.sh#  Output:#  x=10, y=20#  10 -eq 20: x 不等于 y#  10 -ne 20: x 不等于 y#  10 -gt 20: x 不大于 y#  10 -lt 20: x 小于 y#  10 -ge 20: x 小于 y#  10 -le 20: x 小于或等于 y</code></pre><h3 id="6-3-布尔运算符"><a href="#6-3-布尔运算符" class="headerlink" title="6.3. 布尔运算符"></a>6.3. 布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td><code>[ ! false ]</code> 返回 true。</td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 true 则返回 true。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 true 才返回 true。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo3.sh">operator-demo3.sh</a></p><pre><code>x=10y=20echo "x=${x}, y=${y}"if [[ ${x} != ${y} ]]; then   echo "${x} != ${y} : x 不等于 y"else   echo "${x} != ${y}: x 等于 y"fiif [[ ${x} -lt 100 &amp;&amp; ${y} -gt 15 ]]; then   echo "${x} 小于 100 且 ${y} 大于 15 : 返回 true"else   echo "${x} 小于 100 且 ${y} 大于 15 : 返回 false"fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]; then   echo "${x} 小于 100 或 ${y} 大于 100 : 返回 true"else   echo "${x} 小于 100 或 ${y} 大于 100 : 返回 false"fiif [[ ${x} -lt 5 || ${y} -gt 100 ]]; then   echo "${x} 小于 5 或 ${y} 大于 100 : 返回 true"else   echo "${x} 小于 5 或 ${y} 大于 100 : 返回 false"fi#  Execute: ./operator-demo3.sh#  Output:#  x=10, y=20#  10 != 20 : x 不等于 y#  10 小于 100 且 20 大于 15 : 返回 true#  10 小于 100 或 20 大于 100 : 返回 true#  10 小于 5 或 20 大于 100 : 返回 false</code></pre><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4. 逻辑运算符"></a>6.4. 逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 AND</td><td><code>[[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]</code> 返回 false</td></tr><tr><td>`</td><td></td><td>`</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo4.sh">operator-demo4.sh</a></p><pre><code>x=10y=20echo "x=${x}, y=${y}"if [[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]then   echo "${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 true"else   echo "${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 false"fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]then   echo "${x} -lt 100 || ${y} -gt 100 返回 true"else   echo "${x} -lt 100 || ${y} -gt 100 返回 false"fi#  Execute: ./operator-demo4.sh#  Output:#  x=10, y=20#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false#  10 -lt 100 || 20 -gt 100 返回 true</code></pre><h3 id="6-5-字符串运算符"><a href="#6-5-字符串运算符" class="headerlink" title="6.5. 字符串运算符"></a>6.5. 字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 true。</td><td><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 true。</td><td><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为 0，为 0 返回 true。</td><td><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为 0，不为 0 返回 true。</td><td><code>[ -n $a ]</code> 返回 true。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 true。</td><td><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo5.sh">operator-demo5.sh</a></p><pre><code>x="abc"y="xyz"echo "x=${x}, y=${y}"if [[ ${x} = ${y} ]]; then   echo "${x} = ${y} : x 等于 y"else   echo "${x} = ${y}: x 不等于 y"fiif [[ ${x} != ${y} ]]; then   echo "${x} != ${y} : x 不等于 y"else   echo "${x} != ${y}: x 等于 y"fiif [[ -z ${x} ]]; then   echo "-z ${x} : 字符串长度为 0"else   echo "-z ${x} : 字符串长度不为 0"fiif [[ -n "${x}" ]]; then   echo "-n ${x} : 字符串长度不为 0"else   echo "-n ${x} : 字符串长度为 0"fiif [[ ${x} ]]; then   echo "${x} : 字符串不为空"else   echo "${x} : 字符串为空"fi#  Execute: ./operator-demo5.sh#  Output:#  x=abc, y=xyz#  abc = xyz: x 不等于 y#  abc != xyz : x 不等于 y#  -z abc : 字符串长度不为 0#  -n abc : 字符串长度不为 0#  abc : 字符串不为空</code></pre><h3 id="6-6-文件测试运算符"><a href="#6-6-文件测试运算符" class="headerlink" title="6.6. 文件测试运算符"></a>6.6. 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td><code>[ -k $file ]</code>返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td><td><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/operator/operator-demo6.sh">operator-demo6.sh</a></p><pre><code>file="/etc/hosts"if [[ -r ${file} ]]; then   echo "${file} 文件可读"else   echo "${file} 文件不可读"fiif [[ -w ${file} ]]; then   echo "${file} 文件可写"else   echo "${file} 文件不可写"fiif [[ -x ${file} ]]; then   echo "${file} 文件可执行"else   echo "${file} 文件不可执行"fiif [[ -f ${file} ]]; then   echo "${file} 文件为普通文件"else   echo "${file} 文件为特殊文件"fiif [[ -d ${file} ]]; then   echo "${file} 文件是个目录"else   echo "${file} 文件不是个目录"fiif [[ -s ${file} ]]; then   echo "${file} 文件不为空"else   echo "${file} 文件为空"fiif [[ -e ${file} ]]; then   echo "${file} 文件存在"else   echo "${file} 文件不存在"fi#  Execute: ./operator-demo6.sh#  Output:(根据文件的实际情况，输出结果可能不同)#  /etc/hosts 文件可读#  /etc/hosts 文件可写#  /etc/hosts 文件不可执行#  /etc/hosts 文件为普通文件#  /etc/hosts 文件不是个目录#  /etc/hosts 文件不为空#  /etc/hosts 文件存在</code></pre><h2 id="7-控制语句"><a href="#7-控制语句" class="headerlink" title="7. 控制语句"></a>7. 控制语句</h2><h3 id="7-1-条件语句"><a href="#7-1-条件语句" class="headerlink" title="7.1. 条件语句"></a>7.1. 条件语句</h3><p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p><p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050">bash 中单双中括号区别</a>的答案。</p><p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>（1）<code>if</code> 语句</p><p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p><pre><code># 写成一行if [[ 1 -eq 1 ]]; then echo "1 -eq 1 result is: true"; fi# Output: 1 -eq 1 result is: true# 写成多行if [[ "abc" -eq "abc" ]]then  echo ""abc" -eq "abc" result is: true"fi# Output: abc -eq abc result is: true</code></pre><p>（2）<code>if else</code> 语句</p><p>同样，我们可以使用<code>if..else</code>语句，例如：</p><pre><code>if [[ 2 -ne 1 ]]; then  echo "true"else  echo "false"fi# Output: true</code></pre><p>（3）<code>if elif else</code> 语句</p><p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p><pre><code>x=10y=20if [[ ${x} &gt; ${y} ]]; then   echo "${x} &gt; ${y}"elif [[ ${x} &lt; ${y} ]]; then   echo "${x} &lt; ${y}"else   echo "${x} = ${y}"fi# Output: 10 &lt; 20</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/if-demo.sh">if-demo.sh</a></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/case-demo.sh">case-demo.sh</a></p><pre><code>execcase ${oper} in  "+")    val=`expr ${x} + ${y}`    echo "${x} + ${y} = ${val}"  ;;  "-")    val=`expr ${x} - ${y}`    echo "${x} - ${y} = ${val}"  ;;  "*")    val=`expr ${x} \* ${y}`    echo "${x} * ${y} = ${val}"  ;;  "/")    val=`expr ${x} / ${y}`    echo "${x} / ${y} = ${val}"  ;;  *)    echo "Unknown oper!"  ;;esac</code></pre><p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p><h3 id="7-2-循环语句"><a href="#7-2-循环语句" class="headerlink" title="7.2. 循环语句"></a>7.2. 循环语句</h3><p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p><p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p><pre><code>for arg in elem1 elem2 ... elemNdo  ### 语句done</code></pre><p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95">大括号扩展</a>。</p><p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p><pre><code>for i in {1..5}; do echo $i; done</code></pre><p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p><pre><code>for (( i = 0; i &lt; 10; i++ )); do  echo $idone</code></pre><p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p><pre><code>DIR=/home/zpfor FILE in ${DIR}/*.sh; do  mv "$FILE" "${DIR}/scripts"done# 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/for-demo.sh">for-demo.sh</a></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p><pre><code>while [[ condition ]]do  ### 语句done</code></pre><p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p><p>比如下面这个例子：</p><pre><code>### 0到9之间每个数的平方x=0while [[ ${x} -lt 10 ]]; do  echo $((x * x))  x=$((x + 1))done#  Output:#  0#  1#  4#  9#  16#  25#  36#  49#  64#  81</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/while-demo.sh">while-demo.sh</a></p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p><pre><code>x=0until [[ ${x} -ge 5 ]]; do  echo ${x}  x=`expr ${x} + 1`done#  Output:#  0#  1#  2#  3#  4</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/until-demo.sh">until-demo.sh</a></p><h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a><code>select</code>循环</h4><p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p><pre><code>select answer in elem1 elem2 ... elemNdo  ### 语句done</code></pre><p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p><p>一个可能的实例可能会是这样：</p><pre><code>#!/usr/bin/env bashPS3="Choose the package manager: "select ITEM in bower npm gem pipdoecho -n "Enter the package name: " &amp;&amp; read PACKAGEcase ${ITEM} in  bower) bower install ${PACKAGE} ;;  npm) npm install ${PACKAGE} ;;  gem) gem install ${PACKAGE} ;;  pip) pip install ${PACKAGE} ;;esacbreak # 避免无限循环done</code></pre><p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p><p>运行这个脚本，会得到如下输出：</p><pre><code>$ ./my_script1) bower2) npm3) gem4) pipChoose the package manager: 2Enter the package name: gitbook-cli</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/select-demo.sh">select-demo.sh</a></p><h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h4><p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p><blockquote><p><code>break</code>语句用来提前结束当前循环。</p><p><code>continue</code>语句用来跳过某次迭代。</p></blockquote><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/break-demo.sh">break-demo.sh</a></p><pre><code># 查找 10 以内第一个能整除 2 和 3 的正整数i=1while [[ ${i} -lt 10 ]]; do  if [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; then    echo ${i}    break;  fi  i=`expr ${i} + 1`done# Output: 6</code></pre><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/statement/continue-demo.sh">continue-demo.sh</a></p><pre><code># 打印10以内的奇数for (( i = 0; i &lt; 10; i ++ )); do  if [[ $((i % 2)) -eq 0 ]]; then    continue;  fi  echo ${i}done#  Output:#  1#  3#  5#  7#  9</code></pre><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>bash 函数定义语法如下：</p><pre><code>[ function ] funname [()] {    action;    [return int;]}</code></pre><blockquote><p>💡 说明：</p><ol><li>函数定义时，<code>function</code> 关键字可有可无。</li><li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li><li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li><li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ol></blockquote><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo.sh">function-demo.sh</a></p><pre><code>#!/usr/bin/env bashcalc(){  PS3="choose the oper: "  select oper in + - \* / # 生成操作符选择菜单  do  echo -n "enter first num: " &amp;&amp; read x # 读取输入参数  echo -n "enter second num: " &amp;&amp; read y # 读取输入参数  exec  case ${oper} in    "+")      return $((${x} + ${y}))    ;;    "-")      return $((${x} - ${y}))    ;;    "*")      return $((${x} * ${y}))    ;;    "/")      return $((${x} / ${y}))    ;;    *)      echo "${oper} is not support!"      return 0    ;;  esac  break  done}calcecho "the result is: $?" # $? 获取 calc 函数返回值</code></pre><p>执行结果：</p><pre><code>$ ./function-demo.sh1) +2) -3) *4) /choose the oper: 3enter first num: 10enter second num: 10the result is: 100</code></pre><h3 id="8-1-位置参数"><a href="#8-1-位置参数" class="headerlink" title="8.1. 位置参数"></a>8.1. 位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p><p>位置参数变量表：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名称</td></tr><tr><td><code>$1 … $9</code></td><td>第 1 个到第 9 个参数列表</td></tr><tr><td><code>${10} … ${N}</code></td><td>第 10 个到 N 个参数列表</td></tr><tr><td><code>$*</code> or <code>$@</code></td><td>除了<code>$0</code>外的所有位置参数</td></tr><tr><td><code>$#</code></td><td>不包括<code>$0</code>在内的位置参数的个数</td></tr><tr><td><code>$FUNCNAME</code></td><td>函数名称（仅在函数内部有值）</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo2.sh">function-demo2.sh</a></p><pre><code>#!/usr/bin/env bashx=0if [[ -n $1 ]]; then  echo "第一个参数为：$1"  x=$1else  echo "第一个参数为空"fiy=0if [[ -n $2 ]]; then  echo "第二个参数为：$2"  y=$2else  echo "第二个参数为空"fiparamsFunction(){  echo "函数第一个入参：$1"  echo "函数第二个入参：$2"}paramsFunction ${x} ${y}</code></pre><p>执行结果：</p><pre><code>$ ./function-demo2.sh第一个参数为空第二个参数为空函数第一个入参：0函数第二个入参：0$ ./function-demo2.sh 10 20第一个参数为：10第二个参数为：20函数第一个入参：10函数第二个入参：20</code></pre><p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p><h3 id="8-2-函数处理参数"><a href="#8-2-函数处理参数" class="headerlink" title="8.2. 函数处理参数"></a>8.2. 函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>返回参数个数</td></tr><tr><td><code>$*</code></td><td>返回所有参数</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程 ID 号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td><code>$@</code></td><td>返回所有参数</td></tr><tr><td><code>$-</code></td><td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td><code>$?</code></td><td>函数返回值</td></tr></tbody></table><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/tree/master/codes/shell/demos//function/function-demo3.sh">function-demo3.sh</a></p><pre><code>runner() {  return 0}name=zpparamsFunction(){  echo "函数第一个入参：$1"  echo "函数第二个入参：$2"  echo "传递到脚本的参数个数：$#"  echo "所有参数："  printf "+ %s\n" "$*"  echo "脚本运行的当前进程 ID 号：$$"  echo "后台运行的最后一个进程的 ID 号：$!"  echo "所有参数："  printf "+ %s\n" "$@"  echo "Shell 使用的当前选项：$-"  runner  echo "runner 函数的返回值：$?"}paramsFunction 1 "abc" "hello, \"zp\""#  Output:#  函数第一个入参：1#  函数第二个入参：abc#  传递到脚本的参数个数：3#  所有参数：#  + 1 abc hello, "zp"#  脚本运行的当前进程 ID 号：26400#  后台运行的最后一个进程的 ID 号：#  所有参数：#  + 1#  + abc#  + hello, "zp"#  Shell 使用的当前选项：hB#  runner 函数的返回值：0</code></pre><h2 id="9-Shell-扩展"><a href="#9-Shell-扩展" class="headerlink" title="9. Shell 扩展"></a>9. Shell 扩展</h2><p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p><p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions">关于 shell 扩展的更多细节</a>。</p><h3 id="9-1-大括号扩展"><a href="#9-1-大括号扩展" class="headerlink" title="9.1. 大括号扩展"></a>9.1. 大括号扩展</h3><p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p><pre><code>echo beg{i,a,u}n ### begin began begun</code></pre><p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p><pre><code>echo {0..5} ### 0 1 2 3 4 5echo {00..8..2} ### 00 02 04 06 08</code></pre><h3 id="9-2-命令置换"><a href="#9-2-命令置换" class="headerlink" title="9.2. 命令置换"></a>9.2. 命令置换</h3><p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或<code>$()</code>包围时，命令置换将会执行。举个例子：</p><pre><code>now=`date +%T`### ornow=$(date +%T)echo $now ### 19:08:26</code></pre><h3 id="9-3-算数扩展"><a href="#9-3-算数扩展" class="headerlink" title="9.3. 算数扩展"></a>9.3. 算数扩展</h3><p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p><pre><code>result=$(( ((10 + 5*3) - 7) / 2 ))echo $result ### 9</code></pre><p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p><pre><code>x=4y=7echo $(( x + y ))     ### 11echo $(( ++x + y++ )) ### 12echo $(( x + y ))     ### 13</code></pre><h3 id="9-4-单引号和双引号"><a href="#9-4-单引号和双引号" class="headerlink" title="9.4. 单引号和双引号"></a>9.4. 单引号和双引号</h3><p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p><pre><code>echo "Your home: $HOME" ### Your home: /Users/&lt;username&gt;echo 'Your home: $HOME' ### Your home: $HOME</code></pre><p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p><pre><code>INPUT="A string  with   strange    whitespace."echo $INPUT   ### A string with strange whitespace.echo "$INPUT" ### A string  with   strange    whitespace.</code></pre><p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p><p>来看一个更严肃的例子：</p><pre><code>FILE="Favorite Things.txt"cat $FILE   ### 尝试输出两个文件: `Favorite` 和 `Things.txt`cat "$FILE" ### 输出一个文件: `Favorite Things.txt`</code></pre><p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p><h3 id="9-5-通配符"><a href="#9-5-通配符" class="headerlink" title="9.5. 通配符"></a>9.5. 通配符</h3><p>使用通配符可以完成特定的匹配, 一些常用的通配符</p><p><code>*</code> 可以通配一个或多个任意字符</p><pre class="line-numbers language-bash"><code class="language-bash">*.txthello.*great*.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>?</code>匹配一个字符</p><pre class="line-numbers language-bash"><code class="language-bash">?.mdHello?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>[]</code>匹配括号内部的任意一个字符</p><pre class="line-numbers language-bash"><code class="language-bash">He<span class="token punctuation">[</span>loym<span class="token punctuation">]</span>, <span class="token punctuation">[</span>AIEOU<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>[!]</code>不匹配括号内的任何字符</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span><span class="token punctuation">[</span><span class="token operator">!</span>aeiou<span class="token punctuation">]</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>预先定义的通配符</strong> </p><p>[[:alpha:]]<br>[[:alnum:]]<br>[[:space:]]<br>[[:upper:]]<br>[[:lower:]]<br>[[:digit:]]</p><p><strong>匹配通配符</strong> 有些情况下我们想匹配<code>*</code>或<code>?</code>等特殊字符，可以使用转义字符<code>\*\?</code></p><h2 id="10-流和重定向"><a href="#10-流和重定向" class="headerlink" title="10. 流和重定向"></a>10. 流和重定向</h2><p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p><p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p><p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p><h3 id="10-1-输入、输出流"><a href="#10-1-输入、输出流" class="headerlink" title="10.1. 输入、输出流"></a>10.1. 输入、输出流</h3><p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p><p>有三个文件描述符：</p><table><thead><tr><th>代码</th><th>描述符</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>stdin</code></td><td>标准输入</td></tr><tr><td><code>1</code></td><td><code>stdout</code></td><td>标准输出</td></tr><tr><td><code>2</code></td><td><code>stderr</code></td><td>标准错误输出</td></tr></tbody></table><h3 id="10-2-重定向"><a href="#10-2-重定向" class="headerlink" title="10.2. 重定向"></a>10.2. 重定向</h3><p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>重定向输出</td></tr><tr><td><code>&amp;&gt;</code></td><td>重定向输出和错误输出</td></tr><tr><td><code>&amp;&gt;&gt;</code></td><td>以附加的形式重定向输出和错误输出</td></tr><tr><td><code>&lt;</code></td><td>重定向输入</td></tr><tr><td><code>&lt;&lt;</code></td><td><a href="http://tldp.org/LDP/abs/html/here-docs.html">Here 文档</a> 语法</td></tr><tr><td><code>&lt;&lt;&lt;</code></td><td><a href="http://www.tldp.org/LDP/abs/html/x17837.html">Here 字符串</a></td></tr></tbody></table><p>以下是一些使用重定向的例子：</p><pre><code>### ls的结果将会被写到list.txt中ls -l &gt; list.txt### 将输出附加到list.txt中ls -a &gt;&gt; list.txt### 所有的错误信息会被写到errors.txt中grep da * 2&gt; errors.txt### 从errors.txt中读取输入less &lt; errors.txt</code></pre><h3 id="10-3-dev-null-文件"><a href="#10-3-dev-null-文件" class="headerlink" title="10.3. /dev/null 文件"></a>10.3. <code>/dev/null</code> 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><pre><code>$ command &gt; /dev/null</code></pre><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre><code>$ command &gt; /dev/null 2&gt;&amp;1</code></pre><h2 id="11-Debug"><a href="#11-Debug" class="headerlink" title="11. Debug"></a>11. Debug</h2><p>shell 提供了用于 debug 脚本的工具。</p><p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p><pre><code>#!/bin/bash options</code></pre><p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p><table><thead><tr><th>Short</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>-f</code></td><td>noglob</td><td>禁止文件名展开（globbing）</td></tr><tr><td><code>-i</code></td><td>interactive</td><td>让脚本以 <em>交互</em> 模式运行</td></tr><tr><td><code>-n</code></td><td>noexec</td><td>读取命令，但不执行（语法检查）</td></tr><tr><td><code>-t</code></td><td>—</td><td>执行完第一条命令后退出</td></tr><tr><td><code>-v</code></td><td>verbose</td><td>在执行每条命令前，向<code>stderr</code>输出该命令</td></tr><tr><td><code>-x</code></td><td>xtrace</td><td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td></tr></tbody></table><p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p><pre><code>#!/bin/bash -xfor (( i = 0; i &lt; 3; i++ )); do  echo $idone</code></pre><p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p><pre><code>$ ./my_script+ (( i = 0 ))+ (( i &lt; 3 ))+ echo 00+ (( i++  ))+ (( i &lt; 3 ))+ echo 11+ (( i++  ))+ (( i &lt; 3 ))+ echo 22+ (( i++  ))+ (( i &lt; 3 ))</code></pre><p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p><p><strong>:keyboard: 『示例源码』</strong> <a href="https://github.com/dunwu/os-tutorial/blob/master/codes/shell/demos/debug-demo.sh">debug-demo.sh</a></p><pre><code># 开启 debugset -xfor (( i = 0; i &lt; 3; i++ )); do  printf ${i}done# 关闭 debugset +x#  Output:#  + (( i = 0 ))#  + (( i &lt; 3 ))#  + printf 0#  0+ (( i++  ))#  + (( i &lt; 3 ))#  + printf 1#  1+ (( i++  ))#  + (( i &lt; 3 ))#  + printf 2#  2+ (( i++  ))#  + (( i &lt; 3 ))#  + set +xfor i in {1..5}; do printf ${i}; doneprintf "\n"#  Output: 12345</code></pre><h2 id="12-更多内容"><a href="#12-更多内容" class="headerlink" title="12. 更多内容"></a>12. 更多内容</h2><blockquote><p>📓 本文已归档到：<a href="https://github.com/dunwu/notes">notes</a></p></blockquote><ul><li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>，shell 资源列表</li><li><a href="https://github.com/awesome-lists/awesome-bash">awesome-bash</a>，bash 资源列表</li><li><a href="https://github.com/denysdovhan/bash-handbook">bash-handbook</a></li><li><a href="https://github.com/vuuihc/bash-guide">bash-guide</a> ，bash 基本用法指南</li><li><a href="https://github.com/Bash-it/bash-it">bash-it</a>，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li><li><a href="http://dotfiles.github.io/">dotfiles.github.io</a>，上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li><li><a href="http://www.runoob.com/linux/linux-shell.html">Runoob Shell 教程</a></li><li><a href="https://github.com/koalaman/shellcheck">shellcheck</a> 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li></ul><p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p><p>本文来源：<a href="https://www.cnblogs.com/jingmoxukong/p/7867397.html">一篇文章让你彻底掌握shell语言</a><br>作者：<a href="http://www.cnblogs.com/jingmoxukong/">静默虚空</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pulsar Modules</title>
      <link href="/2020/01/10/20200110-pulsar-modules/"/>
      <url>/2020/01/10/20200110-pulsar-modules/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Psrchive"><a href="#Psrchive" class="headerlink" title="Psrchive"></a>Psrchive</h2><h2 id="Astropy"><a href="#Astropy" class="headerlink" title="Astropy"></a>Astropy</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- statsmodels</title>
      <link href="/2020/01/09/20200109-data-analysis-statsmodels/"/>
      <url>/2020/01/09/20200109-data-analysis-statsmodels/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- sklearn</title>
      <link href="/2020/01/08/20200108-data-analysis-sklearn/"/>
      <url>/2020/01/08/20200108-data-analysis-sklearn/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- Pandas</title>
      <link href="/2020/01/07/20200107-data-analysis-pandas/"/>
      <url>/2020/01/07/20200107-data-analysis-pandas/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>NumPy 的 ndarray 数据处理要求数据类型一致，且不能缺失，不可为数据项添加额外标签等，为了解决 ndarray 的强类型限制，Panda 对 NumPy 的 ndarray 对象进行了扩展。</p><p>建立在 NumPy 数组结构上的 Pandas， 提供了 Series 和 DataFrame 对象，为极度繁琐和耗时的“数据清理”（data munging）任务提供了捷径。</p><p>笔者使用 Anaconda 提供的集成数据处理环境，查看 pandas 版本：</p><pre><code>import pandas as pdprint(pd.__version__)&gt;&gt;&gt;0.20.3</code></pre><h2 id="2-1-基本数据结构"><a href="#2-1-基本数据结构" class="headerlink" title="2.1. 基本数据结构"></a>2.1. 基本数据结构</h2><p>pandas 在 NumPy 的 ndarray 对象基础上封装了三个基本数据结构 Series、 DataFrame 和 Index。 Pandas 在这些基本数据结构上实现了许多功能和方法。</p><h3 id="2-1-1-Series-对象"><a href="#2-1-1-Series-对象" class="headerlink" title="2.1.1. Series 对象"></a>2.1.1. Series 对象</h3><p>Series 对象是一个带索引标签（Labels）的一维数组，打印查看很像只有一列的表，可以看做向量。可以使用 list 作为参数，来生成对应 Series 对象，例如：</p><pre><code>sdata = pd.Series([1, 2, 3.14])print(sdata)&gt;&gt;&gt;0    1.00  # 默认使用从 0 开始的整数作为索引1    2.002    3.14dtype: float64print(type(sdata).__name__)print(sdata.dtype) # dtype 属性记录成员的类型&gt;&gt;&gt;Seriesfloat64</code></pre><p>可以使用索引访问 Series 对象成员，如果使用切片返回的是一个 Series 对象。</p><pre><code>print(type(sdata[1]).__name__, sdata[1])print(type(sdata[0:-1]).__name__)&gt;&gt;&gt;float64 2Series</code></pre><p>如同查看列表长度一样，可以使用 len() 查看成员数目：</p><pre><code>print(len(sdata))&gt;&gt;&gt;3</code></pre><h4 id="2-1-1-1-Series-索引"><a href="#2-1-1-1-Series-索引" class="headerlink" title="2.1.1.1. Series 索引"></a>2.1.1.1. Series 索引</h4><p>Series 对象和一维 NumPy 数组的本质差异在于索引：</p><ul><li>NumPy 数组通过隐式定义的整数索引获取数值。</li><li>Pandas 的 Series 对象用显式定义的 RangeIndex 索引与数值关联。</li></ul><pre><code># 打印 RangeIndex 类型print(sdata.index)&gt;&gt;&gt;RangeIndex(start=0, stop=3, step=1)</code></pre><p>显式索引让 Series 对象拥有了更具弹性的索引方式。 索引不再局限于整数，可以是任意想要的类型。例如用字符串作为索引：</p><pre><code>sdata = pd.Series([1, 2, 3.14], index=['num1', 'num2', 'pi'])print(sdata)&gt;&gt;&gt;num1    1.00num2    2.00pi      3.14dtype: float64# 使用字符串作为索引print(sdata['pi'])&gt;&gt;&gt;3.14</code></pre><p>Series 成员可以是其他任何对象，也可以是不同对象，这看起来很像字典，此时它的类型为 object：</p><pre><code>sdata = pd.Series({'a': 1, 'b': 2, 'c': 'abc'})print(sdata)&gt;&gt;&gt;a      1b      2c    abcdtype: object</code></pre><h4 id="2-1-1-2-Series-是特殊字典"><a href="#2-1-1-2-Series-是特殊字典" class="headerlink" title="2.1.1.2. Series 是特殊字典"></a>2.1.1.2. Series 是特殊字典</h4><p>字典是一种将任意键映射到一组任意值或对象的数据结构，而 Series 对象是一种将类型键映射到一组类型值的数据结构。Pandas Series 的类型信息使得它在某些操作上比 Python 的字典更高效。</p><p>可以直接用 Python 的字典创建一个 Series 对象：</p><pre><code>id_dicts = {'John': 100,            'Tom' : 101,            'Bill': 102}ids = pd.Series(id_dicts)print(ids['Bill'])&gt;&gt;&gt;102# 元素顺序按照索引字母大小进行排序print(ids)&gt;&gt;&gt;Bill    102John    100Tom     101dtype: int64</code></pre><p>和字典不同，Series 对象还支持数组形式的操作， 比如切片：</p><pre><code># 注意切片索引顺序不是按照字典中元素定义顺序，而是按照 Series 对象的索引顺序sub_ids = ids['Bill':'John']print(sub_ids)&gt;&gt;&gt;Bill    102John    100dtype: int64</code></pre><h4 id="2-1-1-3-创建-Series-对象"><a href="#2-1-1-3-创建-Series-对象" class="headerlink" title="2.1.1.3. 创建 Series 对象"></a>2.1.1.3. 创建 Series 对象</h4><pre><code>pd.Series(data, index=index)</code></pre><p>创建 Series 对象的格式如上所示，index 可选，指定索引序列，默认值为整数序列；data 参数支持多种数据类型：列表，字典或者一维的 ndarray 对象。</p><pre><code>ndata = np.arange(1, 4, 1)sdata = pd.Series(ndata)print(sdata)&gt;&gt;&gt;0    11    22    3dtype: int32</code></pre><p>data 也可以是一个数值， 创建 Series 对象时会重复填充到每个索引上：</p><pre><code>sdata = pd.Series(1, index=['a', 'b', 'c'])print(sdata)&gt;&gt;&gt;a    1b    1c    1dtype: int64</code></pre><p>当参数为字典时，可以通过显式指定索引筛选需要的成员：</p><pre><code>subsdata = pd.Series({'a': 1, 'b': 2, 'c': 'abc'}, index=['a', 'c'])print(subsdata)&gt;&gt;&gt;a    1c    abcdtype: object</code></pre><p><strong>注意</strong></p><p>Series 对象只会保留显式定义的键值对。</p><p>Series.index 属性获取所有行索引信息：</p><pre><code># 获取行索引信息print(subsdata.index)&gt;&gt;&gt;Index(['a', 'c'], dtype='object') </code></pre><h3 id="2-1-2-DataFrame-对象"><a href="#2-1-2-DataFrame-对象" class="headerlink" title="2.1.2. DataFrame 对象"></a>2.1.2. DataFrame 对象</h3><p>如果将 Series 类比为带索引的一维数组（或者含有一列数据的带有行标签的单列表）， 那么 DataFrame 就可以看作是一种既有行索引，又有列名的二维数组（或者含有行标签和列标签的表，每一列都是一个 Series 对象）。</p><pre><code>id_dicts = {'John': 100,            'Tom' : 101,            'Bill': 102}age_dicts = {'John': 20,             'Tom' : 21,             'Bill': 19}studentd = pd.DataFrame({'id':  pd.Series(id_dicts),                        'age': pd.Series(age_dicts)})print(studentd)&gt;&gt;&gt;      age   idBill   19  102John   20  100Tom    21  101</code></pre><p>从示例中可以看出 DataFrame 是一组 Series 的集合，每一列都是一个 Series 对象。</p><h4 id="2-1-2-1-DataFrame-索引"><a href="#2-1-2-1-DataFrame-索引" class="headerlink" title="2.1.2.1. DataFrame 索引"></a>2.1.2.1. DataFrame 索引</h4><p>在 NumPy 的二维数组里， data[0] 返回第一行；而在 DataFrame 中， data[‘col0’] 返回第一列。 因此，DataFrame 是一种通用字典，而不是通用数组。</p><pre><code># 使用列名字访问特定列print(studentd['age'])&gt;&gt;&gt;Bill    19John    20Tom     21Name: age, dtype: int64# 指定列名和行名print(studentd['age']['John'])&gt;&gt;&gt;20</code></pre><h4 id="2-1-2-2-创建DataFrame对象"><a href="#2-1-2-2-创建DataFrame对象" class="headerlink" title="2.1.2.2. 创建DataFrame对象"></a>2.1.2.2. 创建DataFrame对象</h4><p>上面的示例指定列名和 Series 对象创建多列，也可以创建单列的 DataFrame 对象：</p><pre><code># 以下两种创建方式等价ids = pd.Series(id_dicts)# 通过 Series 对象字典创建studentd = pd.DataFrame({'id': ids})studentd = pd.DataFrame(ids, columns=['id'])</code></pre><p>通过字典列表创建: 任何元素是字典的列表都可以变成 DataFrame。</p><pre><code># 创建字典列表num = [{'num0': i, 'num*3': 3 * i} for i in range(3)]print(num)&gt;&gt;&gt;[{'num0': 0, 'num*3': 0}, {'num0': 1, 'num*3': 3}, {'num0': 2, 'num*3': 6}]# 创建 DataFrame 对象print(pd.DataFrame(num))&gt;&gt;&gt;   num*3  num00      0     01      3     12      6     2 </code></pre><p>如果字典中有些键不存在，Pandas 会用 NaN（不是数字或此处无数，Not a number） 来表示：</p><pre><code>numd = pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])print(numd)     a  b    c0  1.0  2  NaN1  NaN  3  4.0</code></pre><p>通过 NumPy 二维数组创建。 假如有一个二维数组， 就可以创建一个可以指定行列索引值的 DataFrame。 如果不指定行列索引值，那么行列默认都是整数索引值：</p><pre><code>narray = np.random.randint(3, size=(3, 2))print(narray)&gt;&gt;&gt;[[2 0] [2 2] [2 1]]df = pd.DataFrame(narray,                  columns = ['foo', 'bar'],                  index=['a', 'b', 'c'])print(df)&gt;&gt;&gt;   foo  bara    2    0b    2    2c    2    1</code></pre><p>查看行索引和列索引：</p><pre><code>print(df.index)print(df.columns)&gt;&gt;&gt;Index(['a', 'b', 'c'], dtype='object')Index(['foo', 'bar'], dtype='object')</code></pre><p>通过 NumPy 结构化数组创建：</p><pre><code>A = np.ones(3, dtype=[('A', 'i8'), ('B', 'f8')])print(A)&gt;&gt;&gt;[(1,  1.) (1,  1.) (1,  1.)]print(pd.DataFrame(A))&gt;&gt;&gt;   A    B0  1  1.01  1  1.02  1  1.0</code></pre><h3 id="2-1-3-更改行或列名"><a href="#2-1-3-更改行或列名" class="headerlink" title="2.1.3. 更改行或列名"></a>2.1.3. 更改行或列名</h3><h4 id="2-1-3-1-通过属性更改"><a href="#2-1-3-1-通过属性更改" class="headerlink" title="2.1.3.1. 通过属性更改"></a>2.1.3.1. 通过属性更改</h4><p>可以通过 df.index 和 df.columns 查看行名和列名，同样可以通过这些属性更改行或列的名称，对于 Series 来说只有行名：</p><pre><code>narray = np.random.randint(3, size=(3, 2))df = pd.DataFrame(narray,                  columns = ['foo', 'bar'],                  index=['a', 'b', 'c'])# 更新行索引标签df.index = [0, 1, 2]print(df.index)# 更新列索引标签df.columns = ['a', 'b']print(df.columns)&gt;&gt;&gt;Int64Index([0, 1, 2], dtype='int64')Index(['a', 'b'], dtype='object')print(df)&gt;&gt;&gt;   a  b0  0  01  1  02  0  2</code></pre><p>注意行或列的标签个数和 DataFrame 对象的行数或列数必须一致，否则会报错。</p><h3 id="2-1-4-Index-对象"><a href="#2-1-4-Index-对象" class="headerlink" title="2.1.4. Index 对象"></a>2.1.4. Index 对象</h3><p>Pandas 的 Index 对象可以将它看作是一个不可变数组或有序集合， Index 对象可以包含重复值。</p><pre><code># 可以包含重复值ind = pd.Index([2, 3, 5, 7, 7, 11])print(type(ind).__name__)&gt;&gt;&gt;Int64Index# 索引访问元素print(ind[1])&gt;&gt;&gt;3# 切片访问返回 Index 对象print(ind[::2])&gt;&gt;&gt;Int64Index([2, 5, 7], dtype='int64')</code></pre><p>Index 对象不支持对数据的修改：</p><pre><code>ind[1] = 1&gt;&gt;&gt;TypeError: Index does not support mutable operations</code></pre><p>Index 对象还有许多与 NumPy 数组相似的属性：</p><pre><code>print(ind.size, ind.shape, ind.ndim, ind.dtype)&gt;&gt;&gt;6 (6,) 1 int64 </code></pre><h4 id="2-1-4-1-排序操作"><a href="#2-1-4-1-排序操作" class="headerlink" title="2.1.4.1. 排序操作"></a>2.1.4.1. 排序操作</h4><p>Index 对象支持对元素的排序：</p><pre><code>ind = pd.Index([2, 4, 5, 1, 11])print(ind)&gt;&gt;&gt;Int64Index([2, 4, 5, 1, 11], dtype='int64')ind = ind.sort_values()print(ind)&gt;&gt;&gt;Int64Index([1, 2, 4, 5, 11], dtype='int64')</code></pre><h4 id="2-1-4-2-集合操作"><a href="#2-1-4-2-集合操作" class="headerlink" title="2.1.4.2. 集合操作"></a>2.1.4.2. 集合操作</h4><p>Pandas 对象被设计用于实现多种操作， 如连接（join） 数据集，其中会涉及许多集合操作。 Index 对象遵循 Python 标准库的集合（set） 数据结构的许多习惯用法， 包括并集、 交集、 差集等：</p><pre><code>indA = pd.Index([1, 3, 5, 7, 9])indB = pd.Index([2, 3, 5, 7, 11])# 交集，等价于 indA.intersection(indB)print(indA &amp; indB)&gt;&gt;&gt;Int64Index([3, 5, 7], dtype='int64')# 并集print(indA | indB)&gt;&gt;&gt;Int64Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')# 异或print(indA ^ indB)&gt;&gt;&gt;Int64Index([1, 2, 9, 11], dtype='int64')</code></pre><p>Index 对象进行集合操作的结果还是 Index 对象。它可以是一个空对象。</p><pre><code>indA = pd.Index([1, 3, 5, 7, 9])indB = pd.Index([2])# 交集print(indA &amp; indB)&gt;&gt;&gt;Int64Index([], dtype='int64')</code></pre><h2 id="2-2-数据选择和扩展"><a href="#2-2-数据选择和扩展" class="headerlink" title="2.2. 数据选择和扩展"></a>2.2. 数据选择和扩展</h2><p>NumPy 数组可以通过索引，切片，花式索引和掩码操作进行各类选择，Pandas 的 Series 和 DataFrame 对象具有相似的数据获取与调整操作。</p><h3 id="2-2-1-Series数据选择"><a href="#2-2-1-Series数据选择" class="headerlink" title="2.2.1. Series数据选择"></a>2.2.1. Series数据选择</h3><h4 id="2-2-1-1-访问数据"><a href="#2-2-1-1-访问数据" class="headerlink" title="2.2.1.1. 访问数据"></a>2.2.1.1. 访问数据</h4><p>将Series看作字典，和字典一样， Series 对象提供了键值对（索引）的映射：</p><pre><code># 使用 in 或者 not in 判断键是否存在sdata = pd.Series([1, 2, 3.14], index=['num1', 'num2', 'pi'])# 等价于 sdata.indexprint(sdata.keys())print('pi' in sdata) # 等价于 'pi' in sdata.keys()&gt;&gt;&gt;Index(['num1', 'num2', 'pi'], dtype='object')True# 判断值是否存在，Series.values 是 ndarray 类型print(sdata.values, type(sdata.values).__name__)print(1 in sdata.values)&gt;&gt;&gt;[ 1.    2.    3.14] ndarrayTrue# Series.items() 返回 zip 类型，可以转换为 listprint(sdata.items())print(list(sdata.items()))&gt;&gt;&gt;&lt;zip object at 0x0000020B8A3DCF08&gt;[('num1', 1.0), ('num2', 2.0), ('pi', 3.1400000000000001)]</code></pre><p>Series 不仅有着和字典一样的接口， 而且还具备和 NumPy 数组一样的数组数据选择功能，包括索引、掩码、花式索引等操作，例如：</p><pre><code># 将显式索引作为切片，结果包含最后一个索引subs = sdata['num1':'num2']print(subs)&gt;&gt;&gt;num1    1.0num2    2.0dtype: float64# 将隐式整数索引作为切片，结果不含最后一个索引print(sdata[0:2])print(sdata[-1:0:-1])&gt;&gt;&gt;num1    1.0num2    2.0dtype: float64pi      3.14num2    2.00dtype: float64# 掩码，返回 bool 类型的 Series 掩码对象print((sdata &gt; 1) &amp; (sdata &lt; 4))&gt;&gt;&gt;num1    Falsenum2     Truepi       Truedtype: bool# Series 掩码对象作为索引subs = sdata[(sdata &gt; 1) &amp; (sdata &lt; 4)]print(subs)&gt;&gt;&gt;num2    2.00pi      3.14dtype: float64# 花式索引subs = sdata[['num1', 'pi']]print(subs)&gt;&gt;&gt;num1    1.00pi      3.14dtype: float64</code></pre><p>切片是绝大部分混乱之源。 需要注意的是，当使用显式索引（即 data[‘a’:’c’]） 作切片时， 结果包含最后一个索引； 而当使用隐式索引（即 data[0:2]） 作切片时， 结果不包含最后一个索引。</p><p>索引标签默认是无序的，也即根据创建时标签声明的顺序来排列，我们可以对它进行排序，以方便切片操作：</p><pre><code>sdata = pd.Series([1, 2, 3.14], index=['num2', 'num1', 'pi']) print(sdata) &gt;&gt;&gt; num2    1.00 num1    3.14 pi      2.00 dtype: float64 # 对索引进行排序 sdata = sdata.sort_index() print(sdata['num1':'num2']) &gt;&gt;&gt; num1    2.0 num2    1.0 dtype: float64 </code></pre><h4 id="2-2-1-2-索引器"><a href="#2-2-1-2-索引器" class="headerlink" title="2.2.1.2. 索引器"></a>2.2.1.2. 索引器</h4><p>切片和取值的习惯用法经常会造成混乱。如果 Series 是显式整数索引，那么 data[1] 这样的取值操作会使用显式索引，而 data[1:3] 样的切片操作却会使用隐式索引。</p><pre><code>sdata = pd.Series([1, 2, 3.14], index=[1, 2, 3])print(sdata[1]) # 显式索引，使用 sdata[0] 将报错&gt;&gt;&gt;1.0print(sdata[0:2]) # 隐式索引，不含 sdata[2]&gt;&gt;&gt;1    1.02    2.0dtype: float64</code></pre><p>由于整数索引很容易造成混淆，所以 Pandas 提供了一些索引器（indexer） 属性来作为取值的方法。它们不是 Series 对象的函数方法， 而是暴露切片接口的属性。</p><p>第一种索引器是 loc 属性， 表示取值和切片都是显式的：</p><pre><code>sdata = pd.Series([1, 2, 3.14], index=[1, 2, 3])print(sdata.loc[1])   # 显式索引&gt;&gt;&gt;1.0print(sdata.loc[1:2]) # 显式索引&gt;&gt;&gt;1    1.02    2.0dtype: float64</code></pre><p>第二种是 iloc 索引属性，表示取值和切片都是隐式索引（从 0 开始， 左闭右开区间）：</p><pre><code>sdata = pd.Series([1, 2, 3.14], index=[1, 2, 3])print(sdata.iloc[1])  # 隐式索引&gt;&gt;&gt;2.0print(sdata.iloc[1:2])# 隐式索引&gt;&gt;&gt;2    2.0dtype: float64</code></pre><p>第三种取值属性是 ix，它是前两种索引器的混合形式，从 0.20.0 版本开始，ix 索引器不再被推荐使用。</p><p>Python 代码的设计原则之一是“显式优于隐式”。 使用 loc 和 iloc 可以让代码更容易维护， 可读性更高。  特别是在处理整数索引的对象时， 我强烈推荐使用这两种索引器。 它们既可以让代码阅读和理解起来更容易， 也能避免因误用索引 / 切片而产生的小  bug。</p><h4 id="2-2-1-3-扩展数据"><a href="#2-2-1-3-扩展数据" class="headerlink" title="2.2.1.3. 扩展数据"></a>2.2.1.3. 扩展数据</h4><p>Series 对象还可以用字典语法调整数据。可以通过增加新的索引值扩展 Series：</p><pre><code>sdata['e'] = 2.72print(sdata)&gt;&gt;&gt;num1    1.00num2    2.00pi      3.14e       2.72dtype: float64</code></pre><h3 id="2-2-2-DataFrame数据选择"><a href="#2-2-2-DataFrame数据选择" class="headerlink" title="2.2.2. DataFrame数据选择"></a>2.2.2. DataFrame数据选择</h3><h4 id="2-2-2-1-访问数据"><a href="#2-2-2-1-访问数据" class="headerlink" title="2.2.2.1. 访问数据"></a>2.2.2.1. 访问数据</h4><p>既可以通过字典方式也可以通过属性方式访问 DataFrame :</p><pre><code>studentd = pd.DataFrame({'id':  pd.Series(id_dicts),                        'age': pd.Series(age_dicts)})print(studentd['id']['John']) # 字典键方式访问&gt;&gt;&gt;100print(studentd['id']) # 列属性方式访问&gt;&gt;&gt;Bill    102John    100Tom     101Name: id, dtype: int64print(studentd['id']['John']) # 列属性和行属性方式访问&gt;&gt;&gt;100</code></pre><p>虽然属性形式的数据选择方法很方便， 但是它并不是通用的。 如果列名不是纯字符串， 或者列名与 DataFrame 的方法同名，  那么就不能用属性索引。 例如， DataFrame 有一个 pop() 方法， 如果用data.pop 就不会获取 ‘pop’ 列，  而是显示为方法。</p><p>另外， 还应该避免对用属性形式选择的列直接赋值（即可以用data[‘pop’] = z，但不要用 data.pop = z）防止覆盖方法名。</p><p>和前面介绍的 Series 对象一样，还可以用字典形式的语法调整对象，如果要增加一列可以这样做：</p><pre><code># 等价于 studentd['newcol'] = studentd.id + studentd.agestudentd['newcol'] = studentd['id'] + studentd['age']print(studentd)&gt;&gt;&gt;      age   id  newcolBill   19  102     121John   20  100     120Tom    21  101     122</code></pre><p>将DataFrame看作二维数组，用 values 属性按行查看数组数据：</p><pre><code>print(studentd.values, '\n', type(studentd.values).__name__)&gt;&gt;&gt;[[ 19 102] [ 20 100] [ 21 101]] ndarray</code></pre><p>由于返回值是 ndarray 类型，所以可以对其进行任何矩阵操作：</p><pre><code># 获取行数据（获取一列数据要传递列索引）print(studentd.values[0])&gt;&gt;&gt;[ 19 102]print(studentd.values.T)&gt;&gt;&gt;[[ 19  20  21] [102 100 101]]print(studentd.keys())</code></pre><p>keys() 方法返回列名组成的索引类型 Index：</p><pre><code>&gt;&gt;&gt; Index(['age', 'id'], dtype='object') </code></pre><h4 id="2-2-2-2-使用索引器"><a href="#2-2-2-2-使用索引器" class="headerlink" title="2.2.2.2. 使用索引器"></a>2.2.2.2. 使用索引器</h4><p>索引器的作用在于指明使用隐式索引还是显示索引。通过 iloc 索引器，可以像对待 NumPy 数组一样索引 Pandas 的底层数组（Python 的隐式索引），DataFrame 的行列标签会自动保留在结果中：</p><pre><code>print(studentd.iloc[:1, :2])&gt;&gt;&gt;      age   idBill   19  102</code></pre><p>任何用于处理 NumPy 形式数据的方法都可以用于这些索引器。例如，可以在 loc 索引器中结合使用掩码与花式索引方法：</p><pre><code># 选择 age &gt;= 20 的学生的 id 信息print(studentd.loc[studentd.age &gt;= 20, ['id']])&gt;&gt;&gt;      idJohn  100Tom   102</code></pre><h4 id="2-2-2-3-切片选择"><a href="#2-2-2-3-切片选择" class="headerlink" title="2.2.2.3. 切片选择"></a>2.2.2.3. 切片选择</h4><p>如果对单个标签取值就选择列，而对多个标签用切片就选择行：</p><pre><code>    # 列选取，返回 Series 对象print(studentd['age'])&gt;&gt;&gt;Name: age, dtype: int64# 行选取，返回 DataFrame 对象print(studentd['John':'Tom'])&gt;&gt;&gt;      age   idJohn   20  100Tom    21  101</code></pre><p>切片也可以不用索引值， 而直接用行数来实现：</p><pre><code>print(studentd[1:3])&gt;&gt;&gt;      age   idJohn   20  100Tom    21  101</code></pre><p>与之类似，掩码操作也可以直接对每一行进行过滤，而不需要使用 loc 索引器：</p><pre><code>print(studentd[studentd.age &gt;= 20])&gt;&gt;&gt;      age   idJohn   20  100Tom    21  101</code></pre><h4 id="2-2-2-4-更新数据"><a href="#2-2-2-4-更新数据" class="headerlink" title="2.2.2.4. 更新数据"></a>2.2.2.4. 更新数据</h4><p>任何一种索引方法都可以用于调整数据， 这一点和 NumPy 的常用方法是相同的：</p><pre><code>studentd.loc['John', 'age'] = 23print(studentd)&gt;&gt;&gt;      age   idBill   19  102John   23  100Tom    21  101# 更新第一行的值全为 5studentd.iloc[0] = 5print(studentd)      age   idBill    5    5John   20  100Tom    21  101</code></pre><h2 id="2-3-数值运算"><a href="#2-3-数值运算" class="headerlink" title="2.3. 数值运算"></a>2.3. 数值运算</h2><p>NumPy 的基本能力之一是快速对每个元素进行运算，既包括基本算术运算（加、 减、 乘、 除） ， 也包括更复杂的运算（三角函数、 指数函数和对数函数等），参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#array-scalar">算术运算</a>。 Pandas 继承了 NumPy 的功能，也即这些函数同样可以作用在 Pandas 对象上。</p><p>除此之外，Pandas 也实现了一些高效技巧：一元运算作用在 Pandas  对象上时会保留索引和列标签；而对于二元运算（如加法和乘法），Pandas  在传递通用函数时会自动对齐索引进行计算。这就意味着，保存数据内容与组合不同来源的数据——两处在NumPy 数组中都容易出错的地方在 Pandas 中很容易实现。</p><h3 id="2-3-1-一元运算"><a href="#2-3-1-一元运算" class="headerlink" title="2.3.1. 一元运算"></a>2.3.1. 一元运算</h3><pre><code>sdata = pd.Series(np.arange(4))print(sdata * 2)&gt;&gt;&gt;0    01    22    43    6dtype: int32</code></pre><p>可以发现 np 函数作用在 Pandas 对象上的返回值还是 Pandas 对象，会保留原标签。</p><pre><code>df = pd.DataFrame(np.arange(4).reshape(2, 2), columns=['a', 'b'])print(np.sin(df / 4 * np.pi))&gt;&gt;&gt;     a         b0  0.0  0.7071071  1.0  0.707107</code></pre><h3 id="2-3-2-二元运算"><a href="#2-3-2-二元运算" class="headerlink" title="2.3.2. 二元运算"></a>2.3.2. 二元运算</h3><p>当在两个 Series 或 DataFrame 对象上进行二元计算时，Pandas 会在计算过程中对齐两个对象的索引。当处理不完整的数据时，这一点非常方便。</p><pre><code>sdata0 = pd.Series(np.arange(3))sdata1 = pd.Series(np.arange(2))print(sdata0)print(sdata1)&gt;&gt;&gt;0    01    12    2dtype: int320    01    1dtype: int32</code></pre><p>首先生成两个索引不同的 Series 对象，然后进行相加：</p><pre><code>print(sdata0 + sdata1)&gt;&gt;&gt;0    0.01    2.02    NaNdtype: float64</code></pre><p>结果数组的索引是两个输入数组索引的并集。对于缺失位置的数据，Pandas 会用 NaN 填充，表示“此处无数”。这是 Pandas 表示缺失值的方法。</p><p>如果用 NaN 值不是我们想要的结果， 那么可以用适当的对象方法代替运算符。 例如， A.add(B) 等价于 A + B， 也可以设置参数自定义 A 或 B 缺失的数据：</p><pre><code># sdata1 中缺失的索引 2 的值将使用 0 替代print(sdata0.add(sdata1, fill_value=0))&gt;&gt;&gt;0    0.01    2.02    2.0  # 0 + 2dtype: float64</code></pre><p>在计算两个 DataFrame 时，类似的索引对齐规则也同样会出现在共同（并集）列中：</p><pre><code>df0 = pd.DataFrame(np.arange(4).reshape(2,2), columns=list('BA'))df1 = pd.DataFrame(np.arange(2).reshape(2,1), columns=list('A'))print(df0)print(df1)&gt;&gt;&gt;   B  A0  0  11  2  3   A0  01  1# 填充缺省值 NaNprint(df0 + df1)&gt;&gt;&gt;   A   B0  1 NaN1  4 NaN# 指定缺省值print(df0.sub(df1, fill_value=0))&gt;&gt;&gt;   A    B0  1  0.01  2  2.0</code></pre><p>两个对象的行列索引可以是不同顺序的，结果的索引会自动按顺序排列。</p><p>Python运算符与Pandas方法的映射关系:</p><blockquote><table><thead><tr><th>Python运算符</th><th>Pandas 对象方法</th></tr></thead><tbody><tr><td>+</td><td>add()</td></tr><tr><td>-</td><td>sub()、 subtract()</td></tr><tr><td>*</td><td>mul()、 multiply()</td></tr><tr><td>/</td><td>truediv()、 div()、 divide()</td></tr><tr><td>//</td><td>floordiv()</td></tr><tr><td>%</td><td>mod()</td></tr><tr><td>**</td><td>pow()</td></tr></tbody></table></blockquote><h3 id="2-3-3-DataFrame与Series的运算"><a href="#2-3-3-DataFrame与Series的运算" class="headerlink" title="2.3.3. DataFrame与Series的运算"></a>2.3.3. DataFrame与Series的运算</h3><p>DataFrame 与 Series 之间的运算遵循 NumPy 中二维数组和一维数组之间的广播运算规则。</p><pre><code>narray0 = np.array([2,2])narray1 = np.array([[1,1],[2,2]])print(narray0 + narray1)&gt;&gt;&gt;[[3 3] [4 4]]sdata = pd.Series(narray0, index=list('AB'))print(sdata)&gt;&gt;&gt;A    2B    2dtype: int32df = pd.DataFrame(narray1, columns=list('AB'))print(df)&gt;&gt;&gt;   A  B0  1  21  1  2print(sdata + df)&gt;&gt;&gt;   A  B0  3  31  4  4</code></pre><p>根据 NumPy 的广播规则，让二维数组减自身的一行数据会按行计算。如果想按列计算，就需要利用前面介绍过的运算符方法， 通过 axis 参数设置：</p><pre><code># 默认按行计算print(df + df.iloc[0])&gt;&gt;&gt;   A  B0  2  21  3  3# 按列相加print(df.add(df['A'], axis=0))&gt;&gt;&gt;   A  B0  2  21  4  4</code></pre><p>这些行列索引的保留与对齐方法说明 Pandas 在运算时会一直保存这些数据内容， 从而避免在处理数据类型有差异和 / 或维度不一致的 NumPy 数组时可能遇到的问题。</p><h2 id="2-4-缺失值处理"><a href="#2-4-缺失值处理" class="headerlink" title="2.4. 缺失值处理"></a>2.4. 缺失值处理</h2><p>现实中采集的数据很少是干净整齐的，许多目前流行的数据集都会有数据缺失的现象。</p><p>通常有两种方式表示缺失值：</p><ol><li>通过一个覆盖全局的掩码表示缺失值，例如 R 语言为每个元素保留 1 bit 用于标记缺失值。</li><li>用一个标签值（sentinel value） 表示缺失值，比如用 NaN（不是一个数） 表示缺失的浮点数。</li></ol><p>Pandas 选择用标签方法表示缺失值，包括两种 Python 原有的缺失值： 浮点数据类型的 NaN 值， 以及 Python 的 None 对象。</p><h3 id="2-4-1-None"><a href="#2-4-1-None" class="headerlink" title="2.4.1. None"></a>2.4.1. None</h3><p>None 是一个 Python 内置对象，经常在代码中表示缺失值。</p><pre><code>print(None, type(None).__name__)&gt;&gt;&gt;None NoneType</code></pre><p>由于 None 是一个 Python 对象，只能用于 ‘object’ 数组类型（即由 Python 对象构成的数组），不能用于其他类型的数组：</p><pre><code>print(np.array([1, None, 3, 4], dtype=object))&gt;&gt;&gt;[1 None 3 4]# 如果不是 object 类型将报错print(np.array([1, None, 3, 4], dtype=int))&gt;&gt;&gt;TypeError: int() argument must be a string, a bytes-likeobject or a number, not 'NoneType'</code></pre><p>这里 dtype=object 表示 NumPy 认为由于这个数组是 Python 对象构成的，因此将其类型判断为  object。虽然这种类型在某些情景中非常有用，对数据的任何操作最终都会在 Python  层面完成，但是在进行常见的快速操作时，这种类型比其他原生类型数组要更耗时。</p><p>由于 Python 没有对 None 对象定义加减等运算操作，所以在包含 None 的数组上执行这类操作均会报错。</p><pre><code>narray = np.array([1, None, 3, 4], dtype=object)print(narray.sum())&gt;&gt;&gt;TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'</code></pre><p>在 Pandas 中，None 被自动转化为 NaN 类型，由于 NaN 是特殊的浮点数，所以生成的对象类型默认为浮点型 float64：</p><pre><code>ps = pd.Series([1, 2, None])print(ps)&gt;&gt;&gt;0    1.01    2.02    NaNdtype: float64</code></pre><p>当为一个整型对象的元素赋值为 None 时，类型自动转换为 float64：</p><pre><code>ps = pd.Series([1, 2])print(ps.dtype)&gt;&gt;&gt;int64ps[0] = Noneprint(ps)&gt;&gt;&gt;0    NaN1    2.0dtype: float64</code></pre><h3 id="2-4-2-NaN"><a href="#2-4-2-NaN" class="headerlink" title="2.4.2. NaN"></a>2.4.2. NaN</h3><p>NaN（全称 Not a Number，不是一个数字），是一种按照 IEEE 浮点数标准设计、在任何系统中都兼容的特殊浮点数。表示未定义或不可表示的值。</p><p>IEEE 754-1985中，用指数部分全为1、小数部分非零表示NaN。以32位IEEE单精度浮点数的NaN为例，按位表示即：S111  1111 1AXX XXXX XXXX XXXX XXXX XXXX，S为符号位，符号位S的取值无关紧要；A是小数部分的最高位（the most significant bit of the significand），其取值表示了 NaN 的类型：X 不能全为0，并被称为 NaN  的payload。</p><p>通常返回 NaN 的运算有如下三种：</p><ol><li>至少有一个参数是 NaN 的运算</li><li>不定式</li></ol><blockquote><ul><li>下列除法运算：0/0、∞/∞、∞/−∞、−∞/∞、−∞/−∞</li><li>下列乘法运算：0×∞、0×−∞</li><li>下列加法运算：∞ + (−∞)、(−∞) + ∞</li><li>下列减法运算：∞ - ∞、(−∞) - (−∞)</li></ul></blockquote><ol><li>产生复数结果的实数运算。例如：</li></ol><blockquote><ul><li>对负数进行开偶次方的运算</li><li>对负数进行对数运算</li><li>对正弦或余弦到达域以外的数进行反正弦或反余弦运算</li></ul></blockquote><p>由于 NaN 是特殊的浮点数，所以当数组成员包含 NaN 时，其类型为浮点型，默认为 float64。</p><pre><code>narray = np.array([1, np.nan, 3, 4])print(narray.dtype)&gt;&gt;&gt;float64# 作用在 NaN 上的运算总是返回 NaNprint(narray.sum())&gt;&gt;&gt;nan# 指定类型为 int 将报错narray = np.array([1, np.nan, 3, 4], dtype=int)&gt;&gt;&gt;ValueError: cannot convert float NaN to integer</code></pre><p>NumPy 同时提供了一类特殊的累计函数，参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#converge">聚合统计</a>，它们可以忽略缺失值的影响：</p><pre><code>print(np.nansum(narray))&gt;&gt;&gt;8.0print(np.nanmin(narray), np.nanmax(narray))&gt;&gt;&gt;1.0 4.0</code></pre><p><strong>注意</strong></p><p>NaN 是一种特殊的浮点数， 不是整数、 字符串以及其他数据类型。</p><p>np.nan 表示常量 NaN，如果在创建 Pandas 对象时，包含 np.nan 成员，则对象 dtype 自动转化为 float64 类型，同样赋值操作也会改变 dtype：</p><pre><code>ps = pd.Series([1, 2, np.nan])print(ps.dtype)&gt;&gt;&gt;float64ps = pd.Series([1, 2])print(ps.dtype)&gt;&gt;&gt;int64ps[0] = np.nanprint(ps)&gt;&gt;&gt;0    NaN1    2.0dtype: float64</code></pre><h3 id="2-4-3-缺失值转换规则"><a href="#2-4-3-缺失值转换规则" class="headerlink" title="2.4.3. 缺失值转换规则"></a>2.4.3. 缺失值转换规则</h3><p>Pandas对不同类型缺失值的转换规则：</p><blockquote><table><thead><tr><th>类型</th><th>缺失值转换规则</th><th>NA标签值</th></tr></thead><tbody><tr><td>floating</td><td>无变化</td><td>np.nan</td></tr><tr><td>object</td><td>无变化</td><td>None 或 np.nan</td></tr><tr><td>integer</td><td>强制转换为 float64</td><td>np.nan</td></tr><tr><td>boolean</td><td>强制转换为 float64</td><td>np.nan</td></tr><tr><td>boolean</td><td>无变化</td><td>None</td></tr></tbody></table></blockquote><p>以 bool 类型为例，分别对元素赋值 None 和 np.nan，观察类型变化：</p><pre><code>ps = pd.Series([1, 0, 1], dtype=bool)# 赋值为 None 等价于 False 类型不变ps[1] = Noneprint(ps)&gt;&gt;&gt;0     True1    False2     Truedtype: bool# 赋值为 np.nan 类型转换为 float64ps[1] = np.nanprint(ps)&gt;&gt;&gt;0    1.01    NaN2    1.0dtype: float64</code></pre><h3 id="2-4-4-缺失值函数"><a href="#2-4-4-缺失值函数" class="headerlink" title="2.4.4. 缺失值函数"></a>2.4.4. 缺失值函数</h3><p>Pandas 提供了一些列用于处理确实值的函数或方法。例如发现缺失值，替换缺失值等。</p><h4 id="2-4-4-1-发现缺失值"><a href="#2-4-4-1-发现缺失值" class="headerlink" title="2.4.4.1. 发现缺失值"></a>2.4.4.1. 发现缺失值</h4><p>Pandas 数据结构有两种有效的方法可以发现缺失值：isnull() 和 notnull()。每种方法都返回布尔类型的掩码数据，例如：</p><pre><code>ps = pd.Series([1, np.nan, None])print(ps.isnull())&gt;&gt;&gt;0    False1     True2     Truedtype: bool# 与 isnull() 方法相反print(ps.notnull())&gt;&gt;&gt;0     True1    False2    Falsedtype: bool </code></pre><p>布尔类型掩码数组可以直接作为 Series 或 DataFrame 的索引使用：</p><pre><code>ps = pd.Series([1, np.nan, 2, None])print(ps[ps.notnull()])&gt;&gt;&gt;0    1.02    2.0dtype: float64</code></pre><p>以上操作同样适用于 DataFrame 对象：</p><pre><code>df = pd.DataFrame([1, np.nan, None])print(df.isnull())&gt;&gt;&gt;       00  False1   True2   True </code></pre><h4 id="2-4-4-2-剔除缺失值"><a href="#2-4-4-2-剔除缺失值" class="headerlink" title="2.4.4.2. 剔除缺失值"></a>2.4.4.2. 剔除缺失值</h4><p>dropna() 用于剔除缺失值，它返回一个数组副本。在 Series 上使用它非常简单：</p><pre><code># 剔除缺失值ps = pd.Series([1, np.nan, 2, None])print(ps.dropna())&gt;&gt;&gt;0    1.02    2.0dtype: float64 </code></pre><p>由于 Series 是一维的，任何元素是 NaN 都可以直接删除这一元素（相当于一列），而在 DataFrame 上使用它们时需要设置一些参数， 例如：</p><pre><code>df = pd.DataFrame([[1, np.nan, 2],                    [2, 3, 5],                    [np.nan, 4, 6]])print(df)&gt;&gt;&gt;     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6</code></pre><p>无法从 DataFrame 中单独剔除一个值，要么是剔除缺失值所在的整行，要么是整列。根据实际需求，来剔除整行或整列，DataFrame 中的 dropna() 会有一些参数可以配置。 默认情况下， dropna() 会剔除任何包含缺失值的整行数据：</p><pre><code>print(df.dropna())&gt;&gt;&gt;     0    1  21  2.0  3.0  5</code></pre><p>可以设置按不同的坐标轴剔除缺失值， 比如 axis=1（或 axis=’columns’） 会剔除任何包含缺失值的整列数据：</p><pre><code>print(df.dropna(axis='columns'))&gt;&gt;&gt;   20  21  52  6</code></pre><p>这么做也会把非缺失值一并剔除，因为可能有时候只需要剔除全部是缺失值的行或列，或者绝大多数是缺失值的行或列。可以通过设置 how 或 thresh 参数来满足，它们可以设置剔除行或列缺失值的数量阈值。</p><p>默认设置是 how=’any’， 也就是说只要有缺失值就剔除整行或整列（通过 axis 设置坐标轴）。还可以设置 how=’all’， 这样就只会剔除全部是缺失值的行或列了：</p><pre><code>df[3] = np.nanprint(df)&gt;&gt;&gt;     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaNdf = df.dropna(axis='columns', how='all')print(df)&gt;&gt;&gt;     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6</code></pre><p>还可以通过 thresh 参数设置行或列中非缺失值的最小数量，从而实现更加个性化的配置：</p><pre><code>df = df.dropna(axis='rows', thresh=3)print(df)&gt;&gt;&gt;     0    1  2   31  2.0  3.0  5 NaN</code></pre><p>第 1 行与第 3 行被剔除了， 因为它们只包含两个非缺失值。</p><h4 id="2-4-4-3-填充缺失值"><a href="#2-4-4-3-填充缺失值" class="headerlink" title="2.4.4.3. 填充缺失值"></a>2.4.4.3. 填充缺失值</h4><p>有时可能并不想移除缺失值，而是想把它们替换成有效的数值。 有效的值可能是像 0、 1、 2  那样单独的值，也可能是经过填充（imputation） 或转换（interpolation） 得到的。 虽然你可以通过isnull()  方法建立掩码来填充缺失值， 但是 Pandas 为此专门提供了一个 fillna() 方法， 它将返回填充了缺失值后的数组副本。</p><pre><code>ps = pd.Series([1, np.nan, 2, None], index=list('abcd'))print(ps)&gt;&gt;&gt;a    1.0b    NaNc    2.0d    NaNdtype: float64</code></pre><p>我们将用一个单独的值来填充缺失值， 例如用 -1：</p><pre><code>print(ps.fillna(-1))&gt;&gt;&gt;a    1.0b   -1.0c    2.0d   -1.0dtype: float64</code></pre><p>可以用缺失值前面的有效值来从前往后填充（forward-fill）：</p><pre><code>print(ps.fillna(method='ffill'))&gt;&gt;&gt;a    1.0b    1.0c    2.0d    2.0dtype: float64</code></pre><p>也可以用缺失值后面的有效值来从后往前填充（back-fill） ：</p><pre><code>print(ps.fillna(method='bfill'))a    1.0b    2.0c    2.0d    NaNdtype: float64</code></pre><p>无论是从前往后还是从后往前，NaN 之后或之前如果都是 NaN 则无法实现填充。</p><p>DataFrame 的操作方法与 Series 类似， 只是在填充时需要设置坐标轴参数 axis：</p><pre><code>df = pd.DataFrame([[1, np.nan, 2],                   [2, 3, 5],                   [np.nan, np.nan, np.nan]])print(df)&gt;&gt;&gt;     0    1    20  1.0  NaN  2.01  2.0  3.0  5.02  NaN  NaN  NaN# 从前向后填充行print(df.fillna(method='ffill', axis=1))&gt;&gt;&gt;     0    1    20  1.0  1.0  2.01  2.0  3.0  5.02  NaN  NaN  NaN# 从后向前填充行print(df.fillna(method='bfill', axis=1))&gt;&gt;&gt;     0    1    20  1.0  2.0  2.01  2.0  3.0  5.02  NaN  NaN  NaN</code></pre><p>需要注意的是，假如在从前往后填充时，需要填充的缺失值前面没有值，那么它就仍然是缺失值，这个机制是递归填充。</p><pre><code># 从前向后填充列print(df.fillna(method='ffill', axis=0))&gt;&gt;&gt;     0    1    20  1.0  NaN  2.01  2.0  3.0  5.02  2.0  3.0  5.0# 从后向前填充列print(df.fillna(method='bfill', axis=0))&gt;&gt;&gt;     0    1    20  1.0  3.0  2.01  2.0  3.0  5.02  NaN  NaN  NaN</code></pre><h2 id="2-5-数据加载"><a href="#2-5-数据加载" class="headerlink" title="2.5. 数据加载"></a>2.5. 数据加载</h2><p>Pandas 提供了丰富的数据加载接口，例如 pd.read_csv，pd.read_json，pd.read_sql 等。</p><h3 id="2-5-1-csv-文件数据"><a href="#2-5-1-csv-文件数据" class="headerlink" title="2.5.1. csv 文件数据"></a>2.5.1. csv 文件数据</h3><p>CSV 是逗号分隔值（Comma-Separated Values有时也称为字符分隔值，因为分隔字符也可以不是逗号）的缩写，其文件以纯文本形式存储表格数据（数字和文本）。可以使用记事本直接打开它，或者使用 Excel 打开。</p><p>名为 students.csv 的示例文件内容如下：</p><pre><code>age,id,name20,100,John21,101,Tom19,102,Bill</code></pre><h4 id="2-5-1-1-读取数据"><a href="#2-5-1-1-读取数据" class="headerlink" title="2.5.1.1. 读取数据"></a>2.5.1.1. 读取数据</h4><pre><code># 参数 header 默认值为 0，表示以第一行为列索引# 等价于 df = pd.read_csv('students.csv')df = pd.read_csv('students.csv', header=0)print(df)&gt;&gt;&gt;   age   id  name0   20  100  John1   21  101   Tom2   19  102  Bill</code></pre><p>read_csv() 方法具有非常丰富的参数，常用参数说明如下：</p><ul><li>sep：分隔符，默认是‘,’，CSV文件的分隔符</li><li>header:列名所在 csv 中的行（列索引），默认第一行为列名（默认header=0），header=None 说明第一行不是列名，它会生成新的整数列名。</li><li>names：当 csv 文件没有列名时候，可以用 names 加上要用的列名</li><li>index_col：要用的行名（index），int或sequence或False，默认为 None，即默认添加从 0 开始的 index，若要用第一列作为行索引则 index_col = 0。</li></ul><pre><code># header 为 None，表示 csv 第一行数据作为普通数据df = pd.read_csv('students.csv', header=None)print(df)&gt;&gt;&gt;     0    1     20  age   id  name1   20  100  John2   21  101   Tom3   19  102  Bill# 使用 names 指定列名df = pd.read_csv('students.csv', header=None, names=['a', 'b', 'c'])print(df)     a    b     c0  age   id  name1   20  100  John2   21  101   Tom3   19  102  Bill# 指定 csv 文件第一列为行名df = pd.read_csv('students.csv', header=0, index_col=0)print(df)&gt;&gt;&gt;      id  nameage20   100  John21   101   Tom19   102  Bill</code></pre><h4 id="2-5-1-2-分块读取"><a href="#2-5-1-2-分块读取" class="headerlink" title="2.5.1.2. 分块读取"></a>2.5.1.2. 分块读取</h4><p>read_csv() 的 chunksize 参数支持指定每次读取的行数，返回的是一个可迭代的对象 TextFileReader，这对于读取超大文件特别有用：</p><pre><code># 每次读取两行tfr = pd.read_csv('students.csv', header=0, chunksize=2)print(type(tfr).__name__)&gt;&gt;&gt;TextFileReaderfor chunk in tfr:    print('------------------')    print(chunk)&gt;&gt;&gt;------------------   age   id  name0   20  100  John1   21  101   Tom------------------   age   id  name2   19  102  Bill</code></pre><p>可以看到每次从 TextFileReader 迭代对象读取时都会带上列名。</p><h4 id="2-5-1-3-保存数据"><a href="#2-5-1-3-保存数据" class="headerlink" title="2.5.1.3. 保存数据"></a>2.5.1.3. 保存数据</h4><p>to_csv() 用于写出数据到文件，注意 index 参数指明是否写出行信息：</p><pre><code>studentdf = pd.DataFrame({'id': [100,101,102],                          'name':['John', 'Tom', 'Bill'],                          'age': [20, 21, 19]})studentdf.to_csv('students.csv', index=False)</code></pre><h3 id="2-5-2-其他数据类型"><a href="#2-5-2-其他数据类型" class="headerlink" title="2.5.2. 其他数据类型"></a>2.5.2. 其他数据类型</h3><p>以下列出 Pandas 支持的数据文件类型，以及读取和保存的方法：</p><blockquote><table><thead><tr><th>数据格式类型</th><th>描述</th><th>读取方法</th><th>写出方法</th></tr></thead><tbody><tr><td>text</td><td>CSV</td><td>read_csv</td><td>to_csv</td></tr><tr><td>text</td><td>JSON</td><td>read_json</td><td>to_json</td></tr><tr><td>text</td><td>HTML</td><td>read_html</td><td>to_html</td></tr><tr><td>text</td><td>本地粘贴板</td><td>read_clipboard</td><td>to_clipboard</td></tr><tr><td>binary</td><td>Excel</td><td>read_excel</td><td>to_excel</td></tr><tr><td>binary</td><td>HDF5</td><td>read_hdf</td><td>to_hdf</td></tr><tr><td>binary</td><td>Feather包</td><td>read_feather</td><td>to_feather</td></tr><tr><td>binary</td><td>Parquet</td><td>read_parquet</td><td>to_parquet</td></tr><tr><td>binary</td><td>Msgpack</td><td>read_msgpack</td><td>to_msgpack</td></tr><tr><td>binary</td><td>Stata</td><td>read_stata</td><td>to_stata</td></tr><tr><td>binary</td><td>SAS</td><td>read_sas</td><td></td></tr><tr><td>binary</td><td>Pickle</td><td>read_pickle</td><td>to_pickle</td></tr><tr><td>SQL</td><td>SQL</td><td>read_sql</td><td>to_sql</td></tr><tr><td>SQL</td><td>谷歌BigQuery</td><td>read_gbq</td><td>to_gbq</td></tr></tbody></table></blockquote><h3 id="2-5-3-查看行数据"><a href="#2-5-3-查看行数据" class="headerlink" title="2.5.3. 查看行数据"></a>2.5.3. 查看行数据</h3><p>head(n) 方法用于查看从头部开始的 n 行数据：</p><pre><code>df = pd.read_csv('students.csv', header=0)print(df.head(2))&gt;&gt;&gt;   age   id  name0   20  100  John1   21  101   Tom</code></pre><p>tail(n) 方法用于查看尾部的 n 行数据：</p><pre><code>print(df.tail(2))&gt;&gt;&gt;   age   id  name1   21  101   Tom2   19  102  Bill</code></pre><p>当我们对一个很大的数据文件一无所知时，可以打开前几行观察数据的类型，列标签等。</p><h2 id="2-6-层级索引"><a href="#2-6-层级索引" class="headerlink" title="2.6. 层级索引"></a>2.6. 层级索引</h2><p>一级索引的 Series 看起来很像一维数组，且是单列数组。DataFrame 可以看做有两个索引的二维数组。</p><p>通过层级索引（hierarchical indexing，也被称为多级索引，multi-indexing）配合多个有不同等级（level）的一级索引一起使用，这样就可以将高维数组转换成类似一维 Series 和二维 DataFrame 对象的形式。</p><h3 id="2-6-1-多级索引的-Series"><a href="#2-6-1-多级索引的-Series" class="headerlink" title="2.6.1. 多级索引的 Series"></a>2.6.1. 多级索引的 Series</h3><p>多级索引的 Series，索引是一个二维数组，相当于多个索引决定一个值，类似于 DataFrame 的行索引和列索引：</p><pre><code>ps = pd.Series([90, 80, 95, 91, 92, 88], index=[['John'] * 3 + ['Tom'] * 3,                ['Maths', 'English', 'Chemistry'] * 2])print(ps)&gt;&gt;&gt;John  Maths        90      English      80      Chemistry    95Tom   Maths        91      English      92      Chemistry    88dtype: int64print(ps.index)&gt;&gt;&gt;MultiIndex(levels=[['John', 'Tom'], ['Chemistry', 'English', 'Maths']],         labels=[[0, 0, 0, 1, 1, 1], [2, 1, 0, 2, 1, 0]])</code></pre><p>此时的索引类型为 MultiIndex。MultiIndex 里面的 levels 属性表示索引的等级，可以看到 John 和 Tom 处在第一级，各科课程名称为第二级。</p><p>labels 标签包含了各个索引等级对应的数据的整数索引。</p><pre><code># 使用一级索引查看数据print(ps['Tom'])&gt;&gt;&gt;Maths        91English      92Chemistry    88dtype: int64# 使用切片查看二级索引 Maths 数据print(ps[:, 'Maths'])&gt;&gt;&gt;John    90Tom     91dtype: int64</code></pre><h4 id="2-6-1-1-多级索引-Series-转-DataFrame"><a href="#2-6-1-1-多级索引-Series-转-DataFrame" class="headerlink" title="2.6.1.1. 多级索引 Series 转 DataFrame"></a>2.6.1.1. 多级索引 Series 转 DataFrame</h4><p>unstack() 方法可以快速将一个多级索引的 Series 转化为普通索引的 DataFrame：</p><pre><code>df = ps.unstack()print(type(df).__name__)&gt;&gt;&gt;DataFrameprint(df)&gt;&gt;&gt;      Chemistry  English  MathsJohn         95       80     90Tom          88       92     91</code></pre><p>stack() 方法实现相反的转换：</p><pre><code>print(df.stack())&gt;&gt;&gt;John  Chemistry    95      English      80      Maths        90Tom   Chemistry    88      English      92      Maths        91dtype: int64</code></pre><h4 id="2-6-1-2-增加索引层级"><a href="#2-6-1-2-增加索引层级" class="headerlink" title="2.6.1.2. 增加索引层级"></a>2.6.1.2. 增加索引层级</h4><p>如果我们可以用含多级索引的一维 Series 数据表示二维数据，那么我们就可以用 Series 或 DataFrame 表示三维甚至更高维度的数据。 多级索引每增加一级，就表示数据增加一维， 利用这一特点就可以轻松表示任意维度的数据了。</p><p>假如上面示例中的学生成绩是 2012 年数据，我们要添加 2013 年的数据，只需要增加一个新的索引层级即可：</p><pre><code>newps = pd.DataFrame({'2012': ps, '2013': [98,87,93, 90,91,84]})print(newps)&gt;&gt;&gt;                2012  2013John Maths        90    98     English      80    87     Chemistry    95    93Tom  Maths        91    90     English      92    91     Chemistry    88    84</code></pre><p>当然我们可以使用 stack() 转化为 Series 类型：</p><pre><code>print(newps.stack())&gt;&gt;&gt;John  Maths      2012    90                 2013    98      English    2012    80                 2013    87      Chemistry  2012    95                 2013    93Tom   Maths      2012    91                 2013    90      English    2012    92                 2013    91      Chemistry  2012    88                 2013    84</code></pre><p>这一实现效果令人惊喜。求取各科平均成绩非常简单：</p><pre><code># 求取两年各科平均成绩average = (newps['2013'] + newps['2012']) / 2print(average.unstack())&gt;&gt;&gt;      Chemistry  English  MathsJohn       94.0     83.5   94.0Tom        86.0     91.5   90.5</code></pre><h3 id="2-6-2-创建多级索引"><a href="#2-6-2-创建多级索引" class="headerlink" title="2.6.2. 创建多级索引"></a>2.6.2. 创建多级索引</h3><p>有多种方式创建多级索引 MultiIndex 对象：</p><ul><li>MultiIndex.from_arrays 转换由 arrays 组成的 list 为 MultiIndex</li><li>MultiIndex.from_tuples 转换元组为 MultiIndex</li><li>MultiIndex.from_product 由迭代对象的笛卡尔积生成 MultiIndex</li></ul><h4 id="2-6-2-1-array-转多级索引"><a href="#2-6-2-1-array-转多级索引" class="headerlink" title="2.6.2.1. array 转多级索引"></a>2.6.2.1. array 转多级索引</h4><pre><code># names 指明每个层级的名称arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]pm = pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))print(pm)&gt;&gt;&gt;MultiIndex(levels=[[1, 2], ['blue', 'red']],           labels=[[0, 0, 1, 1], [1, 0, 1, 0]],           names=['number', 'color'])# 查看多级索引的属性print(pm.levels)print(pm.labels)print(pm.names)&gt;&gt;&gt;[[1, 2], ['blue', 'red']][[0, 0, 1, 1], [1, 0, 1, 0]]['number', 'color']</code></pre><h4 id="2-6-2-2-元组转多级索引"><a href="#2-6-2-2-元组转多级索引" class="headerlink" title="2.6.2.2. 元组转多级索引"></a>2.6.2.2. 元组转多级索引</h4><pre><code>tuples = [(1, 'red'), (1, 'blue'),(2, 'red'), (2, 'blue')]pm = pd.MultiIndex.from_tuples(tuples, names=('number', 'color'))print(pm)&gt;&gt;&gt;MultiIndex(levels=[[1, 2], ['blue', 'red']],           labels=[[0, 0, 1, 1], [1, 0, 1, 0]],           names=['number', 'color'])</code></pre><h4 id="2-6-2-3-笛卡尔积转多级索引"><a href="#2-6-2-3-笛卡尔积转多级索引" class="headerlink" title="2.6.2.3. 笛卡尔积转多级索引"></a>2.6.2.3. 笛卡尔积转多级索引</h4><pre><code>numbers = [0, 1, 2]colors = ['green', 'purple']pm = pd.MultiIndex.from_product([numbers, colors], names=['number', 'color'])print(pm)&gt;&gt;&gt;MultiIndex(levels=[[0, 1, 2], ['green', 'purple']],           labels=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],           names=['number', 'color'])</code></pre><p>使用笛卡尔积方式创建 MultiIndex 对象，层次是比较清晰的。</p><pre><code># 增加模拟数据，查看层级和层级名称pf = pd.DataFrame(np.arange(6), index=pm)print(pf)&gt;&gt;&gt;number color0      green   0       purple  11      green   2       purple  32      green   4       purple  5</code></pre><h4 id="2-6-2-4-多级列索引"><a href="#2-6-2-4-多级列索引" class="headerlink" title="2.6.2.4. 多级列索引"></a>2.6.2.4. 多级列索引</h4><p>上面的示例均是创建多级行索引，当然也可以创建多级列索引。</p><pre><code>students = ['John', 'Tom']subjects = ['Maths', 'English', 'Chemistry']# 创建多级行索引index = pd.MultiIndex.from_product([students, subjects], names=['student', 'subject'])# 创建多级列索引columns = pd.MultiIndex.from_product([['2012', '2013'], ['first_half', 'latter_half']],                                      names=['year', 'half'])# 模拟成绩数据，一共是 6 行 4 列pf = pd.DataFrame(99 - np.random.randint(20, size=(6, 4)), index=index, columns=columns)print(pf)&gt;&gt;&gt;year                    2012                   2013half              first_half latter_half first_half latter_halfstudent subjectJohn    Maths             82          81         86          81        English           83          81         88          94        Chemistry         81          85         85          81Tom     Maths             97          80         95          82        English           89          99         94          92        Chemistry         97          92         92          84</code></pre><p>有上例可以看出多级行列索引的创建非常简单。我们可以方便查看各级索引的数据：</p><pre><code># 查询 2012 年上半年成绩数据print(pf['2012','first_half'].unstack())subject  Chemistry  English  MathsstudentJohn            89       88     88Tom             83       84     99</code></pre><p>如果想获取包含多种标签的数据，需要通过对多个维度（姓名、科目等标签）的多次查询才能实现，这时使用多级行列索引进行查询会非常方便。</p><h3 id="2-6-3-多级索引排序和切片"><a href="#2-6-3-多级索引排序和切片" class="headerlink" title="2.6.3. 多级索引排序和切片"></a>2.6.3. 多级索引排序和切片</h3><h4 id="2-6-3-1-Series多级索引排序"><a href="#2-6-3-1-Series多级索引排序" class="headerlink" title="2.6.3.1. Series多级索引排序"></a>2.6.3.1. Series多级索引排序</h4><p>和单级索引一样，多级索引顺序是按照声明顺序确定的，也即是无序的，如果按照索引字母顺序排序，将方便切片操作：</p><pre><code>students = ['Tom', 'John']subjects = ['Maths', 'English', 'Chemistry']index = pd.MultiIndex.from_product([students, subjects], names=['student', 'subject'])ps = pd.Series(np.arange(6) + 90, index=index)print(ps)&gt;&gt;&gt;student  subjectTom      Maths        90         English      91         Chemistry    92John     Maths        93         English      94         Chemistry    95dtype: int32</code></pre><p>可以看到，默认的索引顺序和声明中索引顺序相同，但是使用切片 [start:end:step] 操作时，start 要小于  end，否则返回空对象，如果是乱序的，我们每次切片时都要记住声明的标签顺序，且声明顺序一旦更改，切片相关的代码就要更新，如果对索引进行排序，就不会再出现这类问题：</p><pre><code># 默认使用 level=0 排序 ps = ps.sort_index() print(ps) &gt;&gt;&gt; student  subject John     Chemistry    95         English      94         Maths        93 Tom      Chemistry    92         English      91         Maths        90 dtype: int32 </code></pre><p>经过排序后，可以发现第一级索引和第二季索引都被更新了。 可以使用 level 参数指定优先进行排序的索引层：</p><pre><code># 默认使用 level=0 排序ps = ps.sort_index()print(ps)&gt;&gt;&gt;student  subjectJohn     Chemistry    95         English      94         Maths        93Tom      Chemistry    92         English      91         Maths        90dtype: int32</code></pre><h4 id="2-6-3-2-逆序排序"><a href="#2-6-3-2-逆序排序" class="headerlink" title="2.6.3.2. 逆序排序"></a>2.6.3.2. 逆序排序</h4><p>sort_index() 方法的 ascending 参数可以指定升序或者降序排列，例如 ascending = False 将降序排列：</p><pre><code># 使用 subject 索引排序print(ps.sort_index(level=1))&gt;&gt;&gt;student  subjectJohn     Chemistry    95Tom      Chemistry    92John     English      94Tom      English      91John     Maths        93Tom      Maths        90dtype: int32</code></pre><h4 id="2-6-3-3-Series多级索引访问"><a href="#2-6-3-3-Series多级索引访问" class="headerlink" title="2.6.3.3. Series多级索引访问"></a>2.6.3.3. Series多级索引访问</h4><pre><code># 使用已排序数据print(ps)&gt;&gt;&gt;student  subjectJohn     Chemistry    95         English      94         Maths        93Tom      Chemistry    92         English      91         Maths        90dtype: int32# 直接通过访问属性方式访问print(ps.Tom.Maths)&gt;&gt;&gt;90# 通过数组访问方式，这类似于 2 维的 DataFrame 访问方式print(ps.loc['Tom', 'Maths'])&gt;&gt;&gt;90# 切片方式访问print(ps.loc[:, 'Maths'])&gt;&gt;&gt;studentJohn    93Tom     90dtype: int32# 二级切片索引访问print(ps.loc['Tom', 'Chemistry':'English'])&gt;&gt;&gt;student  subjectTom      Chemistry    92         English      91dtype: int32</code></pre><p>使用 loc 或者 iloc 属性进行多级索引操作，应该为所有层级指定索引，例如 ps.loc[:, :]，而不是 ps.loc[:]。</p><h4 id="2-6-3-4-排序直接修改"><a href="#2-6-3-4-排序直接修改" class="headerlink" title="2.6.3.4. 排序直接修改"></a>2.6.3.4. 排序直接修改</h4><p>以上示例排序结果不对对象直接修改，如果需要结果直接作用在排序对象上，可以传入 inplace = True，此时无返回值。</p><pre><code>ps.sort_index(level=1, inplace=True)print(ps)&gt;&gt;&gt;student  subjectJohn     Chemistry    95Tom      Chemistry    92John     English      94Tom      English      91John     Maths        93Tom      Maths        90dtype: int32</code></pre><h4 id="2-6-3-5-DataFrame-多级索引排序"><a href="#2-6-3-5-DataFrame-多级索引排序" class="headerlink" title="2.6.3.5. DataFrame 多级索引排序"></a>2.6.3.5. DataFrame 多级索引排序</h4><p>与 Series 对象类似，DataFrame 同样支持多级索引的排序，唯一不同点在于它有行索引和列索引，可以接受 axis 参数：</p><ul><li>axis = 0，对行索引进行排序，Series 只有行索引，所以 axis 永远为 0.</li><li>axis = 1，对列索引进行排序。</li></ul><pre><code>students = ['Tom', 'John']subjects = ['Maths', 'English', 'Chemistry']columns = pd.MultiIndex.from_product([['2013', '2012'], ['first_half', 'latter_half']],                                      names=['year', 'half'])# 使用固定的模拟成绩数据，以观察排序影响pf = pd.DataFrame(75 + np.arange(24).reshape(6, 4), index=index, columns=columns)print(pf)&gt;&gt;&gt;year                     2013                   2012half              latter_half first_half latter_half first_halfstudent subjectTom     Maths              75         76          77         78        English            79         80          81         82        Chemistry          83         84          85         86John    Maths              87         88          89         90        English            91         92          93         94        Chemistry          95         96          97         98</code></pre><p>我们使用上面的示例数据，为了查看排序效果，我们把所有索引标签的顺序都颠倒了。</p><pre><code># 行标签排序print(pf.sort_index(axis=0))&gt;&gt;&gt;year                     2013                   2012half              latter_half first_half latter_half first_halfstudent subjectJohn    Chemistry          95         96          97         98        English            91         92          93         94        Maths              87         88          89         90Tom     Chemistry          83         84          85         86        English            79         80          81         82        Maths              75         76          77         78</code></pre><p>行标签排序后，对列标签顺序无影响，同样列标签排序对行标签顺序无影响：</p><pre><code># 列标签排序print(pf.sort_index(axis=1))&gt;&gt;&gt;year                    2012                   2013half              first_half latter_half first_half latter_halfstudent subjectTom     Maths             78          77         76          75        English           82          81         80          79        Chemistry         86          85         84          83John    Maths             90          89         88          87        English           94          93         92          91        Chemistry         98          97         96          95# 同时对行和列排序sorted_pf = pf.sort_index(axis=0).sort_index(axis=1)print(sorted_pf)&gt;&gt;&gt;year                    2012                   2013half              first_half latter_half first_half latter_halfstudent subjectJohn    Chemistry         98          97         96          95        English           94          93         92          91        Maths             90          89         88          87Tom     Chemistry         86          85         84          83        English           82          81         80          79        Maths             78          77         76          75</code></pre><p>无论是行排序还是列排序，均对行或列的所有层级标签依次进行了排序，我们当然可以使用 level 指定优先排序的索引层：</p><pre><code># 优先使用 subject 排序print(pf.sort_index(axis=0, level=1))&gt;&gt;&gt;year                     2013                   2012half              latter_half first_half latter_half first_halfstudent subjectJohn    Chemistry          95         96          97         98Tom     Chemistry          83         84          85         86John    English            91         92          93         94Tom     English            79         80          81         82John    Maths              87         88          89         90Tom     Maths              75         76          77         78# # 优先使用半学期 half 排序print(pf.sort_index(axis=1, level=1))&gt;&gt;&gt;year                    2012       2013        2012        2013half              first_half first_half latter_half latter_halfstudent subjectTom     Maths             78         76          77          75        English           82         80          81          79        Chemistry         86         84          85          83John    Maths             90         88          89          87        English           94         92          93          91        Chemistry         98         96          97          95</code></pre><h4 id="2-6-3-6-DataFrame多级索引访问"><a href="#2-6-3-6-DataFrame多级索引访问" class="headerlink" title="2.6.3.6. DataFrame多级索引访问"></a>2.6.3.6. DataFrame多级索引访问</h4><p>DataFrame 不支持属性访问方式。所以通常使用 loc 显式索引方式访问：</p><pre><code># 使用已排序数据pf.sort_index(inplace=True)print(pf)&gt;&gt;&gt;year                     2013                   2012half              latter_half first_half latter_half first_halfstudent subjectJohn    Chemistry          95         96          97         98        English            91         92          93         94        Maths              87         88          89         90Tom     Chemistry          83         84          85         86        English            79         80          81         82        Maths              75         76          77         78# 访问 Tom 的各科成绩print(pf.loc['Tom', :])&gt;&gt;&gt;year             2013                   2012half      latter_half first_half latter_half first_halfsubjectChemistry          83         84          85         86English            79         80          81         82Maths              75         76          77         78# 查看 Tom 的 2012 年各科成绩print(pf.loc['Tom', :]['2012'])&gt;&gt;&gt;  half       latter_half  first_halfsubjectChemistry           85          86English             81          82Maths               77          78# 查看 Tom 的 2012 年下半年各科成绩# 等价于 print(pf.loc['Tom', '2012']['latter_half'])print(pf.loc['Tom', :]['2012']['latter_half'])&gt;&gt;&gt;  subjectChemistry    85English      81Maths        77Name: latter_half, dtype: int32</code></pre><p>注意体会 DataFrame 的数组访问方式，第一维索引的形式有几种：</p><ul><li>[‘Tom’, ‘2012’]：指定行索引和列索引</li><li>[‘Tom’, ‘Maths’]：均指定行索引</li><li>[‘Tom’, :]：均指定行索引</li></ul><p>显然第一维索引无法指定的列索引的第二层索引，就要通过增加第二维索引来访问，例如 [‘Tom’, ‘2012’][‘latter_half’]。</p><h3 id="2-6-4-索引调整和重置"><a href="#2-6-4-索引调整和重置" class="headerlink" title="2.6.4. 索引调整和重置"></a>2.6.4. 索引调整和重置</h3><p>我们可以通过对象的 index 和 columns 属性更新行或列标签。也可以调整索引的顺序。</p><h4 id="2-6-4-1-reindex"><a href="#2-6-4-1-reindex" class="headerlink" title="2.6.4.1. reindex"></a>2.6.4.1. reindex</h4><p>reindex() 是 pandas 对象的一个重要方法，其作用是在当前对象基础上创建一个新索引的新对象。它通常和 set_index() 配合使用：</p><pre><code>students = ['Tom', 'John']subjects = ['Maths', 'English', 'Chemistry']index = pd.MultiIndex.from_product([students, subjects], names=['student', 'subject'])ps = pd.Series(np.arange(6) + 90, index=index)# 重制索引flat_ps = ps.reset_index()print(flat_ps)&gt;&gt;&gt;  student    subject   00     Tom      Maths  901     Tom    English  912     Tom  Chemistry  923    John      Maths  934    John    English  945    John  Chemistry  95# 逆向转换print(flat_ps.set_index(['student','subject']))&gt;&gt;&gt;student subjectTom     Maths      90        English    91        Chemistry  92John    Maths      93        English    94        Chemistry  95</code></pre><p>可以传入 drop = True 丢弃所有索引，此时变为 Series 对象，只保留数据：</p><pre><code>flat_ps = ps.reset_index(drop = True)print(flat_ps)&gt;&gt;&gt;0    901    912    923    934    945    95dtype: int32</code></pre><h3 id="2-6-5-多级索引数据统计"><a href="#2-6-5-多级索引数据统计" class="headerlink" title="2.6.5. 多级索引数据统计"></a>2.6.5. 多级索引数据统计</h3><p>前面已经介绍过一些 Pandas 自带的数据累计方法，比如 mean()、sum() 和 max()。而对于层级索引数据，可以设置参数 level 实现对数据子集的累计操作。</p><p>首先我们准备如下用于统计的带有多级索引的数据：</p><pre><code># Series 类型的数据student  subject         # 行标签名Tom      Maths        90         English      91         Chemistry    92John     Maths        93         English      94         Chemistry    95dtype: int32print(ps.index)&gt;&gt;&gt;MultiIndex(levels=[['John', 'Tom'], ['Chemistry', 'English', 'Maths']],           labels=[[1, 1, 1, 0, 0, 0], [2, 1, 0, 2, 1, 0]],           names=['student', 'subject'])</code></pre><p>可以使用 level 指定要统计的行标签名或者整数索引，来进行统计：</p><pre><code>print(ps.mean(level='student')) # 等价于 ps.mean(level=0)&gt;&gt;&gt;studentJohn    94  # (93+94+95) / 3 = 94Tom     91  # (90+91+92) / 3 = 91dtype: int32</code></pre><p>结合 axis 参数， 就可以对 DataFrame 列索引进行类似的统计操作：</p><pre class="line-numbers language-jw200107"><code class="language-jw200107"># 准备以下 DataFrame 数据year                     2013                   2012half              latter_half first_half latter_half first_halfstudent subjectJohn    Chemistry          95         96          97         98        English            91         92          93         94        Maths              87         88          89         90Tom     Chemistry          83         84          85         86        English            79         80          81         82        Maths              75         76          77         78# 查看多级索引信息print(pf.index)>>>MultiIndex(levels=[['John', 'Tom'], ['Chemistry', 'English', 'Maths']],           labels=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],           names=['student', 'subject'])# 获取每个学生的平均成绩，axis=0 指定对行统计print(pf.mean(level='student', axis=0))>>>year           2013                   2012half    latter_half first_half latter_half first_halfstudentJohn             91         92          93         94Tom              79         80          81         82# 获取年平均成绩，axis=1 指定对列统计print(pf.mean(level='year', axis=1))>>>year               2012  2013student subjectJohn    Chemistry  97.5  95.5        English    93.5  91.5        Maths      89.5  87.5Tom     Chemistry  85.5  83.5        English    81.5  79.5        Maths      77.5  75.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- matplotlib</title>
      <link href="/2020/01/06/20200106-data-analysis-matplotlib/"/>
      <url>/2020/01/06/20200106-data-analysis-matplotlib/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>matplotlib 是 python 中一个非常强大的 2D 函数绘图模块，它提供了子模块 pyplot 和 pylab 。pylab 是对 pyplot 和 numpy 模块的封装，更适合在 IPython 交互式环境中使用。</p><p>经典参考：<a href="https://www.cnblogs.com/vamei/archive/2013/01/30/2879700.html">绘图: matplotlib核心剖析</a></p><p>对于一个项目来说，官方建议分别导入使用，这样代码更清晰，即：</p><pre><code>import numpy as npimport matplotlib.pyplot as plt</code></pre><p>而不是</p><pre><code>import pylab as pl </code></pre><h2 id="3-1-基本绘图流程"><a href="#3-1-基本绘图流程" class="headerlink" title="3.1. 基本绘图流程"></a>3.1. 基本绘图流程</h2><p>这里以绘制正余弦函数图像为例。</p><pre><code># 分别导入 numpy 和 pyplot 模块import numpy as npimport matplotlib.pyplot as plt# 生成 X 坐标，256个采样值足够图像平滑X = np.linspace(-np.pi, np.pi, 256, endpoint=True)# 生成 Y 坐标C,S = np.cos(X), np.sin(X)# 绘制正余弦plt.plot(X,S)plt.plot(X,C)# 显示图像plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincos0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincos0.png" alt="sincos0"></a></p><p>matplotlib 默认绘制的正余弦函数图像</p><h3 id="3-1-1-默认配置"><a href="#3-1-1-默认配置" class="headerlink" title="3.1.1. 默认配置"></a>3.1.1. 默认配置</h3><p>matplotlib 的相关配置主要包括以下几种，用户可以自定义它们：</p><ul><li>图片大小和分辨率（dpi）</li><li>线宽、颜色、风格</li><li>坐标轴、坐标轴以及网格的属性</li><li>文字与字体属性。</li></ul><p>所有的默认属性均保存在 matplotlib.rcParams 字典中。</p><h4 id="3-1-1-1-默认配置概览"><a href="#3-1-1-1-默认配置概览" class="headerlink" title="3.1.1.1. 默认配置概览"></a>3.1.1.1. 默认配置概览</h4><pre><code>X = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)# 创建一个宽10，高8 英寸（inches，1inch = 2.54cm）的图，并设置分辨率为72 (每英寸像素点数)plt.figure(figsize=(10, 8), dpi=72)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）plt.subplot(1,1,1)# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plt.plot(X, S, color="orange", linewidth=1.0, linestyle="-")# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plt.plot(X, C, color="blue", linewidth=1.0, linestyle="-")# 设置 x轴的上下限plt.xlim(-np.pi, np.pi)# 设置 x轴记号plt.xticks(np.linspace(-4, 4, 9, endpoint=True))# 设置 y轴的上下限plt.ylim(-1.0, 1.0)# 设置 y轴记号plt.yticks(np.linspace(-1, 1, 5, endpoint=True))# 在屏幕上显示plt.show()</code></pre><p>我们可以依次改变上面的值，观察不同属性对图像的影响。</p><h4 id="3-1-1-2-图像大小等"><a href="#3-1-1-2-图像大小等" class="headerlink" title="3.1.1.2. 图像大小等"></a>3.1.1.2. 图像大小等</h4><p>图像就是以「Figure #」为标题的那些窗口。图像编号从 1 开始，与 MATLAB 的风格一致，而于 Python 从 0 开始的索引编号不同。以下参数是图像的属性：</p><blockquote><table><thead><tr><th>参数</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>num</td><td>1</td><td>图像的数量</td></tr><tr><td>figsize</td><td>figure.figsize</td><td>图像的长和宽（英寸）</td></tr><tr><td>dpi</td><td>figure.dpi</td><td>分辨率（像素/英寸）</td></tr><tr><td>facecolor</td><td>figure.facecolor</td><td>绘图区域的背景颜色</td></tr><tr><td>edgecolor</td><td>figure.edgecolor</td><td>绘图区域边缘的颜色</td></tr><tr><td>frameon</td><td>True</td><td>是否绘制图像边缘</td></tr></tbody></table></blockquote><pre><code>import matplotlib as mplfigparams = ['figsize', 'dpi', 'facecolor', 'edgecolor']for para in figparams:    name = 'figure.' + para    print(name + '\t:', mpl.rcParams[name])&gt;&gt;&gt;figure.figsize  : [10.0, 8.0]figure.dpi      : 72.0figure.facecolor        : whitefigure.edgecolor        : white</code></pre><p>我们可以通过查询参数字典来获取默认值。除了图像 num 这个参数，其余的参数都很少修改，num 可以是一个字符串，此时它会显示在图像窗口上。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincosfg0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincosfg0.png" alt="sincosfg0"></a></p><p>plt.figure(figsize=(5, 4), dpi=72)</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincosfg1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincosfg1.png" alt="sincosfg1"></a></p><p>plt.figure(figsize=(10, 8), dpi=36)</p><p>可以看到调整长宽英寸数和分辨率均会影响图片显示大小，以宽度为例，显示大小为 w * dpi / 显示屏幕宽度分辨率。</p><p>14 英寸显示屏是指屏幕对角线长度 35.56cm，如果屏幕宽高比为 16 : 9，则宽和高约为 31cm 和 17.4cm，如果分比率为 1920 * 1080，则上述图像显示宽度的 10 * 36 / 1920 * 31 = 5.8cm，或者 5 * 72 / 1920 * 31 = 5.8cm。</p><p>高 dpi 显示图像更细腻，但是图像尺寸也会变大。使用默认值即可。如果图像非常复杂，为了看清细节，我们可以调整宽高的英寸数。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincosfg2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincosfg2.png" alt="sincosfg1"></a></p><p>plt.figure(figsize=(10, 8), dpi=72, facecolor=’orange’)</p><p>绘图区域的背景色改为橙色的效果，通常不需要改变它。</p><h4 id="3-1-1-3-线条的颜色"><a href="#3-1-1-3-线条的颜色" class="headerlink" title="3.1.1.3. 线条的颜色"></a>3.1.1.3. 线条的颜色</h4><pre><code>plt.plot(X, S, color="orange", linewidth=1.0, linestyle="-") </code></pre><p>上文中，已经观察到线条属性有如下几个：</p><p><strong>颜色</strong>，color/c 参数指定。我们可以通过 help(plt.plot) 查看帮助信息，颜色属性可以通过如下方式指定：</p><ul><li>颜色名，例如 ‘green’。</li><li>16进制的RGB值 ‘#008000’，或者元组类型 RGBA (0,1,0,1)。</li><li>灰度值，例如 ‘0.8’。</li><li>颜色缩写字符，例如 ‘r’ 表示 ‘red’</li></ul><p>当前支持的颜色缩写有：</p><blockquote><table><thead><tr><th>缩写字符</th><th>颜色</th></tr></thead><tbody><tr><td>‘b’</td><td>blue</td></tr><tr><td>‘g’</td><td>green</td></tr><tr><td>‘r’</td><td>red</td></tr><tr><td>‘c’</td><td>cyan</td></tr><tr><td>‘m’</td><td>magenta</td></tr><tr><td>‘y’</td><td>yellow</td></tr><tr><td>‘k’</td><td>black</td></tr><tr><td>‘w’</td><td>white</td></tr></tbody></table></blockquote><pre><code>plt.subplot(2,2,1)plt.plot(X, S, color='orange', linewidth=1.0, linestyle="-")plt.subplot(2,2,2)plt.plot(X, S, color='b', linewidth=1.0, linestyle="-")plt.subplot(2,2,3)plt.plot(X, S, color='0.8', linewidth=1.0, linestyle="-")plt.subplot(2,2,4)plt.plot(X, S, color='#003333', linewidth=1.0, linestyle="-")</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincolor0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincolor0.png" alt="sincolor0"></a></p><p>分别指定四种颜色参数画图</p><h4 id="3-1-1-4-线条的粗细"><a href="#3-1-1-4-线条的粗细" class="headerlink" title="3.1.1.4. 线条的粗细"></a>3.1.1.4. 线条的粗细</h4><p><strong>线宽</strong>，linewidth/lw，浮点值，指定绘制线条宽度点数。</p><pre><code>plt.subplot(2,2,1)plt.plot(X, S, color='blue', linewidth=0.5, linestyle="-")plt.subplot(2,2,2)plt.plot(X, S, color='blue', linewidth=1.0, linestyle="-")plt.subplot(2,2,3)plt.plot(X, S, color='blue', linewidth=1.5, linestyle="-")plt.subplot(2,2,4)plt.plot(X, S, color='blue', linewidth=2.0, linestyle="-")</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sinlw0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sinlw0.png" alt="sinlw0"></a></p><p>四种线宽画图</p><h4 id="3-1-1-5-线条的样式"><a href="#3-1-1-5-线条的样式" class="headerlink" title="3.1.1.5. 线条的样式"></a>3.1.1.5. 线条的样式</h4><p><strong>线条样式</strong>， linestyle/ls 指定绘制线条的样式，当前支持的线条样式表如下：</p><blockquote><table><thead><tr><th>样式缩写</th><th>描述</th></tr></thead><tbody><tr><td>‘-‘</td><td>实线</td></tr><tr><td>‘–’</td><td>短划线</td></tr><tr><td>‘-.’</td><td>点划线</td></tr><tr><td>‘:’</td><td>虚线</td></tr></tbody></table></blockquote><pre><code>linestyles = ['-', '--', '-.', ':']for i in range(1, 5, 1):    plt.subplot(2,2,i)    plt.plot(X, S, color='blue', linewidth=1.0, linestyle=linestyles[i-1])</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sinls0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sinls0.png" alt="sinls0"></a></p><p>四种线条样式画图</p><h4 id="3-1-1-6-线条的标记"><a href="#3-1-1-6-线条的标记" class="headerlink" title="3.1.1.6. 线条的标记"></a>3.1.1.6. 线条的标记</h4><p><strong>标记</strong>，marker，可以使用标记代替 linestyle 画图。常用标记如下：</p><blockquote><table><thead><tr><th>标记缩写</th><th>描述</th></tr></thead><tbody><tr><td>‘.’</td><td>point marker</td></tr><tr><td>‘,’</td><td>pixel marker</td></tr><tr><td>‘o’</td><td>circle marker</td></tr><tr><td>‘v’</td><td>triangle_down marker</td></tr><tr><td>‘^’</td><td>triangle_up marker</td></tr><tr><td>‘&lt;’</td><td>triangle_left marker</td></tr><tr><td>‘&gt;’</td><td>triangle_right marker</td></tr><tr><td>‘1’</td><td>tri_down marker</td></tr><tr><td>‘2’</td><td>tri_up marker</td></tr><tr><td>‘3’</td><td>tri_left marker</td></tr><tr><td>‘4’</td><td>tri_right marker</td></tr><tr><td>‘s’</td><td>square marker</td></tr><tr><td>‘p’</td><td>pentagon marker</td></tr><tr><td>‘*’</td><td>star marker</td></tr><tr><td>‘h’</td><td>hexagon1 marker</td></tr><tr><td>‘H’</td><td>hexagon2 marker</td></tr><tr><td>‘+’</td><td>plus marker</td></tr><tr><td>‘x’</td><td>x marker</td></tr><tr><td>‘D’</td><td>diamond marker</td></tr><tr><td>‘d’</td><td>thin_diamond marker</td></tr><tr><td>‘|’</td><td>vline marker</td></tr><tr><td>‘_’</td><td>hline marker</td></tr></tbody></table></blockquote><pre><code># 降低X坐标数量，以观察标记的作用X = np.linspace(-np.pi, np.pi, 56, endpoint=True)......markers = ['.', ',', 'o', 'v']for i in range(1, 5, 1):    plt.subplot(2,2,i)    plt.plot(X, S, color='blue', linewidth=0.0, marker=markers[i-1])</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sinmark0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sinmark0.png" alt="sinmark0"></a></p><p>四种标记画图</p><h4 id="3-1-1-7-图片边界"><a href="#3-1-1-7-图片边界" class="headerlink" title="3.1.1.7. 图片边界"></a>3.1.1.7. 图片边界</h4><p>上述图像在 Y 轴上会和边界重合，我们可以调整轴的上下限来调整曲线在图像中的位置。</p><pre><code># 设置 x轴的上下限 plt.xlim(-np.pi, np.pi) # 设置 y轴的上下限 plt.ylim(-1.0, 1.0) # 扩展 y轴的上下限 10% plt.ylim(-1.1, 1.1) </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincosadjust.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincosadjust.png" alt="sincosadjust"></a></p><p>扩展Y轴上下10%对比图</p><p>一个可重用的设置边界的扩展函数如下：</p><pre><code>def scope_adjust(X, axis='X', scale=0.1):    xmin, xmax = X.min(), X.max()    dx = (xmax - xmin) * scale    if axis == 'X':        plt.xlim(xmin - dx, xmax + dx)    else:        plt.ylim(xmin - dx, xmax + dx)# 扩展 x 轴边界 10%def xscope_adjust(X):    scope_adjust(X, 'X')# 扩展 y 轴边界 10%def yscope_adjust(Y):    scope_adjust(Y, 'Y')</code></pre><h4 id="3-1-1-8-坐标记号标签"><a href="#3-1-1-8-坐标记号标签" class="headerlink" title="3.1.1.8. 坐标记号标签"></a>3.1.1.8. 坐标记号标签</h4><p>当讨论正弦和余弦函数的时候，通常希望知道函数在 ±π 和 ±π/2 的值。这样看来，当前的设置就不那么理想了。默认坐标记号总是位于整的分界点处，例如 1,2,3或者0.1,0.2处。</p><p>我们要在 x = π 处做记号，就要使用 xticks() 和 yticks() 函数：</p><pre><code># 设置 x轴记号plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])# 设置 y轴记号plt.yticks([-1, 0, +1])</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincoslabel0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincoslabel0.png" alt="sincoslabel"></a></p><p>设置 x轴和 y轴记号</p><p>记号现在没问题了，不过标签却不大符合期望。我们可以把 3.142 当做是 π，但毕竟不够精确。当我们设置记号的时候，我们可以同时设置记号的标签。注意这里使用了 LaTeX 数学公式语法。</p><pre><code># 设置 x轴记号和标签plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],           [r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])# 设置 y轴记号和标签plt.yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$'])</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincoslabel1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincoslabel1.png" alt="sincoslabel"></a></p><p>设置 x轴和 y轴记号和标签</p><h4 id="3-1-1-9-移动脊柱-坐标轴"><a href="#3-1-1-9-移动脊柱-坐标轴" class="headerlink" title="3.1.1.9. 移动脊柱(坐标轴)"></a>3.1.1.9. 移动脊柱(坐标轴)</h4><p>坐标轴线和上面的记号连在一起就形成了脊柱（Spines，一条线段上有一系列的凸起，很像脊柱骨），它记录了数据区域的范围。它们可以放在任意位置，不过至今为止，我们都把它放在图的四边。</p><p>实际上每幅图有四条脊柱（上下对应 x坐标轴，左右对应 y坐标轴），为了将脊柱放在图的中间，我们必须将其中的两条（上和左）设置为无色，然后调整剩下的两条到合适的位置，这里为坐标轴原点。</p><pre><code>ax = plt.gca()ax.spines['left'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data', 0))ax.yaxis.set_ticks_position('right')ax.spines['right'].set_position(('data', 0))</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincospine.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincospine.png" alt="sincospine"></a></p><p>移动脊柱后的效果图</p><h4 id="3-1-1-10-添加图例"><a href="#3-1-1-10-添加图例" class="headerlink" title="3.1.1.10. 添加图例"></a>3.1.1.10. 添加图例</h4><p>我们在图的左上角添加一个图例。为此，我们只需要在 plot 函数里以键值的形式增加一个参数。</p><pre><code>plt.plot(X, S, color='orange', linewidth=1.0, linestyle='-', label='sin(x)')plt.plot(X, C, color='blue', linewidth=1.0, linestyle='-', label='cos(x)')plt.legend(loc='upper left', fontsize='large')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincoslegend.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincoslegend.png" alt="sincoslegend"></a></p><p>添加图例后的效果图</p><h4 id="3-1-1-11-特殊点做注释"><a href="#3-1-1-11-特殊点做注释" class="headerlink" title="3.1.1.11. 特殊点做注释"></a>3.1.1.11. 特殊点做注释</h4><pre><code>t = 2 * np.pi / 3# 两个坐标点，画一条竖线plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=1.5, linestyle="--")# 在竖线一端画一个点，颜色 blue，30个像素宽plt.scatter([t,],[np.cos(t),], 30, color ='blue')# 在特定点添加注释plt.annotate(r'$\sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',             xy=(t,np.sin(t)), xycoords='data',             xytext=(+10, +30), textcoords='offset points', fontsize=16,             arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2"))plt.plot([t,t],[0,np.sin(t)], color ='orange', linewidth=1.5, linestyle="--")plt.scatter([t,],[np.sin(t),], 30, color ='orange')plt.annotate(r'$\cos(\frac{2\pi}{3})=-\frac{1}{2}$',             xy=(t, np.cos(t)), xycoords='data',             xytext=(-90, -50), textcoords='offset points', fontsize=16,             arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2")) </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sincosmark.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/sincosmark.png" alt="sincosmark"></a></p><p>为特殊点添加注释</p><h3 id="3-1-2-各类参数的表示"><a href="#3-1-2-各类参数的表示" class="headerlink" title="3.1.2. 各类参数的表示"></a>3.1.2. 各类参数的表示</h3><h4 id="3-1-2-1-尺寸"><a href="#3-1-2-1-尺寸" class="headerlink" title="3.1.2.1. 尺寸"></a>3.1.2.1. 尺寸</h4><p>为了理解 matplotlib 中的尺寸先关参数，先介绍几个基本概念：</p><ul><li>inch，英寸，1英寸约等于 2.54cm，它是永恒不变的。</li><li>point，点，缩写为 pt，常用于排版印刷领域。字体大小常称为“磅”，“磅”指的是 point  的音译发音，正确的中文译名应为“点”或“点数”，和重量单位没有任何关系。它是一种固定长度的度量单位，大小为1/72英寸，1 inch = 72  points。A4 纸宽度为 8.27 英寸，595 pt。</li><li>pixel，像素，缩写为 px。像素有两个概念，图片中的像素，它是一个bits序列，比如bmp文件中一个8bits  的0-255的灰度值描述了一个像素点，没有物理大小。 另一个概念是指显示屏或者摄像机的像素，一个像素由RGB  3个显示单元组成，它的物理大小并不是一样的，它的尺寸不是一个绝对值。计算机显示屏可以调整屏幕分辨率，其实是通过算法转换的，比如用四个像素表示原一个像素，那么垂直和水平分辨率就各降低了一半。</li><li>分辨率/屏幕分辨率：横纵2个方向的像素（pixels）数量，常见取值 1024<em>768 ，1920</em>1080。在Windows中 一张基于存储像素值的图片(例如BMP，PNG，JPG等格式)的分辨率也可以这样表示。</li><li>图像分辨率：在图像处理领域，图像分辨率是指每英寸图像内的像素点数。它的单位是 PPI（像素每英寸，pixels per inch），<strong>图像分辨率参数通常用于照相机和摄影机等摄录设备，而不是图片本身</strong>，图片本身只有像素，而像素在1:1比例下查看，对应显示设备的1个像素。</li><li>DPI(Dots Per Inch)，打印分辨率，也称为打印精度，单位每英寸点数。也即每英寸打印的墨点数，普通喷墨打印机在 300-500 DPI，激光打印机可以达到 2000 DPI。</li></ul><p>了解了这些概念，我们就可以理解几种常见情况了：</p><p><strong>0.图片中dpi和图像分辨率</strong></p><p>我们已经强调，图像分辨率参数通常用于照相机和摄影机等摄录设备，而不是图片本身。但是很多图片格式，例如 jpg 文件通过 windows 可以查看文件属性中有 96 dpi 字样，又是什么意思呢？</p><p>参考 <a href="https://convert.town/image-dpi">图片DPI</a>，图片中的 dpi 值保存在图片文件格式头部的某个字段，它仅仅是一个数值，用于被某些设备读取做图片处理的参考，例如打印机，在打印时每英寸打印多少个像素点。</p><p>JPG, PNG, TIF, BMP 和 ICO 均支持设置图片文件的 dpi 参数。该参数不影响图片的分辨率，分辨率与像素数量有关。</p><p><strong>1.图片像素和屏幕显示大小</strong></p><p>一张图片在屏幕上显示的大小是由图片像素数和屏幕尺寸以及屏幕分辨率共同决定。例如一张图片分辨率是640x480，这张图片在屏幕上默认按1:1显示，水平方向有640个像素点，垂直方向有480个像素点。</p><p>14英寸的16:9屏幕，也即显示屏对角线长度 35.56cm = 14 inch * 2.54cm/inch，屏幕宽高比为 16 :  9，根据勾股定理宽和高约为 31cm 和 17.4cm，如果分比率为 1920 * 1080，则图像显示宽度 640 / 1920 * 31 = 10.33cm，高度为 480 /1080 * 17.4 = 7.73cm。</p><p>如果分辨率是 1600*900，则显示的图片尺寸约为 640 / 1600 * 31 = 12.40cm 和 480 / 900 * 17.4 = 9.28cm。</p><pre><code>def scatter_create_test_graph():    plt.figure(figsize=(6.4, 4.8), dpi=100)    ax.set_ylim(0, 2)    ax.set_xlim(0, 2)    plt.xticks([0, 1, 2])    plt.yticks([0, 1, 2])    plt.scatter(1, 1)    plt.savefig(filename="test.jpg", format='jpg', facecolor='orange')</code></pre><p>以上代码生成一张640*480的JPG图片，背景为橘黄色。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/640480.jpg"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/640480.jpg" alt="640*480"></a></p><p>一张 640 * 480 的JPG图片</p><p>上图是一张640*480的JPG图片，为了避免网页对图片缩放，可以先保存它并用画图编辑器在<strong>不缩放</strong>的情况下查看它，根据电脑显示屏的分辨率来换算它的宽和高，然后对比用尺子在屏幕上测量的结果，大小是一定不会错的。</p><p>总结：1:1显示时，图片的像素点和屏幕的像素点是一一对应的，在同一台设备上，图片分辨率越高（图片像素越多），图片显示面积越大；图片分辨率越低，图片显示面积越小。对于同一张图片，屏幕分辨率越高，显示越小，屏幕分辨率越低，显示越大。对图片进行放大或者缩小显示时，计算机通过算法对图像进行了像素补足或者压缩。</p><p>图像是否清晰与图像分辨率有关。显示器是否能显示清晰的图片需同时考虑屏幕尺寸和分辨率大小，屏幕尺寸相同时，分辨率越高显示越清晰。</p><p><strong>2.图片像素和打印</strong></p><p>DPI(Dots Per Inch)，打印分辨率用于描述打印精度，这里的 Dot 对于使用计算机打印图片来讲就是 Pixel。也即用一个打印墨点打印一个图像像素。通常 300 DPI是照片打印的标准。</p><p>照片规格通常用“寸”表示，它是指照片长方向上的边长英寸数，一般四舍五入取整数表示。</p><table><thead><tr><th>照片规格</th><th>英寸表示</th><th>厘米</th><th>图片像素(最低)</th></tr></thead><tbody><tr><td>5寸</td><td>5 * 3</td><td>12.7 * 8.9</td><td>1200 * 840</td></tr><tr><td>6寸</td><td>6 * 4</td><td>15.2 * 10.2</td><td>1440 * 960</td></tr><tr><td>7寸</td><td>7 * 5</td><td>17.8 * 12.7</td><td>1680 * 1200</td></tr><tr><td>8寸</td><td>8 * 6</td><td>20.3 * 15.2</td><td>1920 * 1440</td></tr><tr><td>10寸</td><td>10 * 8</td><td>25.4 * 20.3</td><td>2400 * 1920</td></tr><tr><td>12寸</td><td>12 * 10</td><td>30.5 * 20.3</td><td>2500 * 2000</td></tr><tr><td>15寸</td><td>15 * 10</td><td>38.1 * 25.4</td><td>3000 * 2000</td></tr></tbody></table><p>图片像素的要求为何是最低呢？因为当图片过大时，打印驱动会帮我们压缩像素来适应打印机的DPI要求，但是如果图片像素不足于一个像素对应一个墨点，驱动就要进行像素插值，导致图片模糊。</p><p><strong>3.matplotlib中的dpi</strong>，matplotlib 不是打印机，为何需要 DPI 参数？实际上在 matplotlib 中，figure 对象被当作一张打印纸，而 matplotlib 的绘图引擎(backend)就是打印机。</p><p>图片的数字化，也即将图片存储为数据有两种方案：</p><ul><li>位图，也被称为光栅图。即是以自然的光学的眼光将图片看成在平面上密集排布的点的集合。每个点发出的光有独立的频率和强度，反映在视觉上，就是颜色和亮度。这些信息有不同的编码方案，最常见的就是RGB。根据需要，编码后的信息可以有不同的位(bit)数——位深。位数越高，颜色越清晰，对比度越高；占用的空间也越大。另一项决定位图的精细度的是其中点的数量。一个位图文件就是所有构成其的点的数据的集合，它的大小自然就等于点数乘以位深。位图格式是一个庞大的家族，包括常见的JPEG/JPG, GIF, TIFF, PNG, BMP。</li><li>矢量图。它记录其中展示的模式而不是各个点的原始数据。它将图片看成各个“对象”的组合，用曲线记录对象的轮廓，用某种颜色的模式描述对象内部的图案（如用梯度描述渐变色）。比如一张留影，被看成各个人物和背景中各种景物的组合。这种更高级的视角，正是人类看世界时在意识里的反映。矢量图格式有CGM, SVG, AI (Adobe Illustrator), CDR (CorelDRAW), PDF, SWF, VML等等。</li></ul><p>matplotlib 支持将图像保存为 eps, jpeg, jpg, pdf, pgf, png, ps, raw, rgba, svg, svgz, tif, tiff 格式。如果要生成 jpg 文件就相当于“打印”一张图像到 figure 打印纸上。</p><p>matplotlib 在“打印”位图时需要 DPI 来指示如何把逻辑图形转换为像素。打印纸的大小由 figsize 参数指定，单位 pt(point)，这与现实中的纸张单位一致，而 dpi 参数决定了在 1 inch (72pts) 要生成的像素数。</p><pre><code>plt.figure(figsize=(6.4, 4.8), dpi=100) </code></pre><p>如果 dpi 为 72，那么一个 point 就对应 jpg 中的一个 pixel，如果 dpi 为 100，则一个 point 对应  jpg 中的 100/72 pixels。注意这里没有尺寸(位图图像无法用尺寸描述，只能用分辨率描述)的对应关系，只有个数的对应关系。</p><p>以下关系总是成立：</p><pre><code>1 point == fig.dpi/72 pixels </code></pre><p>matplotlib 在生成矢量图时总是使用72dpi，而忽略用户指定的dpi参数，矢量图中只保存宽和高，也即figsize参数，单位pt。</p><pre><code>&lt;svg height="345pt" version="1.1" viewBox="0 0 460 345" width="460pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;</code></pre><p>一张 figsize=(6.4, 4.8) 参数生成的 svg 图片文件中指定了宽 width = 6.4 * 72 = 460pt，高  height = 4.8 * 72 = 345pt。即便我们认为指定了 dpi = 100，生成的 svg 图片的宽高不会有任何改变。</p><p><strong>dpi对生成位图的影响</strong></p><p>我们知道 fig.dpi 参数对矢量图的大小没有影响，而对位图有影响。考虑如下两张图片：</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/test72.jpg"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/test72.jpg" alt="test72"></a></p><p>plt.figure(figsize=(5, 4), dpi=72)</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/test36.jpg"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/test36.jpg" alt="test36"></a></p><p>plt.figure(figsize=(10, 8), dpi=36)</p><p>图片的宽和高像素数是一致的，但是 dpi = 72 时图片明显清晰，所以 dpi 参数会影响图片中的字体大小和线条粗细，当 dpi 小时，系统会选择小字体和细线条，dpi 大时则相反。</p><h4 id="3-1-2-2-point-和-pixel"><a href="#3-1-2-2-point-和-pixel" class="headerlink" title="3.1.2.2. point 和 pixel"></a>3.1.2.2. point 和 pixel</h4><p>由于以下关系总是成立，强烈建议将 fig.dpi 设置为 72，并保存为 svg 矢量格式，这会为处理一些关于尺寸的函数参数提供方便。此时计算时生成图片时这些参数就会直接对应（从屏幕上观察）到生成的图片上的元素的长宽或者字体大小上。</p><pre><code>1 point == fig.dpi/72 pixels </code></pre><p>这些参数包括 markersize，linewidth，markeredgewidth，scatter中的 s 参数和坐标系统相关参数，例如注释的相对坐标 textcoords。</p><p>这些参数的单位通常为 points。唯一例外的是 scatter() 函数中的 s 参数。</p><p>s 参数可以为一个标量或 array_like，shape(n,)，指定绘制点的大小，默认值 rcParams [‘lines.markersize’]^2。注意这里的平方，所以 s 是指的标记所占面积的像素数。</p><pre><code>plt.figure(figsize=(8,4), dpi=72)plt.plot([0],[1], marker="o", markersize=30)plt.plot([0.2, 1.8], [1, 1], linewidth=30)plt.scatter([2],[1], s=30**2)plt.annotate('plt.plot([0],[1], marker="o", markersize=30)',            xy=(0, 1), xycoords='data',            xytext=(0, 70), textcoords='offset points',fontsize=12,            arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2"))......plt.rcParams['font.sans-serif']=['SimHei']plt.rcParams['axes.unicode_minus'] = False  # 解决保存图像时，负号'-'显示为方块问题plt.annotate('ABC123abc 30号中文字体', xy=(0.2, 1), xycoords='data',             xytext=(-10,-10), textcoords='offset pixels', fontsize=30)plt.savefig(filename="markersize.svg", format='svg')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/markersize.svg"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/markersize.svg" alt="markersize"></a></p><p>scatter 中的 s 参数和 plot 中的 markersize 参数关系</p><p>由上图可以得到以下几点结论：</p><ul><li>scatter 中的 s 参数和 plot 中的 markersize 参数关系为，s = markersize^2，markersize = linewidth。</li><li>s 是指的标记所占面积的像素数。所以可以开根号求出高度或者宽度的 point 值。</li><li>markersize 和 linewidth 单位均是 points，当 dpi 设置为 72 时，它们的单位等同于 pixels。</li><li>可以看到字体大小 fontsize 单位是 points，和 markersize ，linewidth 是一致的。</li><li>dpi 设置为 72 时，textcoords=’offset points’ 和 textcoords=’offset pixels’ 是等价的。</li></ul><p>如果 dpi 设置超过 72，相对于生成的像素增多，图片显示出来会增大，否则显示会变小。</p><p>生成的图像分辨率就是 fig.dpi，Windows 中显示的分辨率为图像的宽和高，对应 dpi * figsize。</p><h4 id="3-1-2-3-颜色"><a href="#3-1-2-3-颜色" class="headerlink" title="3.1.2.3. 颜色"></a>3.1.2.3. 颜色</h4><p>颜色参数通常为 color 或者 c，它们有几种形式，参考 线条的颜色。在不同的函数中，它们格式基本是通用的。</p><h4 id="3-1-2-4-marker"><a href="#3-1-2-4-marker" class="headerlink" title="3.1.2.4. marker"></a>3.1.2.4. marker</h4><p><strong>标记</strong>，marker，可以使用 marker 标记坐标点。所有标记如下：</p><blockquote><table><thead><tr><th>标记缩写</th><th>描述</th></tr></thead><tbody><tr><td>‘.’</td><td>point marker</td></tr><tr><td>‘,’</td><td>pixel marker</td></tr><tr><td>‘o’</td><td>circle marker</td></tr><tr><td>‘v’</td><td>triangle_down marker</td></tr><tr><td>‘^’</td><td>triangle_up marker</td></tr><tr><td>‘&lt;’</td><td>triangle_left marker</td></tr><tr><td>‘&gt;’</td><td>triangle_right marker</td></tr><tr><td>‘1’</td><td>tri_down marker</td></tr><tr><td>‘2’</td><td>tri_up marker</td></tr><tr><td>‘3’</td><td>tri_left marker</td></tr><tr><td>‘4’</td><td>tri_right marker</td></tr><tr><td>‘s’</td><td>square marker</td></tr><tr><td>‘p’</td><td>pentagon marker</td></tr><tr><td>‘*’</td><td>star marker</td></tr><tr><td>‘h’</td><td>hexagon1 marker</td></tr><tr><td>‘H’</td><td>hexagon2 marker</td></tr><tr><td>‘+’</td><td>plus marker</td></tr><tr><td>‘x’</td><td>x marker</td></tr><tr><td>‘D’</td><td>diamond marker</td></tr><tr><td>‘d’</td><td>thin_diamond marker</td></tr><tr><td>‘|’</td><td>vline marker</td></tr><tr><td>‘_’</td><td>hline marker</td></tr></tbody></table></blockquote><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/markers.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/markers.png" alt="markers"></a></p><p>各类标记对应的图形</p><p>matplotlib.markers.MarkerStyle 类定义标记和标记的各种样式。可以看到 1-11 个数字也可作为标记，它们表示的图形中心不对应坐标点，而是图形的一个边对应坐标点。</p><pre><code># print(mpl.markers.MarkerStyle().markers)      # 所有支持的标记print(mpl.markers.MarkerStyle().filled_markers) # 可填充的标记print(mpl.markers.MarkerStyle().fillstyles)     # 填充类型&gt;&gt;&gt;('o', 'v', '^', '&lt;', '&gt;', '8', 's', 'p', '*', 'h', 'H', 'D', 'd', 'P', 'X')('full', 'left', 'right', 'bottom', 'top', 'none')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/markerfill.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/markerfill.png" alt="markerfill"></a></p><p>支持填充的标记使用不同填充样式对应的图形</p><h3 id="3-1-3-matplotlib各类对象"><a href="#3-1-3-matplotlib各类对象" class="headerlink" title="3.1.3. matplotlib各类对象"></a>3.1.3. matplotlib各类对象</h3><p>在 Matplotlib 里面：</p><ul><li>figure（plt.Figure 类的一个实例）可以被看成是一个能够容纳各种坐标轴、图形、文字和标签的容器，好比作画的画布，或者一张打印纸。</li><li>axes（plt.Axes 类的一个实例） 是一个带有刻度和标签的矩形，最终会包含所有可视化的图形元素。</li></ul><p>通常会用变量 fig 表示一个图形实例，用变量 ax 表示一个坐标轴实例或一组坐标轴实例。创建好坐标轴之后， 就可以用 ax.plot 画图了。</p><pre><code>fig = plt.figure()ax = plt.axes()x = np.linspace(0, np.pi*4, 256)ax.plot(x, np.sin(x));plt.plot(x, np.cos(x));plt.show()</code></pre><p>也可以使用 plt.plot() 来作图，它对 ax.plot() 进行了封装。如果要在 figure 上创建多个图像元素，只要重复调用 plot 等画图命令即可。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axplot.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axplot.png" alt="axplot"></a></p><p>使用ax对象和plt.plot绘图</p><h4 id="3-1-3-1-坐标轴"><a href="#3-1-3-1-坐标轴" class="headerlink" title="3.1.3.1. 坐标轴"></a>3.1.3.1. 坐标轴</h4><p>关闭坐标轴标签：</p><pre><code>plt.xticks([]) # 关闭 x 轴标签 plt.yticks([]) # 关闭 y 轴标签 </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axisoff.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axisoff.png" alt="axisoff"></a></p><p>关闭X轴和Y轴标签</p><p>关闭坐标轴将同时关闭标签：</p><pre><code>plt.axis('off') </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axisoffall.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axisoffall.png" alt="axisoffall"></a></p><p>关闭坐标轴</p><p>以下操作等价于关闭 x/y 轴标签：</p><pre><code>frame = plt.gca() # get current axis frame.axes.get_yaxis().set_visible(False) # y 轴不可见 frame.axes.get_xaxis().set_visible(False) # x 轴不可见 </code></pre><p>注意，类似的这些操作需要将其置于 plt.show() 之前 plt.imshow() 之后。</p><p>设置坐标轴区间：</p><pre><code>plt.xlim(xmin, xmax)  #设置坐标轴的最大最小区间 plt.ylim(ymin, ymax)#设置坐标轴的最大最小区间 </code></pre><p>设置图形标签：</p><pre><code>plt.plot(x, np.sin(x)) plt.title("A Sine Curve") # 坐标轴标题 plt.xlabel("x")           # x 轴标签 plt.ylabel("sin(x)")      # y 轴标签 </code></pre><h3 id="3-1-4-annotate注释"><a href="#3-1-4-annotate注释" class="headerlink" title="3.1.4. annotate注释"></a>3.1.4. annotate注释</h3><p>annotate() 注释可以将文本放于任意坐标位置。</p><pre><code>matplotlib.pyplot.annotate(s, xy, *args, **kwargs)</code></pre><ul><li><p>s，要注释的文本字符串</p></li><li><p>xy，(float, float) 要注释的坐标</p></li><li><p>xycoords，指定 xy 坐标系统，默认 data。</p></li><li><p>xytext，(float, float)，注释要放置的坐标，如果不提供则使用 xy。textcoords 参数指定 xytext 如何使用。</p></li><li><p>textcoords，指定 xytext 坐标与 xy 之间的关系。如果不提供，则使用 xycoords。</p></li><li><p>ha /horizontalalignment，水平对齐，和点 xy 的水平对齐关系。取值 ‘center’, ‘right’ 或 ‘left’。</p></li><li><p>va /verticalalignment，垂直对齐，和点 xy 的垂直对齐关系。取值 ‘center’, ‘top’, ‘bottom’, ‘baseline’ 或 ‘center_baseline’。</p></li><li><p>**kwargs    参数可以是  <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">matplotlib.text.Text</a> 中的任意属性，例如 color。</p><table><thead><tr><th>xycoords 值</th><th>坐标系统</th></tr></thead><tbody><tr><td>‘figure points’</td><td>距离图形左下角点数</td></tr><tr><td>‘figure pixels’</td><td>距离图形左下角像素数</td></tr><tr><td>‘figure fraction’</td><td>0,0 是图形左下角，1,1 是右上角</td></tr><tr><td>‘axes points’</td><td>距离轴域左下角的点数量</td></tr><tr><td>‘axes pixels’</td><td>距离轴域左下角的像素数量</td></tr><tr><td>‘axes fraction’</td><td>0,0 是轴域左下角，1,1 是右上角</td></tr><tr><td>‘data’</td><td>使用轴域数据坐标系</td></tr><tr><td>‘polar’</td><td>极坐标</td></tr></tbody></table><table><thead><tr><th>textcoords 取值</th><th>描述</th></tr></thead><tbody><tr><td>‘offset points’</td><td>相对于 xy 进行值偏移(inch)</td></tr><tr><td>‘offset pixels’</td><td>相对于 xy 进行像素偏移</td></tr></tbody></table></li></ul><h4 id="3-1-4-1-注释位置"><a href="#3-1-4-1-注释位置" class="headerlink" title="3.1.4.1. 注释位置"></a>3.1.4.1. 注释位置</h4><pre><code>def annotate():    fig = plt.figure(dpi=72, facecolor='#dddddd')    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 5), ylim=(-3, 5))    plt.rcParams['font.sans-serif']=['SimHei']    t = np.arange(0.0, 5.0, 0.01)    s = np.cos(2 * np.pi * t)    line, = ax.plot(t, s)    # 相对于图像最左下角的偏移像素数，未提供xytext，则表示注释在xy点    ax.annotate('1.figure pixels',                xy=(0, 0), xycoords='figure pixels', color='r', fontsize=16)    # 相对于图像最左下角的偏移点数，由于 dpi=72，这里与'figure pixels' 效果相同    ax.annotate('2.figure points',                xy=(0, 50), xycoords='figure points', color='r', fontsize=16)    # 使用轴域数据坐标系，也即 2,1 相对于坐标原点 (0,0)，注释位置再相对于xy 偏移 xytext    ax.annotate('3.data',                xy=(2, 1), xycoords='data',                xytext=(-15, 25), textcoords='offset points',                arrowprops=dict(facecolor='black', shrink=0.05),                horizontalalignment='right', verticalalignment='top',                color='r')    # 整个图像的左下角为 0,0，右上角为1,1，xy 在[0-1] 之间取值    ax.annotate('4.figure fraction',                xy=(0.0, .95), xycoords='figure fraction',                horizontalalignment='left', verticalalignment='top',                fontsize=16, color='r')    # 0,0 是轴域左下角，1,1 是轴域右上角    ax.annotate('5.axes fraction',                xy=(3, 1), xycoords='data',                xytext=(0.8, 0.95), textcoords='axes fraction',                arrowprops=dict(facecolor='black', shrink=0.05),                horizontalalignment='right', verticalalignment='top',                color='r')    # xy被注释点使用轴域偏移 'axes fraction', xytext使用相对偏移    ax.annotate('6.pixel offset from axes fraction',                xy=(1, 0), xycoords='axes fraction',                xytext=(-20, 20), textcoords='offset pixels',                horizontalalignment='right',                verticalalignment='bottom', color='r')    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/annotatecoords.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/annotatecoords.png" alt="annotatecoords"></a></p><p>使用各类坐标系统进行注释</p><p>对于上图，有几点需要说明：</p><ul><li>matplotlib 中有两个区域，图形区域（整个图形区域，包括灰色和白色两部分）；轴域，上图中的白色部分。</li><li>每个区域有自己的坐标系统，左下角均为 (0, 0)，可以使用点或者像素偏移，或者指定 fraction 坐标，此时右上角坐标值为 (1,1)，整个区域的坐标用[0-1]之间的小数表示。</li><li>xycoords 值中 ‘figure points’ 和 ‘figure pixels’ 相对于图形区域左下角偏移点和像素数。</li><li>xycoords 值中 ‘figure fraction’ 直接指定图形区域的 fraction 小数坐标 。</li><li>xycoords 值中 ‘axes points’，’axes pixels’ 和 ‘axes fraction’ 类似。</li><li>xycoords 值中 ‘data’ 指定使用轴域数据坐标系。</li></ul><h4 id="3-1-4-2-坐标点注释"><a href="#3-1-4-2-坐标点注释" class="headerlink" title="3.1.4.2. 坐标点注释"></a>3.1.4.2. 坐标点注释</h4><pre><code>def scatter_create_annotate_graph():    x = np.array([i for i in range(10)])    y = [0,1,2,3,4,4,3,2,1,0]    plt.figure(figsize=(10,10))    plt.scatter(x, y, marker='s', s = 50)    for x, y in zip(x, y):        plt.annotate('(%s,%s)'%(x,y), xy=(x,y), xytext=(0, -5),                     textcoords = 'offset pixels', ha='left', va='top')    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ano.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/ano.png" alt="ano"></a></p><p>对坐标点进行注释</p><h4 id="3-1-4-3-添加箭头"><a href="#3-1-4-3-添加箭头" class="headerlink" title="3.1.4.3. 添加箭头"></a>3.1.4.3. 添加箭头</h4><p>可以通过参数 arrowprops 在注释文本和注释点之间添加箭头。</p><table><thead><tr><th>arrowprops属性</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>箭头的宽度，以点为单位</td></tr><tr><td>frac</td><td>箭头的头部所占据的比例</td></tr><tr><td>headwidth</td><td>箭头的头部宽度，以点为单位</td></tr><tr><td>shrink</td><td>收缩箭头头部和尾部，使其离注释点和注释文本多一些距离</td></tr></tbody></table><pre><code>def annotate_arrow():    plt.figure(dpi=72)    plt.xticks([0, 1, 2, 3], ['width','headwidth','shrink',''], fontsize=16)    plt.yticks([0, 1, 1.4], ['']*3)    ax = plt.gca()    ax.spines['left'].set_color('none')    ax.spines['top'].set_color('none')    ax.spines['bottom'].set_color('none')    ax.spines['right'].set_color('none')    # 调整箭头的宽度    for i in [1, 2, 4, 6, 8, 10]:        plt.annotate('annotate' + str(i), xy=(0, i/8), xycoords='data',                     arrowprops=dict(facecolor='black', shrink=0.0, width=i, headwidth=20),                     xytext=(50, i/8), textcoords='offset pixels', fontsize=16)    # 调整箭头的箭头宽度    for i in [1, 2, 4, 6, 8, 10]:        plt.annotate('annotate' + str(i), xy=(1, i/8), xycoords='data',                     arrowprops=dict(facecolor='r', edgecolor='r', shrink=0.0,                     width=3, headwidth=i*2),                     xytext=(50, i/8), textcoords='offset pixels', fontsize=16)    # 调整箭头的收缩比    for i in [1, 2, 4, 6, 8, 10]:        plt.annotate('annotate' + str(i), xy=(2, i/8), xycoords='data',                     arrowprops=dict(facecolor='m', edgecolor='m', shrink=0.01 * i,                     width=3, headwidth=20),                     xytext=(50, i/8), textcoords='offset pixels', fontsize=16)    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/annotatearrows.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/annotatearrows.png" alt="annotatearrows"></a></p><p>调节箭头各个参数的效果图</p><h4 id="3-1-4-4-箭头样式"><a href="#3-1-4-4-箭头样式" class="headerlink" title="3.1.4.4. 箭头样式"></a>3.1.4.4. 箭头样式</h4><p>matplotlib 内置了丰富的箭头样式，参考 <a href="https://matplotlib.org/tutorials/text/annotations.html?highlight=arrowprops#annotating-with-arrow">注释箭头</a>。</p><h3 id="3-1-5-绘图风格"><a href="#3-1-5-绘图风格" class="headerlink" title="3.1.5. 绘图风格"></a>3.1.5. 绘图风格</h3><p>可以通过 plt.style 设置绘图风格，它们存放在 plt.style.available 列表中。</p><pre><code>print(mpl.__version__)print(plt.style.available[:5])&gt;&gt;&gt;2.0.2['bmh', 'classic', 'dark_background', 'fivethirtyeight', 'ggplot']</code></pre><p>在 matplotlib 2.0.2 版本上支持 23 中不同的绘图风格。</p><p>如果要恢复默认的绘图风格，请使用 mpl.rcParams.update(mpl.rcParamsDefault)。</p><pre><code>#plt.style.use('classic')          # 定义全局绘图风格plt.figure(figsize=(16,25), dpi=72)index = 1for style in plt.style.available:    with plt.style.context(style): # 使用绘图风格上下文        plt.subplot(6,4,index)        plt.plot([1,2])        plt.scatter(1,2)        plt.title('Style{}:'.format(index) + style)        index+=1plt.show()</code></pre><p>如果使用 plt.style.use(style) 则作用到全局，使用绘图风格上下文管理器（context manager） plt.style.context(style) 临时切换绘图风格。</p><p>一些知名的常用绘图风格：</p><ul><li>classic，matplotlib 仿照 matlab 的经典风格。</li><li>FiveThirtyEight 风格模仿著名网站 FiveThirtyEight（<a href="http://fivethirtyeight.com)/">http://fivethirtyeight.com）</a> 的绘图风格。</li><li>ggplot风格，R 语言的 ggplot 是非常流行的可视化工具。</li><li>bmh风格，源于在线图书  Probabilistic Programming and Bayesian Methods for Hackers（<a href="http://bit.ly/2fDJsKC%EF%BC%89%E3%80%82%E6%95%B4%E6%9C%AC%E4%B9%A6%E7%9A%84%E5%9B%BE%E5%BD%A2%E9%83%BD%E6%98%AF%E7%94%A8">http://bit.ly/2fDJsKC）。整本书的图形都是用</a> Matplotlib 创建的， 通过一组 rc 参数创建了一种引人注目的绘图风格，它被 bmh 风格继承了。</li><li>dark_background 风格：用黑色背景而非白色背景往往会取得更好的效果。它就是为此设计的。</li><li>grayscale 灰度风格：有时可能会做一些需要打印的图形，不能使用彩色。 这时使用它效果最好。</li><li>Seaborn 系列风格，灵感来自 Seaborn 程序库，Seaborn 程序对 Matplotlib 进行了高层的API封装，从而使得作图更加容易。seaborn-whitegrid 带网格显示。</li></ul><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/mplstyles.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/mplstyles.png" alt="mplstyles"></a></p><p>不同绘图风格效果图</p><h4 id="3-1-5-1-带网格作图"><a href="#3-1-5-1-带网格作图" class="headerlink" title="3.1.5.1. 带网格作图"></a>3.1.5.1. 带网格作图</h4><pre><code>plt.style.use('seaborn-whitegrid')fig = plt.figure()ax = plt.axes()  # 绘制坐标轴plt.show() </code></pre><p>seaborn-whitegrid 风格常用来绘制带网格的图。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/mplgrid.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/mplgrid.png" alt="mplgrid"></a></p><p>带网格的作图风格</p><h2 id="3-2-绘制散点图"><a href="#3-2-绘制散点图" class="headerlink" title="3.2. 绘制散点图"></a>3.2. 绘制散点图</h2><h3 id="3-2-1-plot"><a href="#3-2-1-plot" class="headerlink" title="3.2.1. plot"></a>3.2.1. plot</h3><p>plt.plot 通常用来绘制线形图，但是它同样可以绘制散点图。</p><pre><code>fig = plt.figure(figsize=(6,4))x = np.linspace(0, 10, 30)y = np.sin(x)# 等价于 plt.plot(x, y, mark='o', color='blue')plt.plot(x, y, 'ob')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/plot0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/plot0.png" alt="plot"></a></p><p>plot 绘制散点图</p><p>这里把 linestyle 参数改为 mark，参考 <a href="https://mlhowto.readthedocs.io/en/latest/matplot.html#marker">marker</a>。当然我们依然可以指定线型，这样可以绘制线条和散点的组合图：</p><pre><code># 把散点用线条连接 plt.plot(x, y, '-ob') </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/plot1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/plot1.png" alt="plot"></a></p><p>plot 绘制线条和散点图</p><p>plt.plot 支持许多设置线条和散点属性的参数：</p><pre><code>plt.plot(x, y, '-H', color='gray',   # 线条颜色         markersize=15, linewidth=4, # 标记大小，线宽         markerfacecolor='white',    # 标记填充色         markeredgecolor='gray',     # 标记边框色         markeredgewidth=2)          # 标记边框宽度</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/plot2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/plot2.png" alt="plot"></a></p><p>plot 设置线条和散点属性</p><h3 id="3-2-2-scatter"><a href="#3-2-2-scatter" class="headerlink" title="3.2.2. scatter"></a>3.2.2. scatter</h3><p>plt.scatter 与 plt.plot 的主要差别在于， 前者在创建散点图时具有更高的灵活性， 可以单独控制每个散点与数据匹配， 也可以让每个散点具有不同的属性（大小、 表面颜色、 边框颜色等） 。</p><pre><code>scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None,        alpha=None, linewidths=None, verts=None, edgecolors=None,        hold=None, data=None, **kwargs)</code></pre><p>scatter() 专门用于绘制散点图，提供默认值的参数可选，各个参数意义如下：</p><ul><li>x, y：array 类型，shape(n,)，输入的坐标点。</li><li>s ：标量或 array_like，shape(n,)，指定绘制点的大小，默认值 rcParams [‘lines.markersize’]^2。</li><li>c：可以为单个颜色，默认：’b’，可以是缩写颜色的字符串，比如 ‘rgb’，或者颜色序列 [‘c’, ‘#001122’, ‘b’]，长度必须与坐标点 n 相同。</li><li>marker：默认值：’o’，可以为标记的缩写，也可以是类 matplotlib.markers.MarkerStyle 的实例。参考 <a href="https://mlhowto.readthedocs.io/en/latest/matplot.html#marker">marker</a>。</li><li>linewidths：标记外边框的粗细，当个值或者序列。</li><li>alpha：透明度，0 - 1.0 浮点值。</li><li>edgecolors：标记外边框颜色，单个颜色，或者颜色序列。</li></ul><pre><code>def scatter_create_color_graph():    x = [i for i in range(20)]    y = [i for i in range(20)]    plt.figure(figsize=(10, 8), dpi=72)    plt.xticks(x)    plt.yticks(y)    c = np.linspace(0, 0xffffff, 20, endpoint=False)    plt.scatter(x, y, c=c, s=200, marker='o')    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scatterclr.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scatterclr.png" alt="scatterclr"></a></p><p>不同颜色值绘制的散点图</p><pre><code>def scatter_create_markers_graph():    x = np.array([i for i in range(20)])    y = np.array([i for i in range(20)])    plt.figure(1)    plt.xticks(x)    plt.yticks(y)    plt.scatter(x, y, c='orange', s=200, marker='v')    plt.scatter(x + 1, y, c='gray', s=100, marker='^')    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scattermark.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scattermark.png" alt="scattermark"></a></p><p>不同标记大小和颜色绘制的散点图</p><pre><code>def scatter_create_size_graph():    x = np.array([i for i in range(10)])    y = np.array([0] * len(x))    plt.figure(1)    plt.ylim(-0.5, 1.5)    plt.yticks([0, 1])    plt.xticks(x)    sizes = [20 * (n + 1) ** 2 for n in range(len(x))]    plt.scatter(x, y, c='m', s=sizes)    sizes = [20 * (10 - n) ** 2 for n in range(len(x))]    plt.scatter(x, y + 1, c='m', s=sizes)    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scattersz.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scattersz.png" alt="scattersz"></a></p><p>根据坐标调整标记大小</p><pre><code>def scatter_create_random_graph():    x = np.random.randn(100)    y = np.random.randn(100)    plt.figure(1)    plt.scatter(x, y, c='m', marker='p', s=500, alpha=0.6)    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scatterand.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scatterand.png" alt="scatterand"></a></p><p>随机坐标散点图</p><pre><code>def scatter_create_guess_graph():    mu_vec = np.array([0,0])    cov_mat = np.array([[1,0],[0,1]])    X = np.random.multivariate_normal(mu_vec, cov_mat, 1000)    R = X ** 2    R_sum = R.sum(axis = 1)    plt.figure(1)    plt.scatter(X[:,0], X[:,1], color='m', marker='o',                s = 32.*R_sum, edgecolor='black', alpha=0.5)    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scattergaus.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scattergaus.png" alt="scattergaus"></a></p><p>多元高斯分布二维图</p><pre><code>def scatter_create_gradual_graph():    plt.figure(1)    c = np.linspace(0xffff00, 0xffffff, 20, endpoint=False)    for i in range(19,-1,-1):        size = i * 10000 + 10        cval = hex(int(c[i]))[2:]        color = "#" + '0' * (6 - len(cval)) + cval        plt.scatter(0, 0, s=size, c=color)    plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scattergra.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/scattergra.png" alt="scattergra"></a></p><p>同点渐变晕化</p><p>由于 plt.scatter 会对每个散点进行单独的大小与颜色的渲染， 因此渲染器会消耗更多的资源。 而在 plt.plot 中， 散点基本都彼此复制，因此整个数据集中所有点的颜色、 尺寸只需要配置一次。当绘制非常多的点时优先选用 plt.plot。</p><h2 id="3-3-条形图"><a href="#3-3-条形图" class="headerlink" title="3.3. 条形图"></a>3.3. 条形图</h2><p>条形图又称为柱状图，是一种直观描述数据量大小的图。</p><h3 id="3-3-1-垂直条形图"><a href="#3-3-1-垂直条形图" class="headerlink" title="3.3.1. 垂直条形图"></a>3.3.1. 垂直条形图</h3><p>plt.bar 用于画条形图，有以下参数：</p><ul><li>x: 条形图 x 轴坐标，y：条形图的高度</li><li>width：条形图的宽度 默认是0.8</li><li>bottom：条形底部的 y 坐标值 默认是0</li><li>align：center 或 edge，条形图对齐 x 轴坐标中心点还是对齐 x 轴坐标左边缘作图。</li></ul><pre><code># 条形图宽 0.1，填充色 greyplt.bar([1], [2], width=0.1, facecolor='grey')# 条形图宽 0.2，填充色 white，边框颜色 blackplt.bar([2], [3], width=0.2, facecolor='w', edgecolor='black')# 左对齐plt.bar([3], [3], width=0.2, align='edge', facecolor='y')# 画多个条形图，底部抬升 1plt.bar([4,5], [2,2], bottom=1, width=0.2, facecolor='m')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/bar.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/bar.png" alt="bar"></a></p><p>条形图</p><p>我们可以为条形图添加标签和文本说明：</p><pre><code>name_list = ['John','Lily','Bill','Tom']score_list = [80, 90, 78, 95]# tick_label 参数指定标签列表bars = plt.bar([1,2,3,4], score_list, color='grey', width=0.4, tick_label=name_list)# plt.text 在指定坐标添加文本，居中标注for bar in bars:    height = bar.get_height()    plt.text(bar.get_x() + bar.get_width() / 2, height, str(int(height)),             ha="center", va="bottom")plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/bar0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/bar0.png" alt="bar"></a></p><p>添加标签和文本</p><h3 id="3-3-2-堆叠条形图"><a href="#3-3-2-堆叠条形图" class="headerlink" title="3.3.2. 堆叠条形图"></a>3.3.2. 堆叠条形图</h3><p>堆叠的关键操作在 bottom 参数，堆叠在 bottom 之上：</p><pre><code>name_list = ['John','Lily','Bill','Tom']lang_scores = [80, 90, 78, 95]math_scores = [92, 88, 90, 93]x = np.arange(1,5,1)lang_bars = plt.bar(x, lang_scores, color='y', width=0.4, tick_label=name_list,                    label='Language')math_bars = plt.bar(x, math_scores, bottom=lang_scores, width=0.4,                    label='Mathmatics', tick_label = name_list)for i,j in zip(lang_bars, math_bars):    height = i.get_height() + j.get_height()    plt.text(i.get_x() + i.get_width() / 2, height, str(int(height)),             ha="center", va="bottom")plt.ylim(0, 220)plt.legend(loc='upper left')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/bar1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/bar1.png" alt="bar"></a></p><p>堆叠条形图</p><h3 id="3-3-3-并列条形图"><a href="#3-3-3-并列条形图" class="headerlink" title="3.3.3. 并列条形图"></a>3.3.3. 并列条形图</h3><p>并列条形图的关键在于调整第二个条形图的 x 坐标，它等于第一个条形图的坐标加上它的宽度的1/2，再加上自身的宽度的1/2，如果对齐为 edge，则要对应调整坐标：</p><pre><code>lang_bars = plt.bar(x, lang_scores, color='y', width=0.4, tick_label=name_list,                    label='Language')# 调整 x 坐标，为第一个条形图的偏移math_bars = plt.bar([i + 0.4 for i in x], math_scores, width=0.4,                    label='Mathmatics', tick_label = name_list)for i,j in zip(lang_bars, math_bars):    plt.text(i.get_x() + i.get_width() / 2, i.get_height(), str(int(i.get_height())),             ha="center", va="bottom")    plt.text(j.get_x() + j.get_width() / 2, j.get_height(), str(int(j.get_height())),             ha="center", va="bottom")plt.ylim(0, 120)plt.legend(loc='upper left')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/bar2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/bar2.png" alt="bar"></a></p><p>并列条形图</p><h3 id="3-3-4-水平条形图"><a href="#3-3-4-水平条形图" class="headerlink" title="3.3.4. 水平条形图"></a>3.3.4. 水平条形图</h3><p>水平条形图使用 plt.barh 作图，其他参数类似，注意文本标注坐标的调整：</p><pre><code>name_list = ['John','Lily','Bill','Tom']score_list = [80, 90, 78, 95]# tick_label 参数指定标签列表bars = plt.barh([1,2,3,4], score_list, color='grey', height=0.4, tick_label=name_list)# plt.text 在指定坐标添加文本，居中标注for bar in bars:    height = bar.get_height()    plt.text(bar.get_width(), bar.get_y() + height / 2, str(int(bar.get_width())),             ha="left", va="center")plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/barh.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/barh.png" alt="bar"></a></p><p>水平条形图</p><h2 id="3-4-饼图"><a href="#3-4-饼图" class="headerlink" title="3.4. 饼图"></a>3.4. 饼图</h2><p>饼图英文学名为 Sector Graph，又名 Pie Graph。常用于统计学。plt.pie 用于绘制饼图。</p><pre><code>plt.figure()plt.subplot(2,2,1)sizes = [1,2]plt.pie(sizes)plt.subplot(2,2,2)plt.axis('equal')   #使饼图长宽相等sizes = [1,1,1]plt.pie(sizes)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/pie.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/pie.png" alt="pie"></a></p><p>简单饼图</p><p>观察上图，可以看到 plt.pid 如何使用参数 sizes 的，它把个元素相加求出总和，然后各部分除以总和求出占比，然后按比例切分一个圆（Pie），为了使上面的饼图有意义，我们增加标签说明。</p><pre><code>labels = ['English', 'Maths', 'Chemistry']scores = [90, 75, 88]explode = (0, 0, 0.1)plt.pie(scores, explode=explode, labels=labels,        autopct='%1.1f%%', shadow=True, startangle=60)plt.axis('equal')plt.legend(loc="upper right")plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/pie0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/pie0.png" alt="pie"></a></p><p>添加标签的饼图</p><p>一个详细的参数列表如下：</p><ul><li>x       :(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化；</li><li>labels  :(每一块)饼图外侧显示的说明文字；</li><li>explode :(每一块)离开中心距离；</li><li>startangle :起始绘制角度，默认图是从x轴正方向逆时针画起，如设定=90则从y轴正方向画起；</li><li>shadow  : 在饼图下面画一个阴影。默认值：False，即不画阴影；</li><li>labeldistance :label标记的绘制位置,相对于半径的比例，默认值为1.1, 如&lt;1则绘制在饼图内侧；</li><li>autopct :控制饼图内百分比设置,可以使用format字符串，’%1.1f’ 指小数点前后位数(没有用空格补齐)；</li><li>pctdistance :类似于labeldistance,指定autopct的位置刻度,默认值为0.6；</li><li>radius  :控制饼图半径，默认值为1；</li><li>counterclock ：指定指针方向；布尔值，可选参数，默认为：True，即逆时针。将值改为False即可改为顺时针。</li><li>wedgeprops ：字典类型，可选参数，默认值：None。参数字典传递给wedge对象用来画一个饼图。例如：wedgeprops={‘linewidth’:3}设置wedge线宽为3。</li><li>textprops ：设置标签（labels）和比例文字的格式；字典类型，可选参数，默认值为：None。传递给text对象的字典参数。</li><li>center ：浮点类型的列表，可选参数，默认值：(0,0)。图标中心位置。</li><li>frame ：布尔类型，可选参数，默认值：False。如果是true，绘制带有表的轴框架。</li><li>rotatelabels ：布尔类型，可选参数，默认为：False。如果为True，旋转每个label到指定的角度。</li><li>colors ： 自定义颜色表，例如 [‘r’,’g’,’y’,’b’]。</li></ul><h2 id="3-5-直方图"><a href="#3-5-直方图" class="headerlink" title="3.5. 直方图"></a>3.5. 直方图</h2><p>直方图常用于显示数据的区间分布密度，统计概率等。又称为频率直方图。</p><p>频率分布直方图中的横轴表示样本的取值，分为若干组距，纵轴表示频率/组距，所谓频率即落在组距上的样本数。</p><h3 id="3-5-1-一维频率直方图"><a href="#3-5-1-一维频率直方图" class="headerlink" title="3.5.1. 一维频率直方图"></a>3.5.1. 一维频率直方图</h3><p>plt.hist 被用来画频次直方图：</p><pre><code>plt.style.use('seaborn-white')data = np.random.randn(500)plt.hist(data, color='gray')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist.png" alt="ct"></a></p><p>随机数直方图</p><p>hist() 有许多用来调整计算过程和显示效果的选项，例如 histtype 类型对比：</p><pre><code>v</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist0.png" alt="ct"></a></p><p>不同 histtype 类型的直方图</p><p>stepfilled 与透明性参数 alpha 搭配使用的效果非常好：</p><pre><code>plt.figure(figsize=(8,4))x1 = np.random.normal(0, 2, 1000)x2 = np.random.normal(-2, 1, 1000)x3 = np.random.normal(2, 2, 1000)kwargs = dict(histtype='stepfilled', alpha=0.5, normed=True, bins=40)plt.hist(x1, **kwargs)plt.hist(x2, **kwargs)plt.hist(x3, **kwargs)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist1.png" alt="ct"></a></p><p>不同频次透明度直方图</p><p>np.histogram() 计算每段区间的样本数：</p><pre><code>counts, bin_edges = np.histogram([1,2,3,4,5], bins=5)print(counts)print(bin_edges)&gt;&gt;&gt;[1 1 1 1 1][ 1.   1.8  2.6  3.4  4.2  5. ]</code></pre><h3 id="3-5-2-二维频率直方图"><a href="#3-5-2-二维频率直方图" class="headerlink" title="3.5.2. 二维频率直方图"></a>3.5.2. 二维频率直方图</h3><p>我们先看一个简单示例，来理解二维频率直方图的绘图步骤。</p><pre><code>plt.hist2d([0,1,1,2],[0,2,2,1.5], bins=2, cmap='Blues')cb = plt.colorbar()cb.set_label('counts in bin')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist2d.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist2d.png" alt="ct"></a></p><p>二维频率直方图</p><p>示例中给定了 4 个坐标，x 坐标范围为 [0-2]，y 坐标范围也是 [0-2]，bins = 2，表示均分 x 和 y  坐标范围，形成四个区域，然后统计每个区域落入的坐标点数。显然右上方深蓝区域落入 3 个点，所以右方的频率标签最大为  3，同时左下角浅蓝对应频率标签 1 处的颜色。</p><p>用一个多元高斯分布（multivariate Gaussian distribution） 生成 x 轴与 y 轴的样本数据并画2D频率图：</p><pre><code>mean = [0, 0]cov = [[1, 1], [1, 2]]x, y = np.random.multivariate_normal(mean, cov, 1000).T# 画点，用于对比直方图颜色深浅plt.plot(x,y, 'o', color='blue', markersize=1, alpha=0.5)plt.hist2d(x,y, bins=30, cmap='Blues')cb = plt.colorbar()cb.set_label('counts in bin')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist2d0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist2d0.png" alt="ct"></a></p><p>多元高斯分布二维频率直方图</p><p>通过对比点数的密集程度，可以看到点越密集的坐标处，直方图显示越深。</p><p>np.histogram2d 实现 2D 分布统计：</p><pre><code>counts, xedges, yedges = np.histogram2d(x, y, bins=30)print(counts.shape)&gt;&gt;&gt;(30, 30) # 所以 bins=30 将坐标划分成 30*30 个区域</code></pre><h3 id="3-5-3-六边形区间划分"><a href="#3-5-3-六边形区间划分" class="headerlink" title="3.5.3. 六边形区间划分"></a>3.5.3. 六边形区间划分</h3><p>二维频次直方图是由与坐标轴正交的方块分割而成的， 还有一种常用的方式是用正六边形分割。 Matplotlib 提供了 plt.hexbin 满足此类需求， 将二维数据集分割成蜂窝状。</p><pre><code>plt.plot(x,y, 'o', color='blue', markersize=1, alpha=0.5)plt.hexbin(x, y, gridsize=30, cmap='Blues')cb = plt.colorbar(label='count in bin')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hlist2d1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hlist2d1.png" alt="ct"></a></p><p>hexbin 函数画二维频次直方图</p><p>plt.hexbin 同样也有很多有趣的配置选项，包括为每个数据点设置不同的权重，以及用任意 NumPy 累计函数改变每个六边形区间划分的结果（权重均值、 标准差等指标）。</p><h2 id="3-6-等高线图"><a href="#3-6-等高线图" class="headerlink" title="3.6. 等高线图"></a>3.6. 等高线图</h2><ul><li>plt.contour 画等高线图。</li><li>plt.contourf 画带有填充色的等高线图（filled contour plot） 的色彩。</li><li>plt.imshow 显示图形。</li></ul><pre><code>def f(x, y):    return np.sin(x) ** 10 + np.cos(10 + y * x)plt.style.use('seaborn-white')x = np.linspace(0, 5, 50)y = np.linspace(0, 5, 40)X, Y = np.meshgrid(x, y)Z = f(X, Y)plt.contour(X, Y, Z, colors='black');</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ct0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/ct0.png" alt="ct"></a></p><p>等高线图</p><p>np.meshgrid 从一维数组构建二维网格数据。 生成 shape(x.shape, y.shape) 两个矩阵，一个用 x 填充行，一个用 y 填充列：</p><pre><code>x = np.array([0,1,2])y = np.array([-2,-1])xv,yv = np.meshgrid(x,y)print(xv)print(yv)&gt;&gt;&gt;[[0 1 2] [0 1 2]][[-2 -2 -2] [-1 -1 -1]]plt.plot(xv, yv, 'o', c='grey')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/grid1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/grid1.png" alt="grid"></a></p><p>meshgrid 效果图</p><p>为了凸显图像的高度和深度，我们可以使用 cmap，并等分更多份的等高线：</p><pre><code># 根据高度数据等分为 20 份，并使用 copper 颜色方案 plt.contour(X, Y, Z, 20, cmap='copper') </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ct1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/ct1.png" alt="ct"></a></p><p>颜色标注的等高线图</p><p>Matplotlib 有非常丰富的配色方案，可以使用 help(plt.cm) 查看它们。</p><p>可以通过 plt.contourf() 函数来填充等高线图（结尾有字母f，意味 fill），它的语法和 plt.contour() 一样。plt.colorbar() 命令自动创建一个表示图形各种颜色对应标签信息的颜色条。</p><pre><code># 亮表示波峰，暗表示波谷，是一个鸟瞰图 plt.contourf(X, Y, Z, 20, cmap='copper') plt.colorbar() </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ct2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/ct2.png" alt="ct"></a></p><p>颜色填充的等高线图</p><p>上面的图形是一个“梯度”的颜色填充等高线图，每一个梯度颜色相同。我们可以为梯度图添加等高线和标签：</p><pre><code># hot 是另一个常用的配色方案，对比度更强烈plt.contourf(X, Y, Z, 20, alpha=0.75, cmap='hot')# 画等高线contours = plt.contour(X, Y, Z, 5, colors='black', linewidth=0.5)# inlins 表示等高线是否穿过数字标签plt.clabel(contours, inline=True, fontsize=10)plt.colorbar()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ct3.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/ct3.png" alt="ct"></a></p><p>带标签的等高线图</p><h2 id="3-7-三维图"><a href="#3-7-三维图" class="headerlink" title="3.7. 三维图"></a>3.7. 三维图</h2><p>Matplotlib 原本只能画2D图，后来扩展了 mplot3d 工具箱，它用来画三维图。</p><pre><code>from mpl_toolkits import mplot3d </code></pre><h3 id="3-7-1-三维数据点与线"><a href="#3-7-1-三维数据点与线" class="headerlink" title="3.7.1. 三维数据点与线"></a>3.7.1. 三维数据点与线</h3><p>最基本的三维图是由 (x , y , z ) 三维坐标点构成的线图与散点图。 与前面介绍的普通二维图类似， 可以用 ax.plot3D 与 ax.scatter3D 函数来创建它们。 由于三维图函数的参数与前面二维图函数的参数基本相同。</p><p>下面来画一个三角螺旋线（trigonometric spiral），在线上随机布一些散点：</p><pre><code># 生成3d坐标ax = plt.axes(projection='3d')# 三维线的数据zline = np.linspace(0, 15, 1000)xline = 2 * np.sin(zline)yline = np.cos(zline)ax.plot3D(xline, yline, zline, 'r')plt.ylim(-2, 2)# 三维散点的数据zdata = 15 * np.random.random(100)xdata = 2 * np.sin(zdata) + 0.1 * np.random.randn(100)ydata = np.cos(zdata) + 0.1 * np.random.randn(100)ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap='hot')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/3d.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/3d.png" alt="ct"></a></p><p>3D 螺旋线和散点图</p><p>默认情况下，散点会自动改变透明度， 以在平面上呈现出立体感。</p><h3 id="3-7-2-三维等高线图"><a href="#3-7-2-三维等高线图" class="headerlink" title="3.7.2. 三维等高线图"></a>3.7.2. 三维等高线图</h3><p>mplot3d 也有用同样的输入数据创建三维晕渲（relief） 图的工具。 与二维 ax.contour 图形一样， ax.contour3D 要求所有数据都是二维网格数据的形式， 并且由函数计算 z 轴数值。</p><p>生成三维正弦函数的三维坐标点：</p><pre><code>def f(x, y):    return np.sin(np.sqrt(x ** 2 + y ** 2))x = np.linspace(-6, 6, 30)y = np.linspace(-6, 6, 30)X, Y = np.meshgrid(x, y)Z = f(X, Y)</code></pre><p>默认的初始观察角度有时不是最优的， view_init 可以调整观察角度与方位角（azimuthal angle）。 第一个参数调整俯仰角（x-y 平面的旋转角度）， 第二个参数是方位角（就是绕 z 轴顺时针旋转的度数）。</p><pre><code>def draw(ax, X, Y, Z):    ax.contour3D(X, Y, Z, 40, cmap='hot')    ax.set_xlabel('x')    ax.set_ylabel('y')    ax.set_zlabel('z')fig = plt.figure(figsize=(10,8))ax = fig.add_subplot(2, 2, 1, projection='3d')draw(ax, X, Y, Z)ax = fig.add_subplot(2, 2, 2, projection='3d')draw(ax, X, Y, Z)ax.view_init(60, 35)ax = fig.add_subplot(2, 2, 3, projection='3d')draw(ax, X, Y, Z)ax.view_init(-90, 0)ax = fig.add_subplot(2, 2, 4, projection='3d')draw(ax, X, Y, Z)ax.view_init(-180, 35)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/3d1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/3d1.png" alt="ct"></a></p><p>3D等高线不同视图</p><h3 id="3-7-3-线框图和曲面图"><a href="#3-7-3-线框图和曲面图" class="headerlink" title="3.7.3. 线框图和曲面图"></a>3.7.3. 线框图和曲面图</h3><h4 id="3-7-3-1-线框图"><a href="#3-7-3-1-线框图" class="headerlink" title="3.7.3.1. 线框图"></a>3.7.3.1. 线框图</h4><p>线框图使用多边形组合成曲面，使用 ax.plot_wireframe 绘制：</p><pre><code>fig = plt.figure()ax = plt.axes(projection='3d')ax.plot_wireframe(X, Y, Z, color='black')ax.set_title('wireframe')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/wireframe.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/wireframe.png" alt="wireframe"></a></p><p>三维线框图</p><p>可以通过 rstride （row stride）和 cstride （column stride）参数调整 y 轴 和 x 轴上的线的密集程度，默认值均为 1，只接受整数：</p><pre><code>def wireframe_draw(ax, X, Y, Z, rstride=1, cstride=1):    ax.plot_wireframe(X, Y, Z,color='black',                      rstride=rstride,                      cstride=cstride)    ax.set_xlabel('x')    ax.set_ylabel('y')    ax.set_zlabel('z')fig = plt.figure(figsize=(8,6))ax = fig.add_subplot(2, 2, 1, projection='3d', title="rstride=5")wireframe_draw(ax, X, Y, Z, rstride=5)ax.view_init(90, 0) # 顶视图，查看行的线密度ax = fig.add_subplot(2, 2, 2, projection='3d', title="cstride=5")wireframe_draw(ax, X, Y, Z, cstride=5)ax.view_init(90, 0) # 顶视图，查看列的线密度ax = fig.add_subplot(2, 2, 3, projection='3d', title="cstride=5,rstride=5")wireframe_draw(ax, X, Y, Z, rstride=5, cstride=5)ax.view_init(90, 0)ax = fig.add_subplot(2, 2, 4, projection='3d', title="cstride=5,rstride=5")wireframe_draw(ax, X, Y, Z, rstride=5, cstride=5)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/stride.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/stride.png" alt="stride"></a></p><p>不同线密度的三维线框图</p><p>对线框图中的多边形使用配色方案进行颜色填充就成为了曲面图。</p><h4 id="3-7-3-2-曲面图"><a href="#3-7-3-2-曲面图" class="headerlink" title="3.7.3.2. 曲面图"></a>3.7.3.2. 曲面图</h4><p>使用 ax.plot_surface 绘制曲面图。</p><pre><code>fig = plt.figure()ax = plt.axes(projection='3d')ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis', edgecolor='none')ax.set_title('surface') </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/surface.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/surface.png" alt="surface"></a></p><p>三维曲面图</p><p>plot_surface 同样支持调整 rstride 和 cstride。同时支持设置阴影。</p><pre><code>def surface_draw(ax, X, Y, Z, rstride=1, cstride=1):    ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none',                    rstride=rstride, cstride=cstride)    ax.set_xlabel('x')    ax.set_ylabel('y')    ax.set_zlabel('z')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/stride0.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/stride0.png" alt="stride"></a></p><p>不同线密度的三维曲面图</p><h4 id="3-7-3-3-极坐标曲面图"><a href="#3-7-3-3-极坐标曲面图" class="headerlink" title="3.7.3.3. 极坐标曲面图"></a>3.7.3.3. 极坐标曲面图</h4><p>使用极坐标曲面图，可以产生切片的可视化效果：</p><pre><code>r = np.linspace(0, 6, 20)theta = np.linspace(-0.9 * np.pi, 0.8 * np.pi, 40)r, theta = np.meshgrid(r, theta)X = r * np.sin(theta)Y = r * np.cos(theta)Z = f(X, Y)ax = plt.axes(projection='3d')ax.plot_surface(X, Y, Z, rstride=1, cstride=1,                cmap='viridis', edgecolor='none')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/polar.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/polar.png" alt="polar"></a></p><p>极坐标曲面图</p><h4 id="3-7-3-4-曲面三角剖分"><a href="#3-7-3-4-曲面三角剖分" class="headerlink" title="3.7.3.4. 曲面三角剖分"></a>3.7.3.4. 曲面三角剖分</h4><p>有时均匀采样的网格数据显得太过严格且不太容易实现，这时可以使用三角剖分图形（triangulation-based plot）。</p><pre><code>def f(x, y):    return np.sin(x) * np.cos(y) * 2theta = 2 * np.pi * np.random.random(1000)r = 6 * np.random.random(1000)x = np.ravel(r * np.sin(theta))y = np.ravel(r * np.cos(theta))z = f(x, y)</code></pre><p>首先生成二维的随机点，然后得到三维数据，接着使用散点图观察大致形状，然后使用 plot_trisurf 绘图，plot_trisurf 使用三角形来构造表面并填充配色。</p><pre><code>fig = plt.figure(figsize=(10,4))ax = fig.add_subplot(1, 2, 1, projection='3d', title='scatter')ax.scatter(x, y, z, c=z, cmap='viridis', linewidth=0.5)ax = fig.add_subplot(1, 2, 2, projection='3d', title='trisurf')ax.plot_trisurf(x, y, z, cmap='viridis', edgecolor='none');</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/tri.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/tri.png" alt="triangle"></a></p><p>散点图和三角剖分曲面图</p><h2 id="3-8-子图"><a href="#3-8-子图" class="headerlink" title="3.8. 子图"></a>3.8. 子图</h2><p>已经接触过 subplot 函数来创建子图：在较大的图形（Figure）中同时放置一组较小的坐标轴。这些子图可可以是画中画（inset）、网格图（grid of plots），或者是其他更复 杂的布局形式。</p><h3 id="3-8-1-axes-子图"><a href="#3-8-1-axes-子图" class="headerlink" title="3.8.1. axes 子图"></a>3.8.1. axes 子图</h3><p>axes 子图又称为画中画子图，可以直接在当前 Figure 上生成新的坐标轴，可任意指定位置和大小。</p><h4 id="3-8-1-1-plt-axes"><a href="#3-8-1-1-plt-axes" class="headerlink" title="3.8.1.1. plt.axes"></a>3.8.1.1. plt.axes</h4><p>Figure 默认会生成一个坐标轴 axes，我们可以使用 plt.axes 手动在 Figure 中创建坐标。</p><p>plt.axes 函数默认创建一个标准的坐标轴，并填满整张图。它还有一个可选参数，由图形坐标系统的四个值构成：[bottom, left, width, height]（底坐标、 左坐标、 宽 度、 高度），数值的取值范围是一个百分比的小数，左下角（原点）为 0，右上角为 1。</p><pre><code>fig = plt.figure(figsize=(6,6))# print(plt.axes) 可以默认值[0.125, 0.125, 0.775, 0.755]plt.axes() # 绘制默认坐标# 在 Figure 原点绘制子坐标 1，高度和宽度分别为 20% 的 Figure 的高和宽ax1 = plt.axes([0.0, 0.0, 0.2, 0.2])ax1.plot([0,1], [0,1], c='r')# 在 Figure 的 60% 处绘制子坐标 1，高度和宽度分别为 20% 的 Figure 的高和宽ax2 = plt.axes([0.6, 0.6, 0.2, 0.2])ax2.plot([0,1], [0,1], c='m')plt.show()</code></pre><p>本示例的目的在于指明子坐标的位置和默认坐标轴无关，它是相对于 Figure 的。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axes.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axes.png" alt="axes"></a></p><p>通过创建子坐标创建子图</p><p>通过 fig 对象我们可以打印所有当前图像对象上的 axes 坐标对象 ：</p><pre><code>for i in fig.axes:    print(i)&gt;&gt;&gt;Axes(0.125,0.125;0.775x0.755)Axes(0,0;0.2x0.2)Axes(0.6,0.6;0.2x0.2)</code></pre><p>Axes(0.125,0.125;0.775x0.755) 是默认坐标，其中原点为相对于 Figure 左下角 (0, 0)  向右平移画布宽度的 12.5%，向上平移画布宽度的 12.5% 作为默认坐标的原点，0.775x0.755 表示坐标轴大小，表示相对于  Figure 宽度的 77.5% 和高度的 77.5%。</p><h4 id="3-8-1-2-add-axes"><a href="#3-8-1-2-add-axes" class="headerlink" title="3.8.1.2. add_axes"></a>3.8.1.2. add_axes</h4><p>通过 fig 的方法 fig.add_axes() 也可以添加新坐标轴。 用这个命令创建两个竖直排列的坐标轴：</p><pre><code>fig = plt.figure(figsize=(6,6))x = np.linspace(0, 10)# 创建子图，原点右平移10%，上平移50%(等于 ax2 的原点上平移 0.1+0.4 高度)ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4], xticklabels=[], ylim=(-1.2, 1.2))ax1.plot(np.sin(x))ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4], ylim=(-1.2, 1.2))ax2.plot(np.cos(x));plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axes1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axes1.png" alt="axes1"></a></p><p>通过 add_axes 创建子图</p><p>可以看到两个紧挨着的坐标轴（上面的坐标轴没有刻度）：上子图（起点 y 坐标为 0.5 位置）与下子图的 x 轴刻度是对应的（起点 y 坐标为 0.1， 高度为 0.4） 。</p><h4 id="3-8-1-3-子图属性"><a href="#3-8-1-3-子图属性" class="headerlink" title="3.8.1.3. 子图属性"></a>3.8.1.3. 子图属性</h4><ul><li>ax.set_title 为子坐标添加标题。</li><li>ax.set_xlim 和 ax.set_xlim 为子坐标指定范围。</li><li>ax.set_xlabel 和 ax.set_ylabel 设置坐标轴标题。</li><li>ax.set_xticks 和 set_yticks 设置坐标轴的标签。</li><li>ax.set_xticklabels 和 ax.set_yticklabels  设置标签文字。</li></ul><pre><code>fig = plt.figure(figsize=(6,6))plt.axes()  # 创建默认坐标# 创建子坐标ax1 = plt.axes([0.5, 0.5, 0.2, 0.2])ax1.plot([0,1], [0,1], c='r')# 子图标题ax1.set_title("sub axes", fontsize=16)# 子图坐标轴的标题ax1.set_xlabel("x", fontsize=16)ax1.set_ylabel("y", fontsize=16)# 设置 x,y 轴范围ax1.set_xlim(-1,1)ax1.set_ylim(-1,1)# 设定 x,y 轴的标签ax1.set_xticks(range(-1,2,1))ax1.set_yticks(range(-1,2,1))# 设定 x 轴的标签文字ax1.set_xticklabels(list("abc"))plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/axes2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/axes2.png" alt="axes2"></a></p><p>设置子图属性</p><p>可以通过 ax.set 设置多个坐标属性，例如：</p><pre><code>ax.set(title='title', xlabel='x' ylabel='y') </code></pre><h3 id="3-8-2-网格子图"><a href="#3-8-2-网格子图" class="headerlink" title="3.8.2. 网格子图"></a>3.8.2. 网格子图</h3><h4 id="3-8-2-1-plt-subplot"><a href="#3-8-2-1-plt-subplot" class="headerlink" title="3.8.2.1. plt.subplot"></a>3.8.2.1. plt.subplot</h4><p>最底层的方法是用 plt.subplot() 在一个网格中创建一个子图。这个命令有三个整型参数——将要创建的网格 子图行数、列数和索引值，索引值从 1 开始， 从左上角到右下角依次增大。</p><pre><code>fig = plt.figure(figsize=(9,6))# 把 fig 划分成 2*3 的网格，并一次画图for i in range(1, 7):    plt.subplot(2, 3, i)    # 文本放置在子图的中心位置    plt.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha='center')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/subplot.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/subplot.png" alt="subplot"></a></p><p>subplot 绘制网格子图</p><p>plt.subplot 方法对应面向对象方法为 fig.add_subplot，参数一致。</p><h4 id="3-8-2-2-子图间隔调整"><a href="#3-8-2-2-子图间隔调整" class="headerlink" title="3.8.2.2. 子图间隔调整"></a>3.8.2.2. 子图间隔调整</h4><p>plt.subplots_adjust 可以调整子图之间的间隔。</p><pre><code>fig = plt.figure(figsize=(9,6))# 分别设置垂直间隔和水平间隔，数值以子图的高或宽为基准，按百分比生成间隔数据fig.subplots_adjust(hspace=0.4, wspace=0.2)for i in range(1, 7):    fig.add_subplot(2, 3, i) # 面向对象方式创建子图    plt.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha='center')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/subplot1.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/subplot1.png" alt="subplot1"></a></p><p>子图间隔调整</p><p>示例中垂直间隔为子图高度的 40%，水平间隔为子图高度的 20%。</p><h4 id="3-8-2-3-plt-subplots"><a href="#3-8-2-3-plt-subplots" class="headerlink" title="3.8.2.3. plt.subplots"></a>3.8.2.3. plt.subplots</h4><p>plt.subplots 与 plt.subplot 不同，它不是用来创建单个子图的，而是用一行代码创建多个子图，并返回一个包含子图的  NumPy 数组。 关键参数是行数与列数，以及可选参数 sharex 与 sharey， 通过它们可以设置不同子图之间的关联关系。</p><p>所谓关联关系，即它们可以使用相同的坐标等属性。</p><pre><code>fig, ax = plt.subplots(2, 3, sharex='col', sharey='row', figsize=(9,6))print(type(fig).__name__, type(ax).__name__, sep='\n')print(type(ax[0,0]).__name__)&gt;&gt;&gt;Figurendarray     # ax 是 NumPy 数组，存储了2*3 个的子坐标对象，索引为 [row, col]AxesSubplot # ax 的每一个成员都是坐标对象</code></pre><p>通过 NumPy 坐标轴数组来设置文本信息：</p><pre><code>for i in range(2):    for j in range(3):        ax[i, j].text(0.5, 0.5, str((i, j)), fontsize=18, ha='center')# 通过索引引用子坐标对象绘图ax[0,0].plot([0, 1], [0, 1])ax[1,2].plot([0, 1], [1, 0])ax[1,2].set_title("1,2", fontsize=16)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/subplot2.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/subplot2.png" alt="subplot2"></a></p><p>子图共享坐标轴</p><p>注意，plt.subplot() 子图索引从 1 开始，plt.subplots() 返回的 ax 数组索引从 0 开始。</p><h4 id="3-8-2-4-不规则网格子图"><a href="#3-8-2-4-不规则网格子图" class="headerlink" title="3.8.2.4. 不规则网格子图"></a>3.8.2.4. 不规则网格子图</h4><p>以上 plt.subplot 和 plt.subplots 示例均自动为子图分配宽和高空间，如果要绘制不规则子图网格，plt.GridSpec() 是最好的工具。</p><pre><code>fig = plt.figure(figsize=(8,6))# 创建 2 行 3 列网格对象grid = plt.GridSpec(2, 3, wspace=0.4, hspace=0.3)# 通过类似 Python 切片的语法设置子图的位置和扩展尺寸plt.subplot(grid[0, 0]) # 第一个子图占用 1 行 1 列空间plt.subplot(grid[0, 1:])# 第二个子图占用 1 行 2 列空间plt.subplot(grid[1, :2])# 第三个子图占用 1 行 2 列空间plt.subplot(grid[1, 2]) # 第四个子图占用 1 行 1 列空间# 在最后一个子图中绘制直线plt.plot([0,1], [0,1])plt.show()</code></pre><p>参数2，3 就是创建每行五个，每列五个的网格，最后就是一个 2*3 的画布，相比于其他函数，使用网格布局的话可以更加灵活的控制占用多少空间。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/subgrid.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/subgrid.png" alt="subgrid"></a></p><p>不规则网格子图</p><p>这种灵活的网格排列方式用途十分广泛，可以实现多轴频次直方图（Multi-axes Histogram），seaborn 中封装了相关的 API。</p><p>多频次直方图的示例：</p><pre><code># 创建一些正态分布数据mean = [0, 0]cov = [[1, 1], [1, 2]]x, y = np.random.multivariate_normal(mean, cov, 2000).T# 设置坐标轴和网格fig = plt.figure(figsize=(8, 8))grid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)main_ax = fig.add_subplot(grid[:-1, :-1])x_hist = fig.add_subplot(grid[-1, :-1], yticklabels=[], sharex=main_ax)y_hist = fig.add_subplot(grid[:-1, -1], xticklabels=[], sharey=main_ax)# 主坐标轴画散点图main_ax.plot(x, y, 'ok', markersize=3, alpha=0.3)# 次坐标轴画频次直方图x_hist.hist(x, 40, histtype='stepfilled', orientation='vertical', color='gray')x_hist.invert_yaxis()y_hist.hist(y, 40, histtype='stepfilled', orientation='horizontal', color='gray')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hist.png"><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-matplotlib.assets/hist.png" alt="hist"></a></p><p>多轴频次直方图</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- SciPy</title>
      <link href="/2020/01/05/20200105-data-analysis-scipy/"/>
      <url>/2020/01/05/20200105-data-analysis-scipy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-Scipy：高级科学计算"><a href="#1-Scipy：高级科学计算" class="headerlink" title="1. Scipy：高级科学计算"></a>1. Scipy：高级科学计算</h2><p><code>scipy</code>包包含许多专注于科学计算中的常见问题的工具箱。它的子模块对应于不同的应用，比如插值、积分、优化、图像处理、统计和特殊功能等。</p><p><code>scipy</code>可以与其他标准科学计算包相对比，比如GSL (C和C++的GNU科学计算包), 或者Matlab的工具箱。<code>scipy</code>是Python中科学程序的核心程序包；这意味着有效的操作<code>numpy</code>数组，因此，numpy和scipy可以一起工作。</p><p>在实现一个程序前，有必要确认一下需要的数据处理时候已经在scipy中实现。作为非专业程序员，科学家通常倾向于<strong>重新发明轮子</strong>，这产生了小玩具、不优化、很难分享以及不可以维护的代码。相反，scipy的程序是优化并且测试过的，因此应该尽可能使用。</p><p><strong>警告</strong> 这个教程根本不是数值计算的介绍。因为列举scipy的不同子模块和功能将会是非常枯燥的，相反我们将聚焦于列出一些例子，给出如何用scipy进行科学计算的大概思路。</p><p>scipy是由针对特定任务的子模块组成的：</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/cluster.html#scipy.cluster"><code>scipy.cluster</code></a></td><td align="left">向量计算 / Kmeans</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/constants.html#scipy.constants"><code>scipy.constants</code></a></td><td align="left">物理和数学常量</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/fftpack.html#scipy.fftpack"><code>scipy.fftpack</code></a></td><td align="left">傅里叶变换</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/integrate.html#scipy.integrate"><code>scipy.integrate</code></a></td><td align="left">积分程序</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/interpolate.html#scipy.interpolate"><code>scipy.interpolate</code></a></td><td align="left">插值</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/io.html#scipy.io"><code>scipy.io</code></a></td><td align="left">数据输入和输出</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/linalg.html#scipy.linalg"><code>scipy.linalg</code></a></td><td align="left">线性代数程序</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/ndimage.html#scipy.ndimage"><code>scipy.ndimage</code></a></td><td align="left">n-维图像包</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/odr.html#scipy.odr"><code>scipy.odr</code></a></td><td align="left">正交距离回归</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/optimize.html#scipy.optimize"><code>scipy.optimize</code></a></td><td align="left">优化</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/signal.html#scipy.signal"><code>scipy.signal</code></a></td><td align="left">信号处理</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/sparse.html#scipy.sparse"><code>scipy.sparse</code></a></td><td align="left">稀疏矩阵</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/spatial.html#scipy.spatial"><code>scipy.spatial</code></a></td><td align="left">空间数据结构和算法</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/special.html#scipy.special"><code>scipy.special</code></a></td><td align="left">一些特殊数学函数</td></tr><tr><td align="left"><a href="http://docs.scipy.org/doc/scipy/reference/stats.html#scipy.stats"><code>scipy.stats</code></a></td><td align="left">统计</td></tr></tbody></table><p>他们全都依赖于<a href="http://docs.scipy.org/doc/numpy/reference/index.html#numpy">numpy</a>, 但是大多数是彼此独立的。导入Numpy和Scipy的标准方式：</p><p>In [1]:</p><pre><code>import numpy as npfrom scipy import stats  # 其他的子模块类似</code></pre><p><code>scipy</code>的主要命名空间通常包含的函数其实是numpy（试一下<code>scipy.cos</code>其实是<code>np.cos</code>) 。这些函数的暴露只是因为历史原因；通常没有必要在你的代码中使用<code>import scipy</code>。</p><h2 id="1-1-文件输入-x2F-输出：scipy-io"><a href="#1-1-文件输入-x2F-输出：scipy-io" class="headerlink" title="1.1 文件输入/输出：scipy.io"></a>1.1 文件输入/输出：<a href="http://docs.scipy.org/doc/scipy/reference/io.html#scipy.io">scipy.io</a></h2><p>载入和保存matlab文件：</p><p>In [2]:</p><pre><code>from scipy import io as spioa = np.ones((3, 3))spio.savemat('file.mat', {'a': a}) # savemat expects a dictionarydata = spio.loadmat('file.mat', struct_as_record=True)data['a']</code></pre><p>Out[2]:</p><pre><code>array([[ 1.,  1.,  1.],       [ 1.,  1.,  1.],       [ 1.,  1.,  1.]])from scipy import miscmisc.imread('fname.png')# Matplotlib也有类似的方法import matplotlib.pyplot as pltplt.imread('fname.png')</code></pre><p>更多请见：</p><ul><li>加载文本文件：<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html#numpy.loadtxt">numpy.loadtxt()</a>/<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html#numpy.savetxt">numpy.savetxt()</a></li><li>智能加载文本/csv文件：<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html#numpy.genfromtxt">numpy.genfromtxt()</a>/numpy.recfromcsv()</li><li>快速有效，但是针对numpy的二进制格式：<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.save.html#numpy.save">numpy.save()</a>/<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.load.html#numpy.load">numpy.load()</a></li></ul><h2 id="1-2-特殊函数：scipy-special"><a href="#1-2-特殊函数：scipy-special" class="headerlink" title="1.2 特殊函数：scipy.special"></a>1.2 特殊函数：<a href="http://docs.scipy.org/doc/scipy/reference/special.html#scipy.specia">scipy.special</a></h2><p>特殊函数是超验函数。<a href="http://docs.scipy.org/doc/scipy/reference/special.html#scipy.special">scipy.special</a>模块的文档字符串写的很详细，因此我们不会在这里列出所有的函数。常用的一些函数如下：</p><ul><li>贝塞尔函数，比如<code>scipy.special.jn()</code> (第n个整型顺序的贝塞尔函数)</li><li>椭圆函数 (<code>scipy.special.ellipj()</code> Jacobian椭圆函数, …)</li><li>Gamma 函数: scipy.special.gamma(), 也要注意 <code>scipy.special.gammaln()</code> 将给出更高准确数值的 Gamma的log。</li><li>Erf, 高斯曲线的面积：scipy.special.erf()</li></ul><h2 id="1-3-线性代数操作：scipy-linalg"><a href="#1-3-线性代数操作：scipy-linalg" class="headerlink" title="1.3 线性代数操作：scipy.linalg"></a>1.3 线性代数操作：<a href="http://docs.scipy.org/doc/scipy/reference/linalg.html#scipy.linalg">scipy.linalg</a></h2><p><a href="http://docs.scipy.org/doc/scipy/reference/linalg.html#scipy.linalg">scipy.linalg</a> 模块提供了标准的线性代数操作，这依赖于底层的高效实现（BLAS、LAPACK）。</p><ul><li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.det.html#scipy.linalg.det">scipy.linalg.det()</a> 函数计算方阵的行列式：</li></ul><p>In [3]:</p><pre><code>from scipy import linalgarr = np.array([[1, 2],                [3, 4]])linalg.det(arr)</code></pre><p>Out[3]:</p><pre><code>-2.0</code></pre><p>In [4]:</p><pre><code>arr = np.array([[3, 2],                 [6, 4]])linalg.det(arr)</code></pre><p>Out[4]:</p><pre><code>0.0</code></pre><p>In [5]:</p><pre><code>linalg.det(np.ones((3, 4)))---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-5-4d4672bd00a7&gt; in &lt;module&gt;()----&gt; 1  linalg.det(np.ones((3, 4)))/Library/Python/2.7/site-packages/scipy/linalg/basic.pyc in det(a, overwrite_a, check_finite) 440         a1 = np.asarray(a) 441     if len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]:--&gt; 442  raise ValueError('expected square matrix') 443     overwrite_a = overwrite_a or _datacopied(a1, a) 444     fdet, = get_flinalg_funcs(('det',), (a1,))ValueError: expected square matrix</code></pre><ul><li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.inv.html#scipy.linalg.inv">scipy.linalg.inv()</a> 函数计算逆方阵：</li></ul><p>In [6]:</p><pre><code>arr = np.array([[1, 2],                 [3, 4]])iarr = linalg.inv(arr)iarr</code></pre><p>Out[6]:</p><pre><code>array([[-2\. ,  1\. ],       [ 1.5, -0.5]])</code></pre><p>In [7]:</p><pre><code>np.allclose(np.dot(arr, iarr), np.eye(2))</code></pre><p>Out[7]:</p><pre><code>True</code></pre><p>最后计算逆奇异矩阵（行列式为0）将抛出<code>LinAlgError</code> :</p><p>In [8]:</p><pre><code>arr = np.array([[3, 2],                 [6, 4]])linalg.inv(arr)---------------------------------------------------------------------------LinAlgError                               Traceback (most recent call last)&lt;ipython-input-8-e8078a9a17b2&gt; in &lt;module&gt;() 1 arr = np.array([[3, 2], 2                  [6, 4]])----&gt; 3  linalg.inv(arr)/Library/Python/2.7/site-packages/scipy/linalg/basic.pyc in inv(a, overwrite_a, check_finite) 381         inv_a, info = getri(lu, piv, lwork=lwork, overwrite_lu=1) 382     if info &gt; 0:--&gt; 383  raise LinAlgError("singular matrix") 384     if info &lt; 0: 385         raise ValueError('illegal value in %d-th argument of internal 'LinAlgError: singular matrix</code></pre><ul><li>还有更多高级的操作，奇异值分解（SVD）：</li></ul><p>In [9]:</p><pre><code>arr = np.arange(9).reshape((3, 3)) + np.diag([1, 0, 1])uarr, spec, vharr = linalg.svd(arr)</code></pre><p>结果的数组频谱是：</p><p>In [10]:</p><pre><code>spec    </code></pre><p>Out[10]:</p><pre><code>array([ 14.88982544,   0.45294236,   0.29654967])</code></pre><p>原始矩阵可以用<code>svd</code>和<code>np.dot</code>矩阵相乘的结果重新获得：</p><p>In [11]:</p><pre><code>sarr = np.diag(spec)svd_mat = uarr.dot(sarr).dot(vharr)np.allclose(svd_mat, arr)</code></pre><p>Out[11]:</p><pre><code>True</code></pre><p>SVD常被用于统计和信号处理。其他标准分解 (QR, LU, Cholesky, Schur), 以及线性系统的求解器，也可以在<a href="http://docs.scipy.org/doc/scipy/reference/linalg.html#scipy.linalg">scipy.linalg</a>中找到。</p><h2 id="1-4-快速傅立叶变换：scipy-fftpack"><a href="#1-4-快速傅立叶变换：scipy-fftpack" class="headerlink" title="1.4 快速傅立叶变换：scipy.fftpack"></a>1.4 快速傅立叶变换：<a href="http://docs.scipy.org/doc/scipy/reference/fftpack.html#scipy.fftpack">scipy.fftpack</a></h2><p><a href="http://docs.scipy.org/doc/scipy/reference/fftpack.html#scipy.fftpack">scipy.fftpack</a> 模块允许计算快速傅立叶变换。例子，一个（有噪音）的信号输入是这样：</p><p>In [12]:</p><pre><code>time_step = 0.02period = 5.time_vec = np.arange(0, 20, time_step)sig = np.sin(2 * np.pi / period * time_vec) + \       0.5 * np.random.randn(time_vec.size)</code></pre><p>观察者并不知道信号的频率，只知道抽样时间步骤的信号<code>sig</code>。假设信号来自真实的函数，因此傅立叶变换将是对称的。<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fftfreq.html#scipy.fftpack.fftfreq">scipy.fftpack.fftfreq()</a> 函数将生成样本序列，而将计算快速傅立叶变换：</p><p>In [13]:</p><pre><code>from scipy import fftpacksample_freq = fftpack.fftfreq(sig.size, d=time_step)sig_fft = fftpack.fft(sig)</code></pre><p>因为生成的幂是对称的，寻找频率只需要使用频谱为正的部分：</p><p>In [14]:</p><pre><code>pidxs = np.where(sample_freq &gt; 0)freqs = sample_freq[pidxs]power = np.abs(sig_fft)[pidxs]</code></pre><p><a href="http://scipy-lectures.github.io/plot_directive/pyplots/fftpack_frequency.py"><img src="http://scipy-lectures.github.io/_images/fftpack_frequency.png" alt="png"></a></p><p>寻找信号频率：</p><p>In [15]:</p><pre><code>freq = freqs[power.argmax()]np.allclose(freq, 1./period)  # 检查是否找到了正确的频率</code></pre><p>Out[15]:</p><pre><code>True</code></pre><p>现在高频噪音将从傅立叶转换过的信号移除：</p><p>In [16]:</p><pre><code>sig_fft[np.abs(sample_freq) &gt; freq] = 0</code></pre><p>生成的过滤过的信号可以用<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ifft.html#scipy.fftpack.ifft">scipy.fftpack.ifft()</a>函数：</p><p>In [17]:</p><pre><code>main_sig = fftpack.ifft(sig_fft)</code></pre><p>查看结果：</p><p>In [18]:</p><pre><code>import pylab as pltplt.figure()plt.plot(time_vec, sig)plt.plot(time_vec, main_sig, linewidth=3)plt.xlabel('Time [s]')plt.ylabel('Amplitude')/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/numpy/core/numeric.py:462: ComplexWarning: Casting complex values to real discards the imaginary part  return array(a, dtype, copy=False, order=order)</code></pre><p>Out[18]:</p><pre><code>&lt;matplotlib.text.Text at 0x107484b10&gt;</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc082bbc7.png" alt="img"></p><p><a href="http://docs.scipy.org/doc/numpy/reference/routines.fft.html#numpy.fft">numpy.fft</a></p><p>Numpy也有一个FFT(numpy.fft)实现。但是，通常scipy的实现更受欢迎，因为，他使用更高效的底层实现。</p><p><strong>实例：寻找粗略周期</strong></p><p><a href="http://scipy-lectures.github.io/plot_directive/intro/solutions/periodicity_finder.py"><img src="http://scipy-lectures.github.io/_images/periodicity_finder_00.png" alt="img"></a></p><p><a href="http://scipy-lectures.github.io/plot_directive/intro/solutions/periodicity_finder.py"><img src="http://scipy-lectures.github.io/_images/periodicity_finder_01.png" alt="img"></a></p><p><strong>实例：高斯图片模糊</strong></p><p>弯曲:</p><p>$f_1(t) = \int dt’, K(t-t’) f_0(t’)$</p><p>$\tilde{f}_1(\omega) = \tilde{K}(\omega) \tilde{f}_0(\omega)$</p><p><a href="http://scipy-lectures.github.io/plot_directive/intro/solutions/image_blur.py"><img src="http://scipy-lectures.github.io/_images/image_blur.png" alt="img"></a></p><p><strong>练习：月球登陆图片降噪</strong></p><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/moonlanding.png" alt="img"></p><ol><li>检查提供的图片moonlanding.png，图片被周期噪音污染了。在这个练习中，我们的目的是用快速傅立叶变换清除噪音。</li><li>用<code>pylab.imread()</code>加载图片。</li><li>寻找并使用在<a href="http://docs.scipy.org/doc/scipy/reference/fftpack.html#scipy.fftpack">scipy.fftpack</a>中的2-D FFT函数，绘制图像的频谱（傅立叶变换）。在可视化频谱时是否遇到了麻烦？如果有的话，为什么？</li><li>频谱由高频和低频成分构成。噪音被包含在频谱的高频部分，因此将那些部分设置为0（使用数组切片）。</li><li>应用逆傅立叶变换来看一下结果图片。</li></ol><h2 id="1-5-优化及拟合：scipy-optimize"><a href="#1-5-优化及拟合：scipy-optimize" class="headerlink" title="1.5 优化及拟合：scipy.optimize"></a>1.5 优化及拟合：<a href="http://docs.scipy.org/doc/scipy/reference/optimize.html#scipy.optimize">scipy.optimize</a></h2><p>优化是寻找最小化或等式的数值解的问题。</p><p><a href="http://docs.scipy.org/doc/scipy/reference/optimize.html#scipy.optimize">scipy.optimize</a> 模块提供了函数最小化（标量或多维度）、曲线拟合和求根的有用算法。</p><p>In [19]:</p><pre><code>from scipy import optimize</code></pre><p><strong>寻找标量函数的最小值</strong></p><p>让我们定义下面的函数：</p><p>In [20]:</p><pre><code>def f(x):    return x**2 + 10*np.sin(x)</code></pre><p>绘制它：</p><p>In [21]:</p><pre><code>x = np.arange(-10, 10, 0.1)plt.plot(x, f(x))plt.show()</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc094114a.png" alt="img"></p><p>这个函数在-1.3附近有一个全局最小并且在3.8有一个局部最小。</p><p>找到这个函数的最小值的常用有效方式是从给定的初始点开始进行一个梯度下降。BFGS算法是这样做的较好方式：</p><p>In [22]:</p><pre><code>optimize.fmin_bfgs(f, 0)Optimization terminated successfully.         Current function value: -7.945823         Iterations: 5         Function evaluations: 24         Gradient evaluations: 8</code></pre><p>Out[22]:</p><pre><code>array([-1.30644003])</code></pre><p>这个方法的一个可能问题是，如果这个函数有一些局部最低点，算法可能找到这些局部最低点而不是全局最低点，这取决于初始点：</p><p>In [23]:</p><pre><code>optimize.fmin_bfgs(f, 3, disp=0)</code></pre><p>Out[23]:</p><pre><code>array([ 3.83746663])</code></pre><p>如果我们不知道全局最低点，并且使用其临近点来作为初始点，那么我们需要付出昂贵的代价来获得全局最优。要找到全局最优点，最简单的算法是暴力算法，算法中会评估给定网格内的每一个点：</p><p>In [24]:</p><pre><code>grid = (-10, 10, 0.1)xmin_global = optimize.brute(f, (grid,))xmin_global</code></pre><p>Out[24]:</p><pre><code>array([-1.30641113])</code></pre><p>对于更大的网格，<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html#scipy.optimize.brute">scipy.optimize.brute()</a> 变得非常慢。<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.anneal.html#scipy.optimize.anneal">scipy.optimize.anneal()</a> 提供了一个替代的算法，使用模拟退火。对于不同类型的全局优化问题存在更多的高效算法，但是这超出了<code>scipy</code>的范畴。<a href="http://openopt.org/Welcome">OpenOpt</a>、<a href="https://github.com/xuy/pyipopt">IPOPT</a>、<a href="http://pagmo.sourceforge.net/pygmo/index.html">PyGMO</a>和<a href="http://pyevolve.sourceforge.net/">PyEvolve</a>是关于全局优化的一些有用的包。</p><p>要找出局部最低点，让我们用<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html#scipy.optimize.fminbound">scipy.optimize.fminbound</a>将变量限制在(0,10)区间：</p><p>In [25]:</p><pre><code>xmin_local = optimize.fminbound(f, 0, 10)    xmin_local</code></pre><p>Out[25]:</p><pre><code>3.8374671194983834</code></pre><p><strong>注</strong>：寻找函数的最优解将在高级章节中：<a href="http://scipy-lectures.github.io/advanced/mathematical_optimization/index.html#mathematical-optimization">数学优化：寻找函数的最优解</a>详细讨论。</p><p><strong>寻找标量函数的根</strong></p><p>要寻找上面函数f的根，比如<code>f(x)=0</code>的一个点，我们可以用比如<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve">scipy.optimize.fsolve()</a>：</p><p>In [26]:</p><pre><code>root = optimize.fsolve(f, 1)  # 我们的最初猜想是1root</code></pre><p>Out[26]:</p><pre><code>array([ 0.])</code></pre><p>注意只找到一个根。检查<code>f</code>的图发现在-2.5左右还有应该有第二个根。通过调整我们最初的猜想，我们可以发现正确的值：</p><p>In [27]:</p><pre><code>root2 = optimize.fsolve(f, -2.5)root2</code></pre><p>Out[27]:</p><pre><code>array([-2.47948183])</code></pre><p><strong>曲线拟合</strong></p><p>假设我们有来自<code>f</code>的样例数据，带有一些噪音：</p><p>In [28]:</p><pre><code>xdata = np.linspace(-10, 10, num=20)ydata = f(xdata) + np.random.randn(xdata.size)</code></pre><p>现在，如果我们知道这些sample数据来自的函数（这个案例中是$x^2 + sin(x)$）的函数形式，而不知道每个数据项的系数，那么我们可以用最小二乘曲线拟合在找到这些系数。首先，我们需要定义函数来拟合：</p><p>In [29]:</p><pre><code>def f2(x, a, b):    return a*x**2 + b*np.sin(x)</code></pre><p>然后我们可以使用<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit">scipy.optimize.curve_fit()</a>来找到<code>a</code>和<code>b</code>：</p><p>In [30]:</p><pre><code>guess = [2, 2]params, params_covariance = optimize.curve_fit(f2, xdata, ydata, guess)params</code></pre><p>Out[30]:</p><pre><code>array([  0.99719019,  10.27381534])</code></pre><p>现在我们找到了<code>f</code>的最优解和根，并且用曲线去拟合它，我们将这些结果整合在一个图中：</p><p><a href="http://scipy-lectures.github.io/plot_directive/pyplots/scipy_optimize_example2.py"><img src="http://scipy-lectures.github.io/_images/scipy_optimize_example2.png" alt="img"></a></p><p><strong>注</strong>：在Scipy &gt;= 0.11中，包含所有最小值和寻找根的算法的统一接口：<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize">scipy.optimize.minimize()</a>、 <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar">scipy.optimize.minimize_scalar()</a>和 <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.root">scipy.optimize.root()</a>。他们允许通过<code>method</code>关键词容易的比较多种算法。</p><p>你可以在<a href="http://docs.scipy.org/doc/scipy/reference/optimize.html#scipy.optimize">scipy.optimize</a>中找到对于多维度问题有相同功能的算法。</p><p><strong>练习：温度数据的曲线拟合</strong></p><p>下面是从1月开始阿拉斯加每个月的温度极值（摄氏度）：</p><p>最大值: 17, 19, 21, 28, 33, 38, 37, 37, 31, 23, 19, 18</p><p>最小值: -62, -59, -56, -46, -32, -18, -9, -13, -25, -46, -52, -58</p><ol><li>绘制这些温度极值。</li><li>定义一个函数，可以描述温度的最大值和最小值。提示：这个函数的周期是一年。提示：包含时间偏移。</li><li>用<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit">scipy.optimize.curve_fit()</a>拟合这个函数与数据。</li><li>绘制结果。这个拟合合理吗？如果不合理，为什么？</li><li>最低温度和最高温度的时间偏移是否与拟合一样精确？</li></ol><p><strong>练习：2-D 最小值</strong></p><p><a href="http://scipy-lectures.github.io/plot_directive/pyplots/scipy_optimize_sixhump.py"><img src="http://scipy-lectures.github.io/_images/scipy_optimize_sixhump.png" alt="img"></a></p><p>六峰驼背函数： <img src="http://scipy-lectures.github.io/_images/math/a15fd87c4934c2530d57ccae635f1e53791a5187.png" alt="img"></p><p>有多个全局和局部最低点。找到这个函数的全局最低点。</p><p>提示：</p><ul><li>变量可以被限定在-2 &lt; x &lt; 2 和 -1 &lt; y &lt; 1。</li><li>用<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.meshgrid.html#numpy.meshgrid">numpy.meshgrid()</a> 和 pylab.imshow() 来从视觉上来寻找区域。</li><li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_bfgs.html#scipy.optimize.fmin_bfgs">scipy.optimize.fmin_bfgs()</a> 或者另一个多维最小化。 多几个全局最小值，那些点上的函数值十多少？如果最初的猜测是$(x, y) = (0, 0)$会怎样?</li></ul><p>看一下<a href="http://scipy-lectures.github.io/intro/summary-exercises/optimize-fit.html#summary-exercise-optimize">非线性最小二乘曲线拟合：地形机载激光雷达数据中的点抽取</a>练习的总结，以及更高及的例子。</p><h2 id="1-6-统计和随机数：scipy-stats"><a href="#1-6-统计和随机数：scipy-stats" class="headerlink" title="1.6. 统计和随机数：scipy.stats"></a>1.6. 统计和随机数：<a href="http://docs.scipy.org/doc/scipy/reference/stats.html#scipy.stats">scipy.stats</a></h2><p><a href="http://docs.scipy.org/doc/scipy/reference/stats.html#scipy.stats">scipy.stats</a>模块包含统计工具和随机过程的概率描述。在<code>numpy.random</code>中可以找到多个随机数生成器。</p><h3 id="1-6-1-直方图和概率密度函数"><a href="#1-6-1-直方图和概率密度函数" class="headerlink" title="1.6.1 直方图和概率密度函数"></a>1.6.1 直方图和概率密度函数</h3><p>给定随机过程的观察值，它们的直方图是随机过程的PDF（概率密度函数）的估计值：</p><p>In [31]:</p><pre><code>a = np.random.normal(size=1000)bins = np.arange(-4, 5)bins</code></pre><p>Out[31]:</p><pre><code>array([-4, -3, -2, -1,  0,  1,  2,  3,  4])</code></pre><p>In [32]:</p><pre><code>histogram = np.histogram(a, bins=bins, normed=True)[0]bins = 0.5*(bins[1:] + bins[:-1])bins</code></pre><p>Out[32]:</p><pre><code>array([-3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,  3.5])</code></pre><p>In [35]:</p><pre><code>from scipy import statsimport pylab as plb = stats.norm.pdf(bins)  # norm 是一种分布pl.plot(bins, histogram)pl.plot(bins, b)</code></pre><p>Out[35]:</p><pre><code>[&lt;matplotlib.lines.Line2D at 0x10764cd10&gt;]</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc0957994.png" alt="img"></p><p>如果我们知道随机过程属于特定的随机过程家族，比如正态过程，我们可以做一个观察值的最大可能性拟合，来估计潜在分布的参数。这里我们用随机过程拟合观察数据：</p><p>In [5]:</p><pre><code>loc, std = stats.norm.fit(a)loc</code></pre><p>Out[5]:</p><pre><code>-0.063033073531050018</code></pre><p>In [6]:</p><pre><code>std</code></pre><p>Out[6]:</p><pre><code>0.97226620529973573</code></pre><p><strong>练习：概率分布</strong></p><p>用shape参数为1的gamma分布生成1000个随机数，然后绘制那些样本的直方图。你可以在顶部绘制pdf（应该会匹配）吗？</p><p>额外信息：这些分布都有一些有用的方法。读一下文档字符串或者用IPython tab 完成来研究这些方法。你可以用在你的随机变量上使用<code>fit</code>方法来找回shape参数1吗？</p><h3 id="1-6-2-百分位数"><a href="#1-6-2-百分位数" class="headerlink" title="1.6.2 百分位数"></a>1.6.2 百分位数</h3><p>中数是有一半值在其上一半值在其下的值：</p><p>In [7]:</p><pre><code>np.median(a)</code></pre><p>Out[7]:</p><pre><code>-0.061271835457024623</code></pre><p>中数也被称为百分位数50，因为50%的观察值在它之下：</p><p>In [8]:</p><pre><code>stats.scoreatpercentile(a, 50)</code></pre><p>Out[8]:</p><pre><code>-0.061271835457024623</code></pre><p>同样，我们也能计算百分位数90：</p><p>In [10]:</p><pre><code>stats.scoreatpercentile(a, 90)</code></pre><p>Out[10]:</p><pre><code>1.1746952490791494</code></pre><p>百分位数是CDF的估计值：累积分布函数。</p><h3 id="1-6-3-统计检验"><a href="#1-6-3-统计检验" class="headerlink" title="1.6.3 统计检验"></a>1.6.3 统计检验</h3><p>统计检验是一个决策指示器。例如，如果我们有两组观察值，我们假设他们来自于高斯过程，我们可以用T检验来决定这两组观察值是不是显著不同：</p><p>In [11]:</p><pre><code>a = np.random.normal(0, 1, size=100)b = np.random.normal(1, 1, size=10)stats.ttest_ind(a, b)   </code></pre><p>Out[11]:</p><pre><code>(-2.8365663431591557, 0.0054465620169369703)</code></pre><p>生成的结果由以下内容组成：</p><ul><li>T 统计值：一个值，符号与两个随机过程的差异成比例，大小与差异的程度有关。</li><li>p 值：两个过程相同的概率。如果它接近1，那么这两个过程几乎肯定是相同的。越接近于0，越可能这两个过程有不同的平均数。</li></ul><h2 id="1-7-插值：scipy-interpolate"><a href="#1-7-插值：scipy-interpolate" class="headerlink" title="1.7 插值：scipy.interpolate"></a>1.7 插值：<a href="http://docs.scipy.org/doc/scipy/reference/interpolate.html#scipy.interpolate">scipy.interpolate</a></h2><p><a href="http://docs.scipy.org/doc/scipy/reference/interpolate.html#scipy.interpolate">scipy.interpolate</a>对从实验数据中拟合函数是非常有用的，因此，评估没有测量过的点。这个模块是基于<a href="http://www.netlib.org/">netlib</a>项目的<a href="http://www.netlib.org/dierckx/index.html">Fortran子程序 FITPACK</a></p><p>假想一个接近sine函数的实验数据：</p><p>In [8]:</p><pre><code>measured_time = np.linspace(0, 1, 10)noise = (np.random.random(10)*2 - 1) * 1e-1measures = np.sin(2 * np.pi * measured_time) + noise</code></pre><p><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html#scipy.interpolate.interp1d">scipy.interpolate.interp1d</a>类可以建立一个线性插值函数：</p><p>In [9]:</p><pre><code>from scipy.interpolate import interp1dlinear_interp = interp1d(measured_time, measures)</code></pre><p><code>scipy.interpolate.linear_interp</code>实例需要评估感兴趣的时间点：</p><p>In [10]:</p><pre><code>computed_time = np.linspace(0, 1, 50)linear_results = linear_interp(computed_time)</code></pre><p>通过提供可选的参数<code>kind</code>也可以选择进行立方插值：</p><p>In [11]:</p><pre><code>cubic_interp = interp1d(measured_time, measures, kind='cubic')cubic_results = cubic_interp(computed_time)</code></pre><p>现在结果可以被整合为下面的Matplotlib图片：</p><p><a href="http://scipy-lectures.github.io/plot_directive/pyplots/scipy_interpolation.py"><img src="http://scipy-lectures.github.io/_images/scipy_interpolation.png" alt="img"></a></p><p><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp2d.html#scipy.interpolate.interp2d">scipy.interpolate.interp2d</a> 与<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html#scipy.interpolate.interp1d">scipy.interpolate.interp1d</a>类似，但是是用于2-D数组。注意对于<code>interp</code>家族，计算的时间点必须在测量时间段之内。看一下<a href="https://www.kancloud.cn/wizardforcel/scipy-lecture-notes/%E6%9A%82%E7%BC%BA">Sprogø气象站的最大风速预测的总结练习</a>，了解更详细的spline插值实例。</p><h2 id="1-8-数值积分："><a href="#1-8-数值积分：" class="headerlink" title="1.8 数值积分："></a>1.8 数值积分：</h2><p><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad">scipy.integrate.quad()</a>是最常见的积分程序：</p><p>In [1]:</p><pre><code>from scipy.integrate import quadres, err = quad(np.sin, 0, np.pi/2)np.allclose(res, 1)</code></pre><p>Out[1]:</p><pre><code>True</code></pre><p>In [2]:</p><pre><code>np.allclose(err, 1 - res)</code></pre><p>Out[2]:</p><pre><code>True</code></pre><p>其他的积分程序可以在<code>fixed_quad</code>、 <code>quadrature</code>、<code>romberg</code>中找到。</p><p><a href="http://docs.scipy.org/doc/scipy/reference/integrate.html#scipy.integrate">scipy.integrate</a> 可提供了常微分公式(ODE)的特色程序。特别的，<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint">scipy.integrate.odeint()</a> 是使用LSODA（Livermore Solver for Ordinary Differential equations with Automatic method switching for stiff and non-stiff problems）的通用积分器，更多细节请见<a href="http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html">ODEPACK Fortran 库</a>。</p><p><code>odeint</code>解决如下形式的第一顺序ODE系统：</p><p>$dy/dt = rhs(y1, y2, .., t0,…)$</p><p>作为一个介绍，让我们解一下在初始条件下$y(t=0) = 1$，这个常微分公式$dy/dt = -2y$在$t = 0..4$时的值。首先，这个函数计算定义位置需要的导数：</p><p>In [3]:</p><pre><code>def calc_derivative(ypos, time, counter_arr):    counter_arr += 1    return -2 * ypos</code></pre><p>添加了一个额外的参数<code>counter_arr</code>用来说明这个函数可以在一个时间步骤被调用多次，直到收敛。计数器数组定义如下：</p><p>In [4]:</p><pre><code>counter = np.zeros((1,), dtype=np.uint16)</code></pre><p>现在计算轨迹线：</p><p>In [5]:</p><pre><code>from scipy.integrate import odeinttime_vec = np.linspace(0, 4, 40)yvec, info = odeint(calc_derivative, 1, time_vec,                    args=(counter,), full_output=True)</code></pre><p>因此，导数函数被调用了40多次（即时间步骤数）：</p><p>In [6]:</p><pre><code>counter</code></pre><p>Out[6]:</p><pre><code>array([129], dtype=uint16)</code></pre><p>前十个时间步骤的累积循环数，可以用如下方式获得：</p><p>In [7]:</p><pre><code>info['nfe'][:10]</code></pre><p>Out[7]:</p><pre><code>array([31, 35, 43, 49, 53, 57, 59, 63, 65, 69], dtype=int32)</code></pre><p>注意，求解器对于首个时间步骤需要更多的循环。导数答案<code>yvec</code>可以画出来：</p><p><a href="http://scipy-lectures.github.io/plot_directive/pyplots/odeint_introduction.py"><img src="http://scipy-lectures.github.io/_images/odeint_introduction.png" alt="img"></a></p><p>阻尼弹簧重物振子（二阶振荡器）是使用<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint">scipy.integrate.odeint()</a>的另一个例子。链接到弹簧的重物的位置服从二阶常微分方程$y’’ + 2 eps wo y’ + wo^2 y = 0$，其中$wo^2 = k/m$ 弹簧的常数为k, m是重物质量，$eps=c/(2 m wo)$，c是阻尼系数。例如，我们选择如下参数：</p><p>In [8]:</p><pre><code>mass = 0.5  # kgkspring = 4  # N/mcviscous = 0.4  # N s/m</code></pre><p>因此系统将是欠阻尼的，因为：</p><p>In [9]:</p><pre><code>eps = cviscous / (2 * mass * np.sqrt(kspring/mass))eps &lt; 1</code></pre><p>Out[9]:</p><pre><code>True</code></pre><p>对于<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint">scipy.integrate.odeint()</a>求解器，二阶等式需要被变换为系统内向量$Y=(y, y’)$的两个一阶等式。为了方便，定义$nu = 2 eps * wo = c / m$和$om = wo^2 = k/m$：</p><p>In [10]:</p><pre><code>nu_coef = cviscous / massom_coef = kspring / mass</code></pre><p>因此函数将计算速度和加速度：</p><p>In [11]:</p><pre><code>def calc_deri(yvec, time, nuc, omc):    return (yvec[1], -nuc * yvec[1] - omc * yvec[0])time_vec = np.linspace(0, 10, 100)yarr = odeint(calc_deri, (1, 0), time_vec, args=(nu_coef, om_coef))</code></pre><p>如下的Matplotlib图片显示了最终的位置和速度： <a href="http://scipy-lectures.github.io/plot_directive/pyplots/odeint_damped_spring_mass.py"><img src="http://scipy-lectures.github.io/_images/odeint_damped_spring_mass.png" alt="img"></a></p><p>在Sicpy中没有偏微分方程（PDE）求解器。存在其他求解PDE的Python包，比如<a href="http://www.ctcms.nist.gov/fipy/">fipy</a>或<a href="http://code.google.com/p/sfepy/">SfePy</a>。</p><h2 id="1-9-信号处理：scipy-signal"><a href="#1-9-信号处理：scipy-signal" class="headerlink" title="1.9 信号处理：scipy.signal"></a>1.9 信号处理：<a href="http://docs.scipy.org/doc/scipy/reference/signal.html#scipy.signal">scipy.signal</a></h2><p>In [13]:</p><pre><code>from scipy import signalimport matplotlib.pyplot as pl</code></pre><ul><li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.detrend.html#scipy.signal.detrend">scipy.signal.detrend()</a>: 从信号中删除线性趋势：</li></ul><p>In [14]:</p><pre><code>t = np.linspace(0, 5, 100)x = t + np.random.normal(size=100)pl.plot(t, x, linewidth=3)pl.plot(t, signal.detrend(x), linewidth=3)</code></pre><p>Out[14]:</p><pre><code>[&lt;matplotlib.lines.Line2D at 0x10781e590&gt;]</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc096b9fe.png" alt="img"></p><ul><li><a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample.html#scipy.signal.resample">scipy.signal.resample()</a>: 用FFT从信号中抽出n个点。</li></ul><p>In [15]:</p><pre><code>t = np.linspace(0, 5, 100)x = np.sin(t)pl.plot(t, x, linewidth=3)pl.plot(t[::2], signal.resample(x, 50), 'ko')</code></pre><p>Out[15]:</p><pre><code>[&lt;matplotlib.lines.Line2D at 0x107855cd0&gt;]</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc097d313.png" alt="img"></p><ul><li><a href="http://docs.scipy.org/doc/scipy/reference/signal.html#scipy.signal">scipy.signal</a> 有许多窗口函数：<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hamming.html#scipy.signal.hamming">scipy.signal.hamming()</a>, <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bartlett.html#scipy.signal.bartlett">scipy.signal.bartlett()</a>, <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.blackman.html#scipy.signal.blackman">scipy.signal.blackman()</a>…</li><li><a href="http://docs.scipy.org/doc/scipy/reference/signal.html#scipy.signal">scipy.signal</a> 有滤镜 (中位数滤镜<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.medfilt.html#scipy.signal.medfilt">scipy.signal.medfilt()</a>, Wiener<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.wiener.html#scipy.signal.wiener">scipy.signal.wiener()</a>), 但是我们将在图片部分讨论这些。</li></ul><h2 id="1-10-图像处理：scipy-ndimage"><a href="#1-10-图像处理：scipy-ndimage" class="headerlink" title="1.10 图像处理：scipy.ndimage"></a>1.10 图像处理：scipy.ndimage</h2><p>scipy中专注于专注于图像处理的模块是scipy.ndimage。</p><p>In [18]:</p><pre><code>from scipy import ndimage</code></pre><p>图像处理程序可以根据他们进行的处理来分类。</p><h3 id="1-10-1-图像的几何变换"><a href="#1-10-1-图像的几何变换" class="headerlink" title="1.10.1 图像的几何变换"></a>1.10.1 图像的几何变换</h3><p>改变原点，解析度，..</p><p>In [19]:</p><pre><code>from scipy import miscimport matplotlib.pyplot as pllena = misc.lena()shifted_lena = ndimage.shift(lena, (50, 50))shifted_lena2 = ndimage.shift(lena, (50, 50), mode='nearest')rotated_lena = ndimage.rotate(lena, 30)cropped_lena = lena[50:-50, 50:-50]zoomed_lena = ndimage.zoom(lena, 2)zoomed_lena.shape</code></pre><p>Out[19]:</p><pre><code>(1024, 1024)</code></pre><p><img src="http://scipy-lectures.github.io/_images/lena_transforms.png" alt="img"></p><p>In [25]:</p><pre><code>subplot(151)pl.imshow(shifted_lena, cmap=cm.gray)axis('off')</code></pre><p>Out[25]:</p><pre><code>(-0.5, 511.5, 511.5, -0.5)</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc098ef28.png" alt="img"></p><h3 id="1-10-2-图像滤波器"><a href="#1-10-2-图像滤波器" class="headerlink" title="1.10.2 图像滤波器"></a>1.10.2 图像滤波器</h3><p>In [26]:</p><pre><code>from scipy import misclena = misc.lena()import numpy as npnoisy_lena = np.copy(lena).astype(np.float)noisy_lena += lena.std()*0.5*np.random.standard_normal(lena.shape)blurred_lena = ndimage.gaussian_filter(noisy_lena, sigma=3)median_lena = ndimage.median_filter(blurred_lena, size=5)from scipy import signalwiener_lena = signal.wiener(blurred_lena, (5,5))</code></pre><p><img src="http://scipy-lectures.github.io/_images/filtered_lena.png" alt="img"> 在<a href="http://docs.scipy.org/doc/scipy/reference/ndimage.html#scipy.ndimage.filters">scipy.ndimage.filters</a> 和 <a href="http://docs.scipy.org/doc/scipy/reference/signal.html#scipy.signal">scipy.signal</a> 有更多应用于图像的滤波器。</p><p>练习</p><p>比较不同过滤后图像的条形图</p><h3 id="1-10-3-数学形态学"><a href="#1-10-3-数学形态学" class="headerlink" title="1.10.3 数学形态学"></a>1.10.3 数学形态学</h3><p>数学形态学是集合理论分支出来的一个数学理论。它刻画并转换几何结构。特别是二元的图像（黑白）可以用这种理论来转换：被转换的集合是临近非零值像素的集合。这个理论也可以被扩展到灰度值图像。 <img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/morpho_mat1.png" alt="img"></p><p>初级数学形态学操作使用结构化的元素，以便修改其他几何结构。</p><p>首先让我们生成一个结构化元素。</p><p>In [27]:</p><pre><code>el = ndimage.generate_binary_structure(2, 1)el</code></pre><p>Out[27]:</p><pre><code>array([[False,  True, False],       [ True,  True,  True],       [False,  True, False]], dtype=bool)</code></pre><p>In [28]:</p><pre><code>el.astype(np.int)</code></pre><p>Out[28]:</p><pre><code>array([[0, 1, 0],       [1, 1, 1],       [0, 1, 0]])</code></pre><ul><li>腐蚀</li></ul><p>In [29]:</p><pre><code>a = np.zeros((7,7), dtype=np.int)a[1:6, 2:5] = 1a</code></pre><p>Out[29]:</p><pre><code>array([[0, 0, 0, 0, 0, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 0, 0, 0, 0, 0]])</code></pre><p>In [30]:</p><pre><code>ndimage.binary_erosion(a).astype(a.dtype)</code></pre><p>Out[30]:</p><pre><code>array([[0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 1, 0, 0, 0],       [0, 0, 0, 1, 0, 0, 0],       [0, 0, 0, 1, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0]])</code></pre><p>In [31]:</p><pre><code>#腐蚀移除了比结构小的对象ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)</code></pre><p>Out[31]:</p><pre><code>array([[0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0]])</code></pre><ul><li>扩张</li></ul><p>In [32]:</p><pre><code>a = np.zeros((5, 5))a[2, 2] = 1a</code></pre><p>Out[32]:</p><pre><code>array([[ 0.,  0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.,  0.],       [ 0.,  0.,  1.,  0.,  0.],       [ 0.,  0.,  0.,  0.,  0.],       [ 0.,  0.,  0.,  0.,  0.]])</code></pre><p>In [33]:</p><pre><code>ndimage.binary_dilation(a).astype(a.dtype)</code></pre><p>Out[33]:</p><pre><code>array([[ 0.,  0.,  0.,  0.,  0.],       [ 0.,  0.,  1.,  0.,  0.],       [ 0.,  1.,  1.,  1.,  0.],       [ 0.,  0.,  1.,  0.,  0.],       [ 0.,  0.,  0.,  0.,  0.]])</code></pre><ul><li>开启</li></ul><p>In [34]:</p><pre><code>a = np.zeros((5,5), dtype=np.int)a[1:4, 1:4] = 1; a[4, 4] = 1a</code></pre><p>Out[34]:</p><pre><code>array([[0, 0, 0, 0, 0],       [0, 1, 1, 1, 0],       [0, 1, 1, 1, 0],       [0, 1, 1, 1, 0],       [0, 0, 0, 0, 1]])</code></pre><p>In [35]:</p><pre><code># 开启移除了小对象ndimage.binary_opening(a, structure=np.ones((3,3))).astype(np.int)</code></pre><p>Out[35]:</p><pre><code>array([[0, 0, 0, 0, 0],       [0, 1, 1, 1, 0],       [0, 1, 1, 1, 0],       [0, 1, 1, 1, 0],       [0, 0, 0, 0, 0]])</code></pre><p>In [36]:</p><pre><code># 开启也可以平滑拐角ndimage.binary_opening(a).astype(np.int)</code></pre><p>Out[36]:</p><pre><code>array([[0, 0, 0, 0, 0],       [0, 0, 1, 0, 0],       [0, 1, 1, 1, 0],       [0, 0, 1, 0, 0],       [0, 0, 0, 0, 0]])</code></pre><ul><li>闭合: <code>ndimage.binary_closing</code></li></ul><p>练习</p><p>验证一下开启相当于先腐蚀再扩张。</p><p>开启操作移除小的结构，而关闭操作填满了小洞。因此这些用来”清洗“图像。</p><p>In [37]:</p><pre><code>a = np.zeros((50, 50))a[10:-10, 10:-10] = 1a += 0.25*np.random.standard_normal(a.shape)mask = a&gt;=0.5opened_mask = ndimage.binary_opening(mask)closed_mask = ndimage.binary_closing(opened_mask)</code></pre><p><img src="http://scipy-lectures.github.io/_images/morpho.png" alt="img"></p><p>练习</p><p>验证一下重建的方格面积比原始方格的面积小。（如果关闭步骤在开启步骤之前则相反）。</p><p>对于_灰度值图像_，腐蚀（区别于扩张）相当于用感兴趣的像素周围的结构元素中的最小（区别于最大）值替换像素。</p><p>In [39]:</p><pre><code>a = np.zeros((7,7), dtype=np.int)a[1:6, 1:6] = 3a[4,4] = 2; a[2,3] = 1a</code></pre><p>Out[39]:</p><pre><code>array([[0, 0, 0, 0, 0, 0, 0],       [0, 3, 3, 3, 3, 3, 0],       [0, 3, 3, 1, 3, 3, 0],       [0, 3, 3, 3, 3, 3, 0],       [0, 3, 3, 3, 2, 3, 0],       [0, 3, 3, 3, 3, 3, 0],       [0, 0, 0, 0, 0, 0, 0]])</code></pre><p>In [40]:</p><pre><code>ndimage.grey_erosion(a, size=(3,3))</code></pre><p>Out[40]:</p><pre><code>array([[0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 1, 1, 1, 0, 0],       [0, 0, 3, 2, 2, 0, 0],       [0, 0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0, 0]])</code></pre><h3 id="1-10-4-测量图像"><a href="#1-10-4-测量图像" class="headerlink" title="1.10.4 测量图像"></a>1.10.4 测量图像</h3><p>首先让我们生成一个漂亮的人造二维图。</p><p>In [41]:</p><pre><code>x, y = np.indices((100, 100))sig = np.sin(2*np.pi*x/50.)*np.sin(2*np.pi*y/50.)*(1+x*y/50.**2)**2mask = sig &gt; 1</code></pre><p>现在让我们看一下图像中对象的各种信息：</p><p>In [42]:</p><pre><code>labels, nb = ndimage.label(mask)nb</code></pre><p>Out[42]:</p><pre><code>8</code></pre><p>In [43]:</p><pre><code>areas = ndimage.sum(mask, labels, xrange(1, labels.max()+1))areas</code></pre><p>Out[43]:</p><pre><code>array([ 190.,   45.,  424.,  278.,  459.,  190.,  549.,  424.])</code></pre><p>In [44]:</p><pre><code>maxima = ndimage.maximum(sig, labels, xrange(1, labels.max()+1))maxima</code></pre><p>Out[44]:</p><pre><code>array([  1.80238238,   1.13527605,   5.51954079,   2.49611818,         6.71673619,   1.80238238,  16.76547217,   5.51954079])</code></pre><p>In [45]:</p><pre><code>ndimage.find_objects(labels==4)</code></pre><p>Out[45]:</p><pre><code>[(slice(30L, 48L, None), slice(30L, 48L, None))]</code></pre><p>In [46]:</p><pre><code>sl = ndimage.find_objects(labels==4)import pylab as plpl.imshow(sig[sl[0]])   </code></pre><p>Out[46]:</p><pre><code>&lt;matplotlib.image.AxesImage at 0x10a861910&gt;</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc09a1907.png" alt="img"></p><p><img src="http://scipy-lectures.github.io/_images/measures.png" alt="img"></p><p>高级例子请看一下总结练习<a href="http://scipy-lectures.github.io/intro/summary-exercises/image-processing.html#summary-exercise-image-processing">图像处理应用：计数气泡和未融化的颗粒</a></p><h2 id="1-11-科学计算的总结练习"><a href="#1-11-科学计算的总结练习" class="headerlink" title="1.11 科学计算的总结练习"></a>1.11 科学计算的总结练习</h2><p>总结练习主要使用Numpy、Scipy 和 Matplotlib。他们提供了一些使用Python进行科学计算的真实例子。现在，已经介绍了Numpy和Scipy的基本使用，邀请感兴趣的用户去做这些练习。</p><p><strong>练习：</strong></p><p><a href="http://scipy-lectures.github.io/intro/summary-exercises/stats-interpolate.html">1.5.11.13 Sprogø气象站的最大风速预测</a></p><p><a href="http://scipy-lectures.github.io/intro/summary-exercises/optimize-fit.html">1.5.11.14 非线性最小二乘曲线拟合：地形机载激光雷达数据中的点抽取</a></p><p><a href="http://scipy-lectures.github.io/intro/summary-exercises/image-processing.html">1.5.11.15 图像处理应用：计数气泡和未融化的颗粒</a></p><p><strong>提议的解决方案:</strong></p><p><a href="http://scipy-lectures.github.io/intro/summary-exercises/answers_image_processing.html">1.5.11.16 图像处理练习：玻璃中的未融化颗粒的答案例子</a></p><h3 id="1-11-13-Sprogo气象站的最大风速预测"><a href="#1-11-13-Sprogo气象站的最大风速预测" class="headerlink" title="1.11.13 Sprogø气象站的最大风速预测"></a>1.11.13 Sprogø气象站的最大风速预测</h3><p>这个练习的目的是预测每50年的最大风速，即使在一个时间段内有记录。可用的数据只是位于丹麦的Sprogø气象站的21年的测量数据。首先，将给出统计步骤，接着将用scipy.interpolae模块中的函数来解释。在最后，将邀请感兴趣的读者用不同的方法从原始数据计算结果。</p><h4 id="1-11-13-1-统计方法"><a href="#1-11-13-1-统计方法" class="headerlink" title="1.11.13.1 统计方法"></a>1.11.13.1 统计方法</h4><p>假设年度最大值符合正态概率密度函数。但是，这个函数不能用来预测，因为它从速度最大值中给出了概率。找到每50年的最大风速需要相反的方法，需要从确定的概率中找到结果。这是百分位数函数的作用而这个练习的目的是找到它。在当前的模型中，假设每50年出现的最大风速定义为高于2%百分位数。</p><p>根据定义，百分位数函数是累积分布函数的反函数。后者描述了年度最大值的概率分布。在这个练习中，给定年份$i$的累积概率$p_i$被定义为$p_i = i/(N+1)$，其中$N = 21$，测量的年数。因此，计算每个测量过的风速最大值的累积概率是可以行的。从这些实验点，scipy.interpolate模块将对拟合百分位数函数非常有用。最后，50年的最大值将从累积概率的2%百分位数中预估出来。</p><h4 id="1-11-13-2-计算累积概率"><a href="#1-11-13-2-计算累积概率" class="headerlink" title="1.11.13.2 计算累积概率"></a>1.11.13.2 计算累积概率</h4><p>计算好的numpy格式的年度风速最大值存储在<a href="http://scipy-lectures.github.io/_downloads/max-speeds.npy">examples/max-speeds.npy</a>文件中, 因此，可以用numpy加载：</p><p>In [4]:</p><pre><code>import numpy as npmax_speeds = np.load('data/max-speeds.npy')years_nb = max_speeds.shape[0]</code></pre><p>下面是前面板块的累积概率定义$p_i$，对应值将为：</p><p>In [5]:</p><pre><code>cprob = (np.arange(years_nb, dtype=np.float32) + 1)/(years_nb + 1)</code></pre><p>并且假设他们可以拟合给定的风速：</p><p>In [6]:</p><pre><code>sorted_max_speeds = np.sort(max_speeds)</code></pre><h4 id="1-11-13-3-用UnivariateSpline预测"><a href="#1-11-13-3-用UnivariateSpline预测" class="headerlink" title="1.11.13.3 用UnivariateSpline预测"></a>1.11.13.3 用UnivariateSpline预测</h4><p>在这个部分，百分位数函数将用<code>UnivariateSpline</code>类来估计，这个类用点代表样条。 默认行为是构建一个3度的样条，不同的点根据他们的可靠性可能有不同的权重。相关的变体还有<code>InterpolatedUnivariateSpline</code>和<code>LSQUnivariateSpline</code>，差别在于检查误差的方式不同。如果需要2D样条，可以使用<code>BivariateSpline</code>家族类。所有这些1D和2D样条使用FITPACK Fortran 程序，这就是为什么通过<code>splrep</code>和<code>splev</code>函数来表征和评估样条的库更少。同时，不使用FITPACK参数的插值函数也提供更简便的用法（见<code>interp1d</code>, <code>interp2d</code>, <code>barycentric_interpolate</code>等等）。 对于Sprogø最大风速的例子，将使用<code>UnivariateSpline</code>，因为3度的样条似乎可以正确拟合数据：</p><p>In [7]:</p><pre><code>from scipy.interpolate import UnivariateSplinequantile_func = UnivariateSpline(cprob, sorted_max_speeds)</code></pre><p>百分位数函数将用评估来所有范围的概率：</p><p>In [8]:</p><pre><code>nprob = np.linspace(0, 1, 1e2)fitted_max_speeds = quantile_func(nprob)</code></pre><p>在当前的模型中，每50年出现的最大风速被定义为大于2%百分位数。作为结果，累积概率值将是：</p><p>In [9]:</p><pre><code>fifty_prob = 1. - 0.02</code></pre><p>因此，可以猜测50年一遇的暴风雪风速为：</p><p>In [10]:</p><pre><code>fifty_wind = quantile_func(fifty_prob)fifty_wind  </code></pre><p>Out[10]:</p><pre><code>array(32.97989825386221)</code></pre><p>现在，结果被收集在Matplotlib图片中：</p><p><img src="http://scipy-lectures.github.io/_images/plot_cumulative_wind_speed_prediction_1.png" alt="img"></p><p>答案：<a href="http://scipy-lectures.github.io/intro/summary-exercises/auto_examples/plot_cumulative_wind_speed_prediction.html#example-plot-cumulative-wind-speed-prediction-py">Python源文件</a></p><h4 id="1-11-13-4-Gumbell分布练习"><a href="#1-11-13-4-Gumbell分布练习" class="headerlink" title="1.11.13.4 Gumbell分布练习"></a>1.11.13.4 Gumbell分布练习</h4><p>现在邀请感兴趣的读者用21年测量的风速做一个练习。测量区间为90分钟（原始的区间约为10分钟，但是，为了让练习的设置简单一些，缩小了文件的大小）。数据以numpy格式存储在文件<a href="http://scipy-lectures.github.io/_downloads/sprog-windspeeds.npy">examples/sprog-windspeeds.npy</a>中。 在完成练习后，不要看绘图的源代码。</p><ul><li>第一步将是通过使用numpy来找到年度最大值，然后将它们绘制为matplotlibe条形图。 <img src="http://scipy-lectures.github.io/_images/plot_sprog_annual_maxima_1.png" alt="img"></li></ul><p>答案：<a href="http://scipy-lectures.github.io/intro/summary-exercises/auto_examples/plot_sprog_annual_maxima.html#example-plot-sprog-annual-maxima-py">Python源文件</a></p><ul><li>第二步将是在累积概率$p_i$使用Gumbell分布，$p_i$的定义是$-log( -log(p_i) )$用来拟合线性百分位数函数（记住你可以定义UnivariateSpline的度数）。 绘制年度最大值和Gumbell分布将生产如下图片。</li></ul><p><img src="http://scipy-lectures.github.io/_images/plot_gumbell_wind_speed_prediction_1.png" alt="img"></p><p>答案：<a href="http://scipy-lectures.github.io/intro/summary-exercises/auto_examples/plot_gumbell_wind_speed_prediction.html#example-plot-gumbell-wind-speed-prediction-py">Python源文件</a></p><ul><li>最后一步将是找到在每50年出现的最大风速34.23 m/s。</li></ul><h3 id="1-11-14-非线性最小二乘曲线拟合：地理雷达数据中的点抽取应用"><a href="#1-11-14-非线性最小二乘曲线拟合：地理雷达数据中的点抽取应用" class="headerlink" title="1.11.14 非线性最小二乘曲线拟合：地理雷达数据中的点抽取应用"></a>1.11.14 非线性最小二乘曲线拟合：地理雷达数据中的点抽取应用</h3><p>这个练习的目的是用模型去拟合一些数据。这篇教程中的数据是雷达数据，下面的介绍段落将详细介绍。如果你没有耐心，想要马上进行联系，那么请跳过这部分，并直接进入<a href="http://scipy-lectures.github.io/intro/summary-exercises/optimize-fit.html#first-step">加载和可视化</a>。</p><h4 id="1-11-14-1-介绍"><a href="#1-11-14-1-介绍" class="headerlink" title="1.11.14.1 介绍"></a>1.11.14.1 介绍</h4><p>雷达系统是光学测距仪，通过分析离散光的属性来测量距离。绝大多数光学测距仪向目标发射一段短光学脉冲，然后记录反射信号。然后处理这个信号来抽取雷达系统与目标间的距离。</p><p>地形雷达系统是嵌入在飞行平台的雷达系统。它们测量平台与地球的距离，以便计算出地球的地形信息（更多细节见[<a href="http://scipy-lectures.github.io/intro/summary-exercises/optimize-fit.html#mallet">1]</a>）。</p><p>[1] Mallet, C. and Bretar, F. Full-Waveform Topographic Lidar: State-of-the-Art. ISPRS Journal of Photogrammetry and Remote Sensing 64(1), pp.1-16, January 2009 <a href="http://dx.doi.org/10.1016/j.isprsjprs.2008.09.007">http://dx.doi.org/10.1016/j.isprsjprs.2008.09.007</a></p><p>这篇教程的目的是分析雷达系统记录到的波形数据[<a href="http://scipy-lectures.github.io/intro/summary-exercises/optimize-fit.html#data">2]</a>。这种信号包含波峰，波峰的中心和振幅可以用来计算命中目标的位置和一些特性。当激光柱的脚步距离地球表面1m左右，光柱可以在二次传播时击中多个目标（例如，地面和树木或建筑的顶部）。激光柱的击中每个目标的贡献之和会产生一个有多个波峰的复杂波，每一个包含一个目标的信息。</p><p>一种从这些数据中抽取信息的先进方法是在一个高斯函数和中分解这些信息，每个函数代表激光柱击中的一个目标的贡献。</p><p>因此，我们使用<code>the scipy.optimize</code>模块将波形拟合为一个高斯函数或高斯函数之和。</p><h4 id="1-11-14-2-加载和可视化"><a href="#1-11-14-2-加载和可视化" class="headerlink" title="1.11.14.2 加载和可视化"></a>1.11.14.2 加载和可视化</h4><p>加载第一个波形：</p><p>In [1]:</p><pre><code>import numpy as npwaveform_1 = np.load('data/waveform_1.npy')</code></pre><p>接着可视化：</p><p>In [2]:</p><pre><code>import matplotlib.pyplot as pltt = np.arange(len(waveform_1))plt.plot(t, waveform_1)plt.show()</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc09b8981.png" alt="img"></p><p>你可以注意到，这个波形是单峰80个区间的信息。</p><h4 id="1-11-14-3-用简单的高斯模型拟合波形"><a href="#1-11-14-3-用简单的高斯模型拟合波形" class="headerlink" title="1.11.14.3 用简单的高斯模型拟合波形"></a>1.11.14.3 用简单的高斯模型拟合波形</h4><p>这个信号非常简单，可以被建模为一个高斯函数，抵消相应的背景噪音。要用函数拟合这个信号，我们必须：</p><ul><li>定义一个模型</li><li>给出初始解</li><li>调用<code>scipy.optimize.leastsq</code></li></ul><h5 id="1-11-14-3-1-模型"><a href="#1-11-14-3-1-模型" class="headerlink" title="1.11.14.3.1 模型"></a>1.11.14.3.1 模型</h5><p>高斯函数定义如下：</p><p>$B + A \exp\left{-\left(\frac{t-\mu}{\sigma}\right)^2\right}$</p><p>在Python中定义如下：</p><p>In [3]:</p><pre><code>def model(t, coeffs):    return coeffs[0] + coeffs[1] * np.exp( - ((t-coeffs[2])/coeffs[3])**2 )</code></pre><p>其中</p><ul><li>coeffs[0] is $B$ (noise)</li><li>coeffs[1] is $A$ (amplitude)</li><li>coeffs[2] is $\mu$ (center)</li><li>coeffs[3] is $\sigma$ (width)</li></ul><h5 id="1-11-14-3-2-初始解"><a href="#1-11-14-3-2-初始解" class="headerlink" title="1.11.14.3.2 初始解"></a>1.11.14.3.2 初始解</h5><p>通过观察图形，我们可以找到大概的初始解，例如：</p><p>In [5]:</p><pre><code>x0 = np.array([3, 30, 15, 1], dtype=float)</code></pre><h5 id="1-11-14-3-3-拟合"><a href="#1-11-14-3-3-拟合" class="headerlink" title="1.11.14.3.3 拟合"></a>1.11.14.3.3 拟合</h5><p><code>scipy.optimize.leastsq</code>最小化作为参数给到的函数的平方和。本质上来说，函数最小化的是残差（数据与模型的差异）：</p><p>In [6]:</p><pre><code>def residuals(coeffs, y, t):    return y - model(t, coeffs)</code></pre><p>因此，让我们通过下列参数调用<code>scipy.optimize.leastsq</code>来求解：</p><ul><li>最小化的函数</li><li>初始解</li><li>传递给函数的额外参数</li></ul><p>In [7]:</p><pre><code>from scipy.optimize import leastsqx, flag = leastsq(residuals, x0, args=(waveform_1, t))print x[  2.70363341  27.82020741  15.47924562   3.05636228]</code></pre><p>答案可视化：</p><p>In [8]:</p><pre><code>plt.plot(t, waveform_1, t, model(t, x))plt.legend(['waveform', 'model'])plt.show()</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/2016-03-21_56efdc09cbc26.png" alt="img"></p><p>备注：从scipy v0.8及以上，你应该使用<code>scipy.optimize.curve_fit</code>，它使用模型和数据作为参数，因此，你不再需要定义残差。</p><h4 id="1-11-14-4-更进一步"><a href="#1-11-14-4-更进一步" class="headerlink" title="1.11.14.4 更进一步"></a>1.11.14.4 更进一步</h4><ul><li>试一下包含三个波峰的更复杂波形（例如<a href="https://github.com/scipy-lectures/scipy-lecture-notes/raw/master/data/waveform_2.npy">data/waveform_2.npy</a>）。你必须调整模型，现在它是高斯函数之和，而不是只有一个高斯波峰。</li></ul><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/waveform_2.png" alt="img"></p><ul><li>在一些情况下，写一个函数来计算Jacobian，要比让leastsq从数值上估计它来的快。创建一个函数来计算残差的Jacobian，并且用它作为leastsq的一个输入。</li><li>当我们想要识别信号中非常小的峰值，或者初始的猜测离好的解决方案太远时，算法给出的结果往往不能令人满意。为模型参数添加限制可以确保克服这些局限性。我们可以添加的先前经验是变量的符号（都是正的）。</li></ul><p>用下列初始解：</p><p>In [9]:</p><pre><code>x0 = np.array([3, 50, 20, 1], dtype=float)</code></pre><p>添加了边界限制之后比较一下<code>scipy.optimize.leastsq</code>与<code>scipy.optimize.fmin_slsqp</code>的结果。</p><p>[2] 本教程的数据部分来自于<a href="http://fullanalyze.sourceforge.net/">FullAnalyze software</a>的演示数据，由 <a href="http://www.ore.fr/rubrique.php3?id_rubrique=24">GIS DRAIX</a> 友情提供。</p><h3 id="1-11-15-图像处理应用：计数气泡和未融化的颗粒"><a href="#1-11-15-图像处理应用：计数气泡和未融化的颗粒" class="headerlink" title="1.11.15 图像处理应用：计数气泡和未融化的颗粒"></a>1.11.15 图像处理应用：计数气泡和未融化的颗粒</h3><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/MV_HFV_012.jpg" alt="img"></p><h4 id="1-11-15-1-问题描述"><a href="#1-11-15-1-问题描述" class="headerlink" title="1.11.15.1 问题描述"></a>1.11.15.1 问题描述</h4><ol><li><p>打开图像文件MV_HFV_012.jpg并且浏览一下。看一下imshow文档字符串中的参数，用“右”对齐来显示图片（原点在左下角，而不是像标准数组在右上角）。</p><p>这个扫描元素显微图显示了一个带有一些气泡（黑色）和未溶解沙（深灰）的玻璃样本（轻灰矩阵）。我们想要判断样本由三个状态覆盖的百分比，并且预测沙粒和气泡的典型大小和他们的大小等。</p></li><li><p>修建图片，删除带有测量信息中底部面板。</p></li><li><p>用中位数过滤稍稍过滤一下图像以便改进它的直方图。看一下直方图的变化。</p></li><li><p>使用过滤后图像的直方图，决定允许定义沙粒像素，玻璃像素和气泡像素掩蔽的阈限。其他的选项（家庭作业）：写一个函数从直方图的最小值自动判断阈限。</p></li><li><p>将三种不同的相用不同的颜色上色并显示图片。</p></li><li><p>用数学形态学清理不同的相。</p></li><li><p>为所有气泡和沙粒做标签，从沙粒中删除小于10像素的掩蔽。要这样做，用<code>ndimage.sum</code>或<code>np.bincount</code>来计算沙粒大小。</p></li><li><p>计算气泡的平均大小。</p></li></ol><h3 id="1-11-16-图像处理练习：玻璃中的未融化颗粒的答案例子"><a href="#1-11-16-图像处理练习：玻璃中的未融化颗粒的答案例子" class="headerlink" title="1.11.16 图像处理练习：玻璃中的未融化颗粒的答案例子"></a>1.11.16 图像处理练习：玻璃中的未融化颗粒的答案例子</h3><p>In [1]:</p><pre><code>import numpy as npimport pylab as plfrom scipy import ndimage</code></pre><p><img src="http://scipy-lectures.github.io/_images/MV_HFV_012.jpg" alt="img"></p><ul><li>打开图像文件MV_HFV_012.jpg并且浏览一下。看一下imshow文档字符串中的参数，用“右”对齐来显示图片（原点在左下角，而不是像标准数组在右上角）。</li></ul><p>In [3]:</p><pre><code>dat = pl.imread('data/MV_HFV_012.jpg')</code></pre><ul><li>修建图片，删除带有测量信息中底部面板。</li></ul><p>In [4]:</p><pre><code>dat = dat[60:]</code></pre><ul><li>用中位数过滤稍稍过滤一下图像以便改进它的直方图。看一下直方图的变化。</li></ul><p>In [5]:</p><pre><code>filtdat = ndimage.median_filter(dat, size=(7,7))hi_dat = np.histogram(dat, bins=np.arange(256))hi_filtdat = np.histogram(filtdat, bins=np.arange(256))</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/exo_histos.png" alt="img"></p><ul><li>使用过滤后图像的直方图，决定允许定义沙粒像素，玻璃像素和气泡像素掩蔽的阈限。其他的选项（家庭作业）：写一个函数从直方图的最小值自动判断阈限。</li></ul><p>In [6]:</p><pre><code>void = filtdat &lt;= 50sand = np.logical_and(filtdat &gt; 50, filtdat &lt;= 114)glass = filtdat &gt; 114</code></pre><ul><li>将三种不同的相用不同的颜色上色并显示图片。</li></ul><p>In [7]:</p><pre><code>phases = void.astype(np.int) + 2*glass.astype(np.int) + 3*sand.astype(np.int)</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/three_phases.png" alt="img"></p><ul><li>用数学形态学清理不同的相。</li></ul><p>In [8]:</p><pre><code>sand_op = ndimage.binary_opening(sand, iterations=2)</code></pre><ul><li>为所有气泡和沙粒做标签，从沙粒中删除小于10像素的掩蔽。要这样做，用<code>ndimage.sum</code>或<code>np.bincount</code>来计算沙粒大小。</li></ul><p>In [9]:</p><pre><code>sand_labels, sand_nb = ndimage.label(sand_op)sand_areas = np.array(ndimage.sum(sand_op, sand_labels, np.arange(sand_labels.max()+1)))mask = sand_areas &gt; 100remove_small_sand = mask[sand_labels.ravel()].reshape(sand_labels.shape)</code></pre><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-data-analysis-scipy.assets/sands.png" alt="img"></p><ul><li>计算气泡的平均大小。</li></ul><p>In [10]:</p><pre><code>bubbles_labels, bubbles_nb = ndimage.label(void)bubbles_areas = np.bincount(bubbles_labels.ravel())[1:]mean_bubble_size = bubbles_areas.mean()median_bubble_size = np.median(bubbles_areas)mean_bubble_size, median_bubble_size</code></pre><p>Out[10]:</p><pre><code>(2416.863157894737, 60.0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Analysis -- NumPy</title>
      <link href="/2020/01/04/20200104-data-analysis-numpy/"/>
      <url>/2020/01/04/20200104-data-analysis-numpy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>NumPy（Numerical Python 的简称），是 Python 语言的一个扩展程序库，提供了高效存储和操作密集数据缓存的接口。 支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p>NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy  为开放源代码并且由许多协作者共同维护开发。</p><p>在某些方面， NumPy 数组与Python 内置的列表类型非常相似。 但是随着数组在维度上变大， NumPy 数组提供了更加高效的存储和数据操作。 NumPy 数组几乎是整个Python 数据科学工具生态系统的核心。</p><p>NumPy 是一个运行速度非常快的数学库，主要用于多维数组计算，包含：</p><ul><li>一个强大的N维核心数组对象 ndarray，对大量矩阵运算提供支撑</li><li>广播功能函数</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><p>NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用， 这种组合广泛用于替代 MatLab，是一个强大的科学计算环境，有助于通过 Python 学习数据科学或者机器学习。</p><p>SciPy 是一个开源的 Python 算法库和数学工具包，包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。</p><p>Matplotlib 是 Python 编程语言及其数值数学扩展包 NumPy 的可视化操作界面。它为利用通用的图形用户界面工具包，如 Tkinter, wxPython, Qt 或 GTK+ 向应用程序嵌入式绘图提供了应用程序接口（API）。</p><pre><code># pip install NumPy import NumPy as np # 通常的导入方式 print(np.__version__) &gt;&gt;&gt; 1.13.1 </code></pre><p>这里不得不提到 Octave（模仿 Matlab 的 GNU 开源软件），它是另一个在科学计算领域应用广泛的开发环境，作者 John W. Eaton。实际上 Octave 之所以易于使用，从而也被广泛应用在教学领域，在于它沿用 Matlab  在各个轴上的定义与笛卡尔坐标系（Cartesian coordinates）保持一致，从而避免了学习梯度的陡升。掌握 NumPy  的关键就是理解不同维度数组的轴，以及建立在轴上的复杂变换（高维数组上轴的定义与 Octave 不同，这让 NumPy 看起来有些混乱）。</p><p>这里使用 2D 数组在 Octave 和 NumPy 上做一对比：</p><pre><code>octave:2&gt; A = [1 2 3; 4 5 6] A =  1   2   3 4   5   6; </code></pre><p>上下比较，哪一个更简洁更易理解是非常明显的，NumPy 在数组显示上要糟糕得多，这还是在只有 2D 的情况下：</p><pre><code>In [1]: A = np.array([[1, 2, 3], [4, 5, 6]]) In [2]: A Out[2]: array([[1, 2, 3],       [4, 5, 6]]) </code></pre><p>我们再看一个 3D 的例子，以说明各个轴和笛卡尔坐标系的关系：</p><pre><code>octave:1&gt; A = reshape ([0, 1, 2, 3, 4, 5, 6, 7], 2, 2, 2) A = ans(:,:,1) =                    0   2                1   3 ans(:,:,2) =    4   6                  5   7 </code></pre><p>octave 的下标总是从 1 开始，常规思维 [1,1,2]（对应 Numpy 的索引为 [0,0,1]）的元素是什么？</p><pre><code># octave 通过圆括号 '()' 进行索引 octave:3&gt; A(1,1,2) ans =  4 </code></pre><p>这里不对 octave 如何进行 reshape 进行深入分析。这里的重点在于 [1,1,1] 对应了 x, y 和 z，通过直观思考就可以得出值为 4。而 Numpy 却不同：</p><pre><code>In [1]: a Out[1]: array([[[0, 1],                       [2, 3]],                      [[4, 5],                    [6, 7]]]) In [2]: a[0,0,1] Out[2]: 1 </code></pre><p>你可能会认为结果是 4，而事实并非如此，在数组坐标轴这一节会分析这一令人迷惑的问题。</p><p>NumPy 另一个令人诟病的地方就是不支持列向量，也即只能使用 Nx1 的 2D 数组来模拟，而行向量却是 1D  的，这看起来非常不合理（Stupid！），所以没有任何经验的人使用 Octave 并基于正常思维掌握它是非常迅速的，而要掌握  NumPy，使用直觉思维是不现实的，你在尝试解读代码时必须要经过一个短暂的转换思考过程。</p><h2 id="1-1-数组属性和类型"><a href="#1-1-数组属性和类型" class="headerlink" title="1.1. 数组属性和类型"></a>1.1. 数组属性和类型</h2><p>从打印的 nparray 结果看，ndarray 类型的数组与Python 列表类似， 但是它是一个 ndarray 对象，它为高效地存储和操作大型数组提供了数据存储的支撑。</p><pre><code>list0 = [1,2,3] nparray = np.array(list0) print(nparray) print(type(list0).__name__, type(nparray).__name__) &gt;&gt;&gt; [1 2 3] list ndarray </code></pre><p>ndarray（n dimention array，多维数组）对象是 NumPy 的数据承载核心。</p><h3 id="1-1-1-数组属性"><a href="#1-1-1-数组属性" class="headerlink" title="1.1.1. 数组属性"></a>1.1.1. 数组属性</h3><p>首先使用 zeros() 生成1-3不同维度的全0数组：</p><pre><code>X1 = np.zeros(2)           # 生成 1 维数组 X2 = np.zeros((2,2))       # 生成 2 维数组 X3 = np.zeros((2,2,2))     # 生成 3 维数组 print("{}{}{}".format(X1, X2, X3),sep='\n') &gt;&gt;&gt; [ 0.  0.]    # 1 维数组[[ 0.  0.]   # 2 维数组 [ 0.  0.]] [[[ 0.  0.]  # 3 维数组     [ 0.  0.]]    [[ 0.  0.]     [ 0.  0.]]] </code></pre><p>我们可以通过数第一行开始连续左中括号 “[” 的个数来判断数组的维数。而判断数组的各个维的长度，则可以从内向外进行，也即从最内层向最外层数：</p><ul><li>如下所示的数组，首先查看最内层元素 [ 0.  0.]，元素个数为 2 个，所以最后一维的维数为 2</li><li>接着把 [ 0.  0.] 看做一个整体单元，查看外层括号包含多少个此单元，显然为 2 个</li><li>然后再把 [[ 0.  0.] [ 0.  0.]]，看做一个整体单元，继续查看外层包含多少个此单元，显然只有 1 个</li><li>以此类推，直至遍历完所有中括号，显然下面代码中的数组的 shape 为 (1,2,2)。</li></ul><pre><code>[[[ 0.  0.]    [ 0.  0.]]] </code></pre><p>描述数组大小的属性有三个：</p><ul><li>nidm：描述数组的维度（dimensions），也被称为轴数（axes），为整数，对于三维数组来说它有 3 个轴，通常记为 x,y,z，这与真实世界的三维空间坐标轴是一致的。</li><li>shape：由每个轴（axis，也即每个维）的长度大小组成的元组类型，一个轴上的元素数称为这个轴的长度，注意和数组维度区别。</li><li>size：数组的元素总个数，整数，size 等于 shape 中所有元素相乘: size = np.prod(a.shape)。</li></ul><pre><code>for i in range(1,4,1):       x = eval('X' + str(i))        print('X' + str(i), "ndim: {} shape: {} size: {}".format(x.ndim, x.shape, x.size)) &gt;&gt;&gt; X1 ndim: 1 shape: (2,) size: 2 X2 ndim: 2 shape: (2, 2) size: 4 X3 ndim: 3 shape: (2, 2, 2) size: 8 </code></pre><p>用于描述数组元素存储的属性有：</p><ul><li>dtype：数组元素类型，决定了每个元素的大小，例如 int32，float64。</li><li>itemsize：表示每个元素占用字节大小。</li><li>nbytes：表示数组中数据部分所占的字节大小，通常 nbytes = itemsize * size。</li></ul><pre><code>for i in range(1,4,1):    x = eval('X' + str(i))    print('X' + str(i), "itemsize: {} nbytes: {}".format(x.itemsize, x.nbytes)) &gt;&gt;&gt; X1 itemsize: 8 nbytes: 16 X2 itemsize: 8 nbytes: 32 X3 itemsize: 8 nbytes: 64 </code></pre><p>可以看到每个元素的大小为 8 个字节，zeros() 默认使用 float64 类型。可以通过 dtype 属性获取：</p><pre><code>print(X1.dtype) X1 = np.zeros(2, dtype='int32') # 指定元素类型 &gt;&gt;&gt; float64 </code></pre><p>关于元素类型要注意以下几点：</p><ul><li>转换数组类型不可以直接更改 dtype，它用于对数据存储区域的解读方式，例如 float64 对应 8 个 bytes，int32 对应 4 个 bytes，直接更改 dtype 会让 float64 类型的数组元素个数翻倍，并未实际改变数组类型。正确的方法应该通过  np.astype 方法进行。</li><li>更新数组元素时，会强制把新元素的数据类型转换为数组的 dtype。</li></ul><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/ndarray.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/ndarray.png" alt="borders"></a></p><p>ndarray 结构 （图自 Enthought, Inc.）</p><h3 id="1-1-2-不同维度的数组"><a href="#1-1-2-不同维度的数组" class="headerlink" title="1.1.2. 不同维度的数组"></a>1.1.2. 不同维度的数组</h3><p>上例中我们分别生成了 1,2,3 维的数组，一些常用的不同维度的数组在数学科学领域有专门的术语：</p><ul><li>单个数值，输出不被包含在 [] 中，例如 1，0.1等被称为标量(scalar)，它们自身不是数组，但可以与数组进行数学运算。np.array 可以创建只包含标量的数组，shape 为 ()。</li><li>1维数组，如 [1,2,3]，被称为向量（vector），只有一个轴。</li><li>2维数组，可以看作是向量组成的数组叫作矩阵（matrix），有两个轴，第一个轴称为行（row），第二个轴称为列（column）。</li><li>3维数组，多个矩阵组合成一个新的数组，可以得到一个 3D 矩阵。</li></ul><p>以上各类量有一个专门的名词，统称为张量（Tensor）。张量的维（dimension）也称为轴（axis），轴的个数叫作秩（rank），因为它和矩阵的秩含义不同，为了防止混淆， 通常很少使用术语 rank，而是称张量的维度。与此同时 np.rank 函数也不再被推荐使用，而是被 ndarray.ndim 替代。</p><p>dimension 或 axis 的个数（rank）在 NumPy 用 ndim 属性表示。每个维的大小（长度）在 NumPy 中用 shape 属性表示。</p><p>标量不是数组，而是数值，维度为 0，它在 NumPy 不用 ndarray 对象表示（实际上可以通过 array(scaler) 获得 0D 的 ndarray 对象，但是没有必要，直接使用标量即可），它没有 ndim 和 shape 属性。</p><pre><code># 创建 0D 的 ndarray 对象 In [1]: a = np.array(1) In [2]: type(a) Out[2]: numpy.ndarray In [3]: a.ndim Out[3]: 0 </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/narraytypes.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/narraytypes.png" alt="narraytypes"></a></p><p>1D 向量和 2D 矩阵</p><p>为了区分向量和 1xN 的矩阵，向量使用平面方式绘制，矩阵使用 3D 效果绘制。</p><p>图中可以看出：</p><ul><li>1D 向量只有 0 轴，也即只有一个方向，所以不存在转置操作，在 numpy 没有行向量和列向量之分，向量的转置还是自身。</li><li>2D 矩阵具有 0 轴和 1 轴，注意 0 轴的方向和 1D 向量 0 轴方向的区别，0 轴上的每个元素构成一行（row），1 轴上的每个元素构成一列（column）</li><li>每个轴均具有索引属性，从 0 开始。</li></ul><p>理解轴的概念是理解 numpy 提供的很多操作，如聚合，拼接等的基础。</p><h3 id="1-1-3-数组坐标轴"><a href="#1-1-3-数组坐标轴" class="headerlink" title="1.1.3. 数组坐标轴"></a>1.1.3. 数组坐标轴</h3><p>我们已经知道数组可以是多维的，这很容易联想到笛卡尔坐标系，2D 使用 x,y 描述平面上的任一点，3D 使用 x,y,z  描述空间中的任一点。是否我们可以借助笛卡尔坐标系来理解 2D 和 3D  数组呢？回答是肯定的，只是不同的软件环境对坐标系的描述不同，有的直接借用了笛卡尔坐标系，有的则进行了变换。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/cs.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/cs.png" alt="cs"></a></p><p>不同的直角坐标系</p><p>平面中的一点和空间中的一点均可使用轴坐标 x,y 或者 x,y,z 来得到，显然它们起到了索引的作用。对数组元素的访问就是通过索引进行的。</p><p>Octave 和 numpy 在 2D 数组处理上保持了一致，也即把数组分为行和列，只是和常见的笛卡尔 2D 坐标系比较，交换了 x 和 y 轴：在水平方向表示列，垂直方向表示行，例如：</p><pre><code>octave:2&gt; a = reshape ([0, 1, 2, 3], 2, 2) a =        0   2       1   3 octave:3&gt; a(1,1) ans = 0 octave:4&gt; a(1,2) ans =  2 </code></pre><p>不难想象，左上角成了坐标原点，而通过 a(1,1) 可以索引到元素 0，a(1,2) 可以索引到元素 2，注意 Octave 的下标总是从 1 开始，并使用圆括号进行索引。</p><pre><code>水平方向，对应列 +--------&gt; y |0   2 | 1   3 V x </code></pre><p>Numpy 与此类似，下标总是从 0 开始，使用方括号进行索引，这与 C 语言保持了一致：</p><pre><code>In [651]: a = np.arange(4).reshape(2,2,order='F') In [652]: a Out[652]: array([[0, 2],                                    [1, 3]]) In [653]: a[0,0] Out[653]: 0 In [654]: a[0,1] Out[654]: 2 </code></pre><p>这里暂时不追究 order 的作用，为了和 Octave 保持结果一致，我们使用了 ‘F’。显然针对 2D 数组，稍微有些编程基础（例如 C 语言）的人就很容易和笛卡尔坐标系结合起来，形成行列的直观思维，在给定索引后很容易指出对应的元素位置。</p><p>然而在 3D 甚至更高维数组的时候，就没那么简单了。观察上图中的 3D 坐标系，Octave 与笛卡尔坐标系保持了一致，也即 0,1,2 轴分别对应笛卡尔坐标系的索引 x,y,z，所以在给定如下视图和索引时我们很容易指出对应的元素值。</p><pre><code>octave:5&gt; a = reshape ([0, 1, 2, 3, 4, 5, 6, 7], 2, 2, 2) a = ans(:,:,1) =            0   2           1   3 ans(:,:,2) =            4   6           5   7 </code></pre><p>例如 [0,0,1]（实际命令为 a(1,1,2)）索引对应的元素是 4。</p><pre><code>octave:6&gt; a(1,1,2) ans =  4 </code></pre><p>以上示例对应如下坐标描述：</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/octave3d.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/octave3d.png" alt="octave3d"></a></p><p>0ctave 3D 数组坐标示例</p><p>octave 每新增一个轴，原来的轴保持不变，新增的轴变为新的维度，看起来轴是在尾部新增的。numpy 与此不同，新增的轴总是添加在最前面，变成 0 轴，原来的轴依次加 1。</p><pre><code>In [665]: a = np.arange(8).reshape(2,2,2,order='F') In [666]: a Out[666]: array([[[0, 4],                [2, 6]],                [[1, 5],                [3, 7]]]) In [667]: a[0,0,1] Out[667]: 4 </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/numpy3d.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/numpy3d.png" alt="numpy3d"></a></p><p>Numpy 3D 数组坐标示例</p><p>理解了数组坐标轴的区别，那么就真正理解索引机制了。我们会发现使用直角坐标系表示 2D  数组时可以把第一维称为行（row），第二维称为列（column），第三维并没有固定的称谓，可以认为是深度（depth），高度（height）或者片/层（slice/layer）。但是一旦超过 3 维，这种表示方法就将无能为力了，实际上索引只是一个树形结构，后面将会展示这种更具弹性的表示方法。</p><p>另一个问题是 order 参数的作用，在 2D 数组中，如果指定了 order = ‘F’，那么 Numpy 和 Octave 的打印结果就是一致的，我们也已经指出它们的行列规定是一致的。 然而如果生成的是 3D 数组，那么 np.array 参数即便指定了 order = ‘F’ 参数，生成的 3D 数组打印出来依然是不同的，这是因为坐标系规定不同。</p><p>我们可以惊奇的发现，上面两幅图只要进行适当的旋转，数据部分就会重合，也即使用相同的索引它们都会得到相同的值（例如  a(1,1,2) 和 a[0,0,1] 结果均为 4）。</p><p>如果不指定 order = ‘F’ 呢，结果会怎样，order 参数到底起到什么作用？这关系到另一个更深层次的问题：内存布局。</p><h3 id="1-1-4-内存布局"><a href="#1-1-4-内存布局" class="headerlink" title="1.1.4. 内存布局"></a>1.1.4. 内存布局</h3><p>理解内存布局对理解坐标系规定至关重要，实际上就是它决定了坐标系的变换规则。<a href="https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays/">Memory layout of multi-dimensional arrays</a> 是一篇很好的文章。</p><h4 id="1-1-4-1-行与列"><a href="#1-1-4-1-行与列" class="headerlink" title="1.1.4.1. 行与列"></a>1.1.4.1. 行与列</h4><p>通常计算机的内存均是线性编址的，可以看做是一维的大数组，通过系统调用分配到一块内存后，虚地址也是连续的，那么当要实现多维数组时，如何读取这一连续的内存数据到多维数组中，同样地如何把数组的行列等存储到这一连续的内存块中呢？这就涉及到内存布局（memory layout）策略。</p><p>对于 2D 数组来说通常有两种策略：行优先（Row-major）和列优先（column-major）。</p><ul><li>行优先：逐行按序读取（存储），行内的元素均是连续读取（存储），然后第二行接着第一行，依次类推。</li><li>列优先：逐列按序读取（存储），列内的元素均是连续读取（存储），然后第二列接着第一列，依次类推。</li></ul><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/rowfirst.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/rowfirst.png" alt="rowfirst"></a></p><p>行优先内存布局</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/columnfirst.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/columnfirst.png" alt="rowfirst"></a></p><p>列优先内存布局</p><p>比较以上两图，很容易理解行优先和列优先的区别，这有些像大小端字节序。内存布局用来指示何读取一块内存到多维数组，以及如何存储数据到一块连续内存。</p><p>Numpy 同时支持两种内存布局，可以通过 order 参数指定。在大部分函数（例如创建，变形等）中均接受 order 参数，用于指定行优先或者列优先：</p><ul><li>‘C’ 表示行优先（row major），numpy 的默认参数，在 C 语言（C++，Python, Pascal，Mathematica 等）中使用。也被称为 C-like 索引顺序。</li><li>‘F’ 表示列优先（column major），Fortran 语言（Matlab, R, Julia 等为了使用 Fortran 的 LAPACK 计算库也同样遵循该规则）默认使用列优先，Fortran-like 索引顺序。</li></ul><pre><code># Numpy 默认 order 为 C-like In [684]: a = np.arange(9).reshape(3,3,order='C') In [685]: a Out[685]: array([[0, 1, 2],               [3, 4, 5],             [6, 7, 8]]) In [686]: b = np.arange(9).reshape(3,3,order='F') In [687]: b Out[687]: array([[0, 3, 6],               [1, 4, 7],               [2, 5, 8]]) </code></pre><p>以上示例均是从相同的一块连续的内存中（9 个连续的 int32 类型的 0-8 数字）读取元素并生成 3x3 的 2D 数组，由于内存布局不同，它们读取到数据后的处理就不同：一个把前三个元素作为行，一个把前三个元素作为列。</p><p>同样对于数据写入，不同的内存布局也会影响索引对应的实际内存偏移地址，结合上图中的地址变化规律，不难得出 2D 数组的偏移公式如下：</p><p>$$offset  =  i_{row} * columns + i_{col} \qquad(行优先)\$$<br>$$offset  =  i_{col} * rows + i_{row} \qquad\qquad(列优先) \$$<br>$$offset_{bytes}  =  offset * itemsize$$</p><p>其中  $i_{row}$ 和 $i_{col}$分别表示行索引和列索引，例如 a[1,2] 中的 1 代表行索引，2 代表列索引。</p><ul><li>a[1,2] 行优先，可以计算得到它在内存中相对于首个元素的偏移个数为 1 * 3 + 2 = 5，因为第一个元素为 0，所以 a[1,2] 就是元素 5。</li><li>b[1,2] 列优先，偏移个数为 2 * 3 + 1，所以 b[1,2] 将访问到元素 7。</li></ul><pre><code>In [722]: a[1,2] Out[722]: 5 In [723]: b[1,2] Out[723]: 7 </code></pre><h4 id="1-1-4-2-索引的本质"><a href="#1-1-4-2-索引的本质" class="headerlink" title="1.1.4.2. 索引的本质"></a>1.1.4.2. 索引的本质</h4><p>如果尝试把行优先和列优先内存布局策略推广到 3D 甚至任意维，就不可行了，不可能为每一维都进行命名并映射到我们可以直观理解的空间进行形象描述。无论行还是列，本质上它们都是用于构成索引的一组数字，我们的目的是通过索引唯一定位到连续内存中的某个元素。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/indices.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/indices.png" alt="indices"></a></p><p>索引与全排列</p><p>我们知道 1 个 bit 可以表示 0 和 1， 而 2 个 bits 可以表示 0-3，所以使用十进制数左右排列在一起具有相同的本质  [i1,i2,…in]，可以表示 0 到 offset = (i1 + 1)(i2 + 1)…(in + 1) 所有数字，可以索引内存块的 0  偏移到最大 offset 处，这一索引关系是一一对应的。</p><p>只要确定了数组的维数（轴数）和每个维的大小（长度），那么它占用内存块长度就是确定的，与此同时索引的一一对应关系就是确定的，整个索引空间就是各维大小的全排列。</p><p>所谓行优先和列优先只是进行全排列时，哪一维在前哪一维在后的区别，在后的那一维它的索引变化最快。所以使用低维最快变化（first index change） 和高维最快变化（last index change）对描述任意维数组都是贴切的。</p><p>观察上图，行优先时最后一维的索引变化最快，它就是 last index change 机制，相应地，列优先属于 first index change 机制。当然我们也可以选择任意一维最快更新，并依次定义其他维的变化优先级，只是通常没有必要。</p><p>这看起来内存布局的区别和大小端字节序区别非常类似，也即没有好坏之分，然而并非如此，内存布局对数据处理速度影响很大：</p><ul><li>CPU 非常善于处理连续数据，它的多级流水线机制使得在处理当前数据时，可以预取紧随其后的其他数据。</li><li>CPU 设有多级 cache，处理连续数据让靠近 CPU 核的 cache 命中率更高。</li></ul><p>我们应该让内存布局符合这一特征：如果处理集中在行数据上，那么就应该使用高维最快变化（order=’C’），集中在列上，就应该使用低维最快变化（order=’F’），这就保证了读取行或列时是数据是被顺序读取的。</p><pre><code># 默认为行优先 In [108]: a = np.empty((10,10)) In [109]: a[0,:] *= 100 In [110]: %timeit a[0,:] *= 100 2.24 µs ± 79.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) In [111]: %timeit a[:,0] *= 100 3.14 µs ± 147 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) </code></pre><p>在小数组上，性能相差不大，但是在处理大数组时差距尤为明显：</p><pre><code># 默认为行优先 In [123]: a = np.empty((10000,10000)) # 处理行数据速度很快 In [124]: %timeit a[0,:] *= 100 5.84 µs ± 399 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) # 处理列数据速度很慢 In [125]: %timeit a[:,0] *= 100 155 µs ± 4.27 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) </code></pre><p>如果我们在创建数组时指定列优先，那么结果就会相反：</p><pre><code># 指定列优先 In [132]: a = np.empty((10000,10000), order='F') # 处理行数据速度很慢 In [133]: %timeit a[0,:] *= 100 149 µs ± 1.41 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) # 处理列数据速度很快 In [134]: %timeit a[:,0] *= 100 5.55 µs ± 184 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) </code></pre><p>示例中数据元素达到了 1 亿个，此时性能相差 30 倍，所以在进行大数据处理时一定要正确设置内存布局。</p><h3 id="1-1-5-树形坐标"><a href="#1-1-5-树形坐标" class="headerlink" title="1.1.5. 树形坐标"></a>1.1.5. 树形坐标</h3><p>无论是笛卡尔坐标系，还是其他坐标系，本身就是一个索引系统。通过坐标系只能很好地描述 1D-3D 数组的索引，超过 3D 就无能为力了。</p><p>从自然的角度使用维度有限的 3D 空间来模拟可以有无限维的索引本身就是不合理的，那么就让索引回归索引，思考邮政系统是如何投递信笺的：地址就是索引最自然的应用。 一个地址可以由：国家，省份，城市，街道，小区，楼号，层号，房号构成，显然这就是一个树形图，采用树形坐标可以完美地描述任意维数组。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/treeindex.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/treeindex.png" alt="treeindex"></a></p><p>树形坐标</p><p>上图描述了一个 shape(2,2,2) 的 3D  数组，为了作图简便，最后两维保留了行列的2维形状，这样树形图就少了一次分支，不会显得太臃肿。虚线部分为扩展为 4D  数组时的最后一维的示意图，可以想见这个虚轴左侧对应 3 轴，右侧对应 0 轴，其余轴增加 1。</p><p>尽管我们极力想把最后两维想象成行或列，正如前所述，我们可以把任意两维作为行或列。我们可能认为一幅彩色图片在 Numpy 应该以  [RGB,W,H] 的索引方式来处理，这样行就对应了高度，列就对应了宽度，第一维描述各个通道。实际上并非如此，而是以 [W,H,RGB]  的方式处理的，这样 Numpy 的树形坐标就和 Octave/Matlab 保持一致了（0, 1轴描述高和宽，类似行和列）。</p><pre><code>from matplotlib import pyplot as plt img = plt.imread("lena.png") print(type(img).__name__) print(img.shape) &gt;&gt;&gt; ndarray (256, 256, 3) </code></pre><p>实际应用中应该根据具体数据，来变换索引（坐标）以最形象直观的方式描述，而不要拘泥于总是把最后两维看做行和列。理解了这一点，就明白了 np.swapaxes() 等轴变换函数的作用了。</p><h3 id="1-1-6-数组视图"><a href="#1-1-6-数组视图" class="headerlink" title="1.1.6. 数组视图"></a>1.1.6. 数组视图</h3><p>NumPy 中提供了大量的对数组进行处理的函数，这些函数返回的新数组中的元素和原数组元素具有两种关系：</p><ul><li>引用，也即不对原数组中元素复制，修改元素会相互影响。</li><li>复制，拷贝副本，修改不会互相影响。包含简单索引（例如简单索引和切片组合使用）的引用方式，均会进行复制。</li></ul><p>一个数组被称为数组包含的数据的一个视图（view），所以如果是引用返回的数组，则称为数据的另一个视图。不同视图是对数据的不同观察方式，体现在数组上就是形式的变形，不会拷贝任何东西。视图也被称为视窗。例如同样是 4 个元素，可以是 2x2 的 2 维数组，也可以组成 1x4 的向量或者 4x1 的 2 维数组，它们均是同一组数据的不同视图。</p><p>如何查看一个对象是视图，还是拥有 data 的原数组呢？ ndarray.base 记录引用的原数组，所以如果 ndarray.base 不是 None，那么它就是视图，且原数组对象就是 ndarray.base。</p><pre><code>In [280]: a = np.array([1,2]) In [281]: a.base In [282]: b = a.reshape(2,1) In [283]: b.base Out[283]: array([1, 2])In [284]: b.base is a Out[284]: True </code></pre><p>不要使用 id(a) == id(b) 判断是否为视图，它们可能相等，也不要使用 id(a.data) == id(b.data)  判断视图，因为 data 是 memoryview 对象，不同的 memoryview 对象可能引用同一块内存区域，但是 memoryview  自身的地址是不同的。</p><pre><code>In [289]: a = memoryview(b'123') In [290]: a # 此地址是 memoryview 自身的地址，不是它引用的对象地址 Out[290]:  &lt;memory at 0x0000029C61D18708&gt;</code></pre><p>步长 strides 是另一个 ndarray 对象成员，它对于理解数组视图至关重要。</p><pre><code>x = np.array([[1, 2, 3],                          [4, 5, 6],                          [7, 8, 9]], dtype=np.int8)t = x.T print(t.base is x) &gt;&gt;&gt; True </code></pre><p>转置不会复制数据，所以 t 和 x 的 data 地址是相同的。但是它们的 stides 是不同的：</p><pre><code>print(x.strides) &gt;&gt;&gt; (3, 1) print(t.strides) &gt;&gt;&gt; (1, 3) </code></pre><p>strides 是一个元组，它的元素个数与 shape 元素个数相同，它记录了查找对应轴下一个元素需要偏移的字节数。为了加速访问数据，ndarray 对象的 data 数据在内存中均是连续成块存储的，所以如何解读这一块数据，就需要 strides 来指示。</p><p>通过 np.nditer 可以直接顺序访问这一连续内存，并打印各个元素以观察它们的在内存中的存储情况：</p><pre><code>In [1]: for i in np.nditer(x):    ...:     print(i, end=' ')    ...:   1 2 3 4 5 6 7 8 9 </code></pre><p>由于转置操作不会对数组进行复制，所以这里的参数替换为 x.T 结果也是一样的。</p><p>这里的 x 类型定义为 int8，所以每个元素占用 1 个字节，x 的 strides 为 (3, 1) 表示：</p><ul><li>需要偏移 3 个字节找到下一行的开始数据。</li><li>需要偏移 1 个字节找到下一列的开始数据。</li></ul><p>有了 shape 和 strides 就构成了一个视图，可以对元素进行不同视图的解读。这种机制在 NumPy 被称为索引策略（indexing scheme），这些成员均存储在每个 ndarray 实例的管理字段中。</p><p>不同的 order 参数创建的数组的 strides 是不同的，例如：</p><pre><code>y = np.array([[1, 2, 3],                   [4, 5, 6],                       [7, 8, 9]], dtype=np.int8, order='F') print(y.strides) &gt;&gt;&gt; (1, 3) </code></pre><p>如果数组元素索引为 i[0], i[1], …, i[n]，通过 strides 可以计算出元素在数组中的偏移字节数:</p><pre><code>offset = sum(np.array(i) * a.strides) </code></pre><p>不同内存布局下，strides 的计算函数如下：</p><pre><code>def f_contiguous_strides(itemsize, shape):        if shape:               strides = [itemsize]             for s in shape[:-1]:                 strides.append(strides[-1]*s)              return tuple(strides)       else:             return ()                 def c_contiguous_strides(itemsize, shape):       if shape:            strides = [itemsize]          for s in shape[:0:-1]:                 strides.append(strides[-1]*s)            return tuple(strides[::-1])      else:            return () </code></pre><p>下面的示例构造一个从 0 开始的，差为 1 的等差数列，这样保证元素的偏移 = 数组元素 * itemsize：</p><pre><code>In [0]: x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0) In [1]: x.strides Out[1]: (32, 4, 224, 1344) # 计算[3,5,2,2]索引处的元素偏移字节数 In [2]: offset = sum(np.array([3,5,2,2]) * x.strides) In [3]: x[3,5,2,2] Out[3]: 813 In [4]: offset / x.itemsize Out[4]: 813.0 </code></pre><p>尽管通过 np.isfortran(a) 接口可以判断数组元素的索引策略，该接口不再被推荐使用，而是直接查看 flags 字段：</p><pre><code>In [517]: x.flags Out[517]:      C_CONTIGUOUS : True   # C-like index order      F_CONTIGUOUS : False      OWNDATA : False      WRITEABLE : True     ALIGNED : True     UPDATEIFCOPY : False </code></pre><p>对于 1D 向量来说，C_CONTIGUOUS 和 F_CONTIGUOUS 是没有区别的，strides 均为 (itemsize,)，此时这两个标志均为 True。</p><h4 id="1-1-6-1-数据复制"><a href="#1-1-6-1-数据复制" class="headerlink" title="1.1.6.1. 数据复制"></a>1.1.6.1. 数据复制</h4><p>有些函数的帮助文件中会有如此描述，例如 np.ravel()：</p><pre><code>ravel(a, order='C')       Return a contiguous flattened array.         A 1-D array, containing the elements of the input, is returned.  A copy is    made only if needed. </code></pre><p>np.ravel() 用于将数组展平为 1D 向量，它通常返回的是视图，但是注意 “A copy is made only if needed”，这说明有些情况返回的不是视图，而会进行数据复制。</p><p>何时需要复制数据呢？ravel() 返回的数组总是会指向一串连续的内存，如果展平的数组不能满足连续内存，那么只能进行数据复制：</p><pre><code>In [373]: a = np.arange(4).reshape(2,2) In [374]: b = a[:,:1] In [375]: b Out[375]: array([[0],                     [2]]) In [376]: b.base Out[376]: array([0, 1, 2, 3]) # 如果对 b 进行 ravel()，由于元素 0,2 内存不连续，会进行复制 In [377]: c = b.ravel() In [378]: c.base </code></pre><h3 id="1-1-7-元素类型"><a href="#1-1-7-元素类型" class="headerlink" title="1.1.7. 元素类型"></a>1.1.7. 元素类型</h3><p>NumPy标准数据类型：</p><blockquote><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>bool</td><td>布尔值 bool_ 别名</td></tr><tr><td>bool_</td><td>布尔值（真、 True 或假、 False） ， 用一个字节存储</td></tr><tr><td>int</td><td>int_ 别名</td></tr><tr><td>int_</td><td>默认整型（类似于 C 语言中的 long， 通常情况下是 int64 或 int32）</td></tr><tr><td>intc</td><td>同 C 语言的 int 相同（通常是 int32 或 int64）</td></tr><tr><td>intp</td><td>用作索引的整型（和 C 语言的 ssize_t 相同， 通常情况下是 int32 或int64）</td></tr><tr><td>int8</td><td>字节（byte， 范围从–128 到 127）</td></tr><tr><td>int16</td><td>整型（范围从–32768 到 32767）</td></tr><tr><td>int32</td><td>整型（范围从–2147483648 到 2147483647）</td></tr><tr><td>int64</td><td>整型（范围从–9223372036854775808 到 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整型（范围从 0 到 255）uint16 无符号整型（范围从 0 到 65535）</td></tr><tr><td>uint32</td><td>无符号整型（范围从 0 到 4294967295）</td></tr><tr><td>uint64</td><td>无符号整型（范围从 0 到 18446744073709551615）</td></tr><tr><td>float</td><td>float64 的简化形式</td></tr><tr><td>float_</td><td>float64 的简化形式</td></tr><tr><td>float16</td><td>半精度浮点型：1 符号位，5 比特位指数(exponent)，10 比特位尾数(mantissa)</td></tr><tr><td>float32</td><td>单精度浮点型：1 符号位，8 比特位指数，23 比特位尾数</td></tr><tr><td>float64</td><td>双精度浮点型：1 符号位，11 比特位指数，52 比特位尾数</td></tr><tr><td>complex_</td><td>complex128 的简化形式</td></tr><tr><td>complex64</td><td>复数， 由两个 32 位浮点数表示</td></tr><tr><td>complex128</td><td>复数， 由两个 64 位浮点数表示</td></tr></tbody></table></blockquote><p>更多的信息可以在 NumPy 文档（<a href="http://numpy.org/%EF%BC%89">http://NumPy.org/）</a> 中查看。NumPy 也支持复合数据类型。创建数组时，如果不指定元素类型，元素默认类型为 float64。</p><p>浮点数据的精度可以通过 numpy.finfo 接口获取：</p><pre><code># numpy.float 等价于 numpy.float64 In [53]: print (numpy.finfo(numpy.float)) Machine parameters for float64 --------------------------------------------------------------- precision =  15   resolution = 1.0000000000000001e-15 machep =    -52   eps =        2.2204460492503131e-16 negep =     -53   epsneg =     1.1102230246251565e-16 minexp =  -1022   tiny =       2.2250738585072014e-308 maxexp =   1024   max =        1.7976931348623157e+308nexp =       11   min =        -max--------------------------------------------------------------- In [54]: print (numpy.finfo(numpy.float32)) Machine parameters for float32 --------------------------------------------------------------- precision =   6   resolution = 1.0000000e-06 machep =    -23   eps =        1.1920929e-07 negep =     -24   epsneg =     5.9604645e-08 minexp =   -126   tiny =       1.1754944e-38 maxexp =    128   max =        3.4028235e+38 nexp =        8   min =        -max --------------------------------------------------------------- </code></pre><p>np.array 会根据提供的数据自动选择 int32 或 flot64 作为数组的  dtype。对于使用切片生成数组的函数，也会根据参数类型自动选择生成数组的 dtype，例如 np.arange，不像 Python 的  range 函数，它可以接受浮点数作为参数：</p><pre><code>In [55]: np.arange(10) Out[55]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) In [56]: np.arange(10.) # 指定 stop 为浮点数 Out[56]: array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]) </code></pre><p>注意</p><p>在整数后加一点 ‘.’，例如 10. 表示这是一个浮点数，是 10.0 的简写，常通过该简写生成浮点类型数组。</p><h3 id="1-1-8-字符串类型"><a href="#1-1-8-字符串类型" class="headerlink" title="1.1.8. 字符串类型"></a>1.1.8. 字符串类型</h3><p>字符串类型在以数值处理见长的 numpy 中很少使用，但是不意味着它不支持。我们可以通过为 dtype 指定 ‘Sn’ 或者 ‘Un’ 来创建字符串类型数组。</p><ul><li>‘Sn’ 中的 ‘S’ 表示 ascii string，它使用单个字节存储字符，n 表示 ascii 字符个数。</li><li>‘Un’ 中的 ‘U’ 表示 unicode string，它使用 unicode 编码存储字符，n 表示 unicode 字符个数。</li></ul><p>注意</p><p>n 是字符的个数，不是字节数。</p><p>numpy 数组均是在创建时一次性分配连续内存的，所以一旦指定了 n，每个元素所能存储的字符长度就固定了。</p><p>np.str 是 ‘U1’ 的别名，所以使用 np.str 创建的数组只能存储一个 unicode 字符。</p><pre><code>In [8]: s = np.zeros((2,2), dtype='S1') In [9]: s Out[9]: array([[b'', b''],                 [b'', b'']],                   dtype='|S1') </code></pre><p>‘|’ 表示该类型不区分大小端。如果赋值的字符串超过元素所能存储的长度大小，并不会报错，而直接进行截断处理。 ‘Sn’ 类型的数组不支持宽字符赋值，否则进行报错处理。</p><pre><code>In [10]: s[0,0] = '123' In [11]: s Out[11]: array([['1', ''],                   ['', '']],                     dtype='|S1') </code></pre><p>Numpy 推荐使用 unicode 类型来创建字符串数组，这样就可以兼容所有可用字符，注意 unicode 是大小端敏感的，所以考虑到程序的移植性，应该明确指定大小端。</p><pre><code>In [33]: s = np.zeros((2,2), dtype='&lt;U2')# 超过长度将进行截断处理In [34]: s[0,0] = '你好吗'In [35]: sOut[35]:array([['你好', ''],       ['', '']],      dtype='&lt;U2')</code></pre><p>如何将字符串数组转换为一个字符串，很简单：</p><pre><code>In [38]: ''.join(s.ravel().tolist()) Out[38]: '你好' </code></pre><p>如果想创建支持任意长度字符的数组，可以指定 object 类型，当然这一维这数组的每个元素可以支持任意类型，付出的代价是：数组无法一次性为所有元素分配连续内存，访问效率不高。</p><pre><code>In [48]: s = np.zeros((2,2), dtype=object) In [49]: s[0,0] = 'hello' In [50]: s Out[50]: array([['hello', 0],                  [0, 0]], dtype=object) </code></pre><p>同样字符串数组支持一系列的处理函数：<a href="https://docs.scipy.org/doc/numpy/reference/routines.char.html">字符串数组处理函数</a> ，借助它们可以实现一些有趣的操作，例如：</p><pre><code>ar = np.arange(9).astype('&lt;U16')commas = ar.copy()commas.fill(',')#将两个 shape 相同的数组按元素拼接起来，中间插入逗号indices = np.core.defchararray.add(ar, commas)indices = np.core.defchararray.add(indices, ar)print(indices)&gt;&gt;&gt;['0,0' '1,1' '2,2' '3,3' '4,4' '5,5' '6,6' '7,7' '8,8']</code></pre><h3 id="1-1-9-类型转换"><a href="#1-1-9-类型转换" class="headerlink" title="1.1.9. 类型转换"></a>1.1.9. 类型转换</h3><p>数组的类型转换，不可直接修改 dtype，dtype 只是用于对内存进行解读的方式，但是内存空间的内容不会有任何改变，类似 C 语言中的指针类型转换：</p><pre><code>np.random.seed(0)a = np.random.random(2)print(a.dtype)print(a)a.dtype = 'int32'print(a.dtype)print(a)&gt;&gt;&gt;float64   # 默认类型为 float64[ 0.5488135   0.71518937]int32[1449071272 1071747041 -815757517 1072095956]</code></pre><p>示例随机生成包含 2 个默认的 float64 元素的数组，直接修改类型为 ‘int32’，发现数组元素个数增加，这不是我们期待的结果。显然 dtype 用于对内存块的解读。</p><p>类型转换需要使用 numpy 提供的 astype 方法：</p><pre><code>a = a.astype(np.int32)print(a.dtype)print(a)&gt;&gt;&gt;int32[0 0]</code></pre><h2 id="1-2-创建数组"><a href="#1-2-创建数组" class="headerlink" title="1.2. 创建数组"></a>1.2. 创建数组</h2><p>除了以下介绍的几种创建数组的方法外，也可以从迭代对象创建数组，参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#iter-array">迭代对象创建数组</a>。</p><h3 id="1-2-1-全新创建"><a href="#1-2-1-全新创建" class="headerlink" title="1.2.1. 全新创建"></a>1.2.1. 全新创建</h3><h4 id="1-2-1-1-zeros-和-empty"><a href="#1-2-1-1-zeros-和-empty" class="headerlink" title="1.2.1.1. zeros 和 empty"></a>1.2.1.1. zeros 和 empty</h4><pre><code>zeros(shape, dtype=float, order='C')empty(shape, dtype=float, order='C')</code></pre><p>数组创建函数，通常具有类似的参数，例如 shape 指定各轴元素个数：</p><ul><li>单个整数指定 1 维数组的大小。</li><li>一个元组或者序列类型来生成多维数组。</li></ul><p>dtype 指定元素类型，默认 float64。order 指定存储类型，默认即可。</p><p>zeros() 生成全 0 数组， empty 生成未初始化值的数组。</p><pre><code>print(np.zeros(2, dtype='bool'))   # 全 0 数组print(np.empty((2, 5), dtype=int)) # 值未初始化的数组，不是随机元素&gt;&gt;&gt;[False False][[         0          0          0 1070596096          0] [1071644672          0 1072168960          0 1072693248]]</code></pre><h4 id="1-2-1-2-like-生成函数"><a href="#1-2-1-2-like-生成函数" class="headerlink" title="1.2.1.2. like 生成函数"></a>1.2.1.2. like 生成函数</h4><p>有些用于创建数组的函数名后缀为 _like，它与原函数功能类似，只是第一个参数是一个现成的数组，参考它的 shape 来生成特定数组。类似的函数有：</p><blockquote><table><thead><tr><th>Like 函数</th><th>描述</th></tr></thead><tbody><tr><td>empty_like</td><td>元素未初始化的数组</td></tr><tr><td>zeros_like</td><td>全 0 数组</td></tr><tr><td>ones_like</td><td>全 1 数组</td></tr><tr><td>full_like</td><td>填充给定的数字</td></tr></tbody></table></blockquote><pre><code>print(np.zeros_like([[1,1],[2,2]]))&gt;&gt;&gt;[[0 0] [0 0]]</code></pre><h4 id="1-2-1-3-全1数组"><a href="#1-2-1-3-全1数组" class="headerlink" title="1.2.1.3. 全1数组"></a>1.2.1.3. 全1数组</h4><p>ones() 与 zeros() 恰恰相反，创建全 1 数组。</p><pre><code>ones(shape, dtype=None, order='C')</code></pre><pre><code>print(np.ones(2, dtype='int'))   # 全 1 数组&gt;&gt;&gt;[1 1]</code></pre><h4 id="1-2-1-4-单位矩阵"><a href="#1-2-1-4-单位矩阵" class="headerlink" title="1.2.1.4. 单位矩阵"></a>1.2.1.4. 单位矩阵</h4><pre><code>eye(N, M=None, k=0, dtype='float')</code></pre><p>创建 N*M 的 2 维度单位矩阵，如果不提供 M，则 M=N，k 为全1的对角线索引：</p><pre><code>print(np.eye(2, dtype=int))print(np.eye(3, k=1))&gt;&gt;&gt;[[1 0] [0 1]][[ 0.  1.  0.] [ 0.  0.  1.] [ 0.  0.  0.]]</code></pre><h4 id="1-2-1-5-填充特定值"><a href="#1-2-1-5-填充特定值" class="headerlink" title="1.2.1.5. 填充特定值"></a>1.2.1.5. 填充特定值</h4><pre><code>full(shape, fill_value, dtype=None, order='C')</code></pre><p>full() 根据 shape 生成特定维度的数组，所有元素默认值为 fill_value。</p><pre><code>print(np.full((2, 2), np.inf))print(np.full((2, 2), 2))print(np.full((), 1)) # 返回标量 1&gt;&gt;&gt;[[ inf  inf] [ inf  inf]][[2 2] [2 2]]1</code></pre><p>fill 是 ndarray 对象方法，可以将数组填充为特定标量，注意会进行强制类型转换：</p><pre><code>In [65]: a = np.arange(5)In [66]: aOut[66]: array([0, 1, 2, 3, 4])In [67]: a.fill(2.1) # 强制转换为 int 型In [68]: aOut[68]: array([2, 2, 2, 2, 2])</code></pre><h3 id="1-2-2-随机数数组"><a href="#1-2-2-随机数数组" class="headerlink" title="1.2.2. 随机数数组"></a>1.2.2. 随机数数组</h3><h4 id="1-2-2-1-均匀分布"><a href="#1-2-2-1-均匀分布" class="headerlink" title="1.2.2.1. 均匀分布"></a>1.2.2.1. 均匀分布</h4><p>rand 返回离散均匀分布（discrete uniform）的 [0, 1] 取值填充的数组。</p><pre><code># 单个随机值print(np.random.rand())&gt;&gt;&gt;0.8257044198690662# 1 维数组print(np.random.rand(2))&gt;&gt;&gt;[ 0.89012233  0.98822365]# 指定 shape 的数组print(np.random.rand(2,3))&gt;&gt;&gt;[[ 0.58724409  0.17262095  0.29256442] [ 0.89758811  0.00469506  0.00793409]]</code></pre><h4 id="1-2-2-2-整型均匀分布"><a href="#1-2-2-2-整型均匀分布" class="headerlink" title="1.2.2.2. 整型均匀分布"></a>1.2.2.2. 整型均匀分布</h4><p>randint 返回离散均匀分布（discrete uniform）的整型随机值填充的数组。</p><pre><code>randint(low, high=None, size=None, dtype='l')</code></pre><p>如果提供 high 从 [low, high) 中取随机数，否则从 [0, low) 中取随机数。size 指定 shape，dtype 指定元素类型，默认 int32。low 必须提供。</p><pre><code># size=None 时默认返回单个随机数print(np.random.randint(10))&gt;&gt;&gt;5# 从 [0-2) 中取随机数，含 10 个元素的一维数组print(np.random.randint(2, size=10))&gt;&gt;&gt;[0 0 1 1 1 0 0 1 0 1]# 从 [1-5) 中取随机数，指定 shape 的数组print(np.random.randint(1, 5, size=(2, 4)))&gt;&gt;&gt;[[1 3 4 1] [3 2 4 2]]</code></pre><p>random() 返回连续型均匀分布（continuous uniform）的 [0, 1) 随机值填充的数组。</p><pre><code># 单个随机数print(np.random.random())&gt;&gt;&gt;0.7490899812919358# 1 维数组print(np.random.random(1))&gt;&gt;&gt;[ 0.08542616]# 指定 shape 的数组print(np.random.random((1,2)))&gt;&gt;&gt;[[ 0.78634523  0.66910924]]</code></pre><h4 id="1-2-2-3-正态分布"><a href="#1-2-2-3-正态分布" class="headerlink" title="1.2.2.3. 正态分布"></a>1.2.2.3. 正态分布</h4><p>正态分布（Normal distribution）又名高斯分布（Gaussian distribution）。</p><p>randn 返回符合标准正态分布的随机值填充的数组。</p><pre><code>print(np.random.randn())    # 返回一个随机值print(np.random.randn(1))   # 返回一维数组print(np.random.randn(2, 2)) # 返回二维数组&gt;&gt;&gt;0.48496737321135236  # float 类型[-0.54254042]        # ndarray 类型[[-0.21879005  0.47782525] [-0.59249748  0.39013432]]</code></pre><p>所谓标准正态分布，也即所有元素均值为 0，标准差为 1。</p><pre><code>normal(loc=0.0, scale=1.0, size=None)</code></pre><p>np.random.normal() 是另一个支持更详细参数的正态分布函数，loc 指定均值，默认 0，scale 指定标准差，默认 1：</p><pre><code># 创建一个3×3的、 均值为0、 方差为2的正态分布随机数组A = np.random.normal(0, 2, (3, 3))print(A)&gt;&gt;&gt;[[-0.04586759 -0.953187    5.27807227] [-1.74930541 -0.95083919 -1.50893838] [-0.15744789 -5.26709878 -3.04729709]]</code></pre><h4 id="1-2-2-4-泊松分布"><a href="#1-2-2-4-泊松分布" class="headerlink" title="1.2.2.4. 泊松分布"></a>1.2.2.4. 泊松分布</h4><pre><code># λ 为6，指定 shape 的泊松分布print(np.random.poisson(6, (3 ,3)))&gt;&gt;&gt;[[4 5 1] [6 1 8] [3 2 8]]</code></pre><h4 id="1-2-2-5-乱序操作"><a href="#1-2-2-5-乱序操作" class="headerlink" title="1.2.2.5. 乱序操作"></a>1.2.2.5. 乱序操作</h4><p>random.shuffle 可以对序列类型，例如 list 或者一维数组进行乱序操作，操作直接作用在参数对象上：</p><pre><code># 一维数组乱序narray = np.arange(10)np.random.shuffle(narray)print(narray)&gt;&gt;&gt;[6 4 8 3 1 9 0 5 2 7]# 列表乱序list0 = [0,1,2,3]np.random.shuffle(list0)print(list0)&gt;&gt;&gt;[1, 3, 0, 2]</code></pre><h4 id="1-2-2-6-元素范围映射"><a href="#1-2-2-6-元素范围映射" class="headerlink" title="1.2.2.6. 元素范围映射"></a>1.2.2.6. 元素范围映射</h4><p>有时我们希望元素分布在任意指定的 [a, b) 区间，而不是 [0, 1) 之间，可以通过如下方式映射到 [a, b) 空间：(b - a) * random() + a。</p><pre><code># 映射到 [-5, 0)print(5 * np.random.random((2, 2)) - 5)&gt;&gt;&gt;[[-4.02260888 -1.18260402] [-0.75450539 -1.48321213]]</code></pre><h4 id="1-2-2-7-随机种子"><a href="#1-2-2-7-随机种子" class="headerlink" title="1.2.2.7. 随机种子"></a>1.2.2.7. 随机种子</h4><p>如果设置了随机种子，可以保证每次生成相同的随机值，np.random.seed(seed=None)，种子是一个无符号 int32 整型。</p><pre><code>np.random.seed(0) # 设置随机数种子x1 = np.random.randint(10, size=6)print(x1)&gt;&gt;&gt;[5 0 3 3 7 9]</code></pre><h3 id="1-2-3-从已有元素创建数组"><a href="#1-2-3-从已有元素创建数组" class="headerlink" title="1.2.3. 从已有元素创建数组"></a>1.2.3. 从已有元素创建数组</h3><h4 id="1-2-3-1-list-转数组"><a href="#1-2-3-1-list-转数组" class="headerlink" title="1.2.3.1. list 转数组"></a>1.2.3.1. list 转数组</h4><pre><code>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</code></pre><p>array() 可以实现列表向数组的转换，自动提升元素类型。它还用于索引和切片。copy 指定是复制原数组还是引用。</p><pre><code>A = np.array([[1, 2], [3, 4]])print(A)print(np.array([1, 2, 3.0])) # 自动提升类型&gt;&gt;&gt;[[1 2] [3 4]][ 1.  2.  3.]</code></pre><p>array() 可以生成 0D 的标量数组，它的 shape 为空的 tuple：</p><pre><code>In [229]: a = np.array(0)In [231]: aOut[231]: array(0)In [230]: a.shapeOut[230]: ()</code></pre><p>subok 表示是否将子类型转换为 ndarray，例如：</p><pre><code>np.array(np.mat('1 2; 3 4'), subok=True)&gt;&gt;&gt;matrix([[1, 2], # 类型依然为 matrix，保留子类型        [3, 4]])np.array(np.mat('1 2; 3 4'), subok=False)&gt;&gt;&gt;array([[1, 2],  # 类型转化为 ndarray       [3, 4]])</code></pre><pre><code>asarray(a, dtype=None, order=None)</code></pre><p>asarray() 与 array 功能类似，都可以转换其他类型到数组，唯一区别是当原类型是数组时，asarray 不对数据复制，只是标签引用，array 总是进行复制。</p><pre><code>list0 = [[0,0,0]]A0 = np.array(list0)A1 = np.asarray(list0)list0[0][0] = 1print(list0)print(A0)print(A1)&gt;&gt;&gt;[[1, 0, 0]][[0 0 0]][[0 0 0]]</code></pre><p>上面示例对 list 转换为 ndarray 类型，所以首先会创建 ndarray，然后对元素进行复制。如果源类型为数组，则不会复制：</p><pre><code>A0 = np.array([0,0,0])A1 = np.array(A0)A2 = np.asarray(A0)A0[0] = 1print(A0)print(A1)print(A2)&gt;&gt;&gt;[1 0 0][0 0 0][1 0 0]</code></pre><p>如果要对数组进行复制，一般使用 copy() 函数。array() 中的 copy 参数开关复制功能。</p><h4 id="1-2-3-2-数组转-list"><a href="#1-2-3-2-数组转-list" class="headerlink" title="1.2.3.2. 数组转 list"></a>1.2.3.2. 数组转 list</h4><p>ndarray 类型转为list类型使用对象的 tolist 方法即可。转 list 可以进行序列化存储。</p><pre><code>A0 =  np.array([[1, 2], [3, 4]])print(A0.tolist())&gt;&gt;&gt;[[1, 2], [3, 4]] </code></pre><h4 id="1-2-3-3-set-转数组"><a href="#1-2-3-3-set-转数组" class="headerlink" title="1.2.3.3. set 转数组"></a>1.2.3.3. set 转数组</h4><p>set 是 python 自带的集合类型，与 list 不同，如果需要把 set 转换为 ndarray，则首先需要转换为 list，然后再创建数组，否则创建出的数组将是 object 类型，并把 set 作为一个整体对待，这可能不是我们想要的。</p><pre><code>In [28]: a_set = set([1,1,2,3])In [29]: bad_array = np.array(a_set)In [30]: bad_array.dtypeOut[30]: dtype('O') # 默认创建的是 object 类型</code></pre><p>把 set 转化为 list，然后再创建 ndarray：</p><pre><code># 先把集合转化为 listIn [35]: b_list = list(a_set)In [36]: b_listOut[36]: [1, 2, 3]# 然后再使用 list 创建数组In [37]: np.array(b_list)Out[37]: array([1, 2, 3])</code></pre><h4 id="1-2-3-4-字节流转数组"><a href="#1-2-3-4-字节流转数组" class="headerlink" title="1.2.3.4. 字节流转数组"></a>1.2.3.4. 字节流转数组</h4><p>frombuffer。</p><h4 id="1-2-3-5-迭代对象转数组"><a href="#1-2-3-5-迭代对象转数组" class="headerlink" title="1.2.3.5. 迭代对象转数组"></a>1.2.3.5. 迭代对象转数组</h4><p>参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#iter-array">迭代对象创建数组</a>。</p><h3 id="1-2-4-数组文件"><a href="#1-2-4-数组文件" class="headerlink" title="1.2.4. 数组文件"></a>1.2.4. 数组文件</h3><h4 id="1-2-4-1-保存到文件"><a href="#1-2-4-1-保存到文件" class="headerlink" title="1.2.4.1. 保存到文件"></a>1.2.4.1. 保存到文件</h4><pre><code>savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')</code></pre><p>我们可以通过 np.savetxt 将数组保存到 txt 文件，例如：</p><pre><code>a = np.arange(4).reshape(2,2) np.savetxt('narray.txt', a) </code></pre><p>narray.txt 文件内容如下，尽管 dtype 为 int32，数据看起来就是浮点数，这是由于默认参数为 fmt 设置成了 ‘%.18e’：</p><pre><code>0.000000000000000000e+00 1.000000000000000000e+00 1.2.000000000000000000e+00 3.000000000000000000e+00 </code></pre><h4 id="1-2-4-2-从文件加载"><a href="#1-2-4-2-从文件加载" class="headerlink" title="1.2.4.2. 从文件加载"></a>1.2.4.2. 从文件加载</h4><pre><code>loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None,        skiprows=0, usecols=None, unpack=False, ndmin=0)</code></pre><p>np.loadtxt 实现从文件加载，相当于 np.savetxt 的逆向操作，所以要保持相关参数一致，例如 delimiter。</p><pre><code>a = np.loadtxt('narray.txt', delimiter=' ')print(a.dtype)print(a)&gt;&gt;&gt;float64[[ 0.  1.] [ 2.  3.]]</code></pre><p>显然通过 txt 文件只能保存数组的数据部分，部分信息（数组类型）被丢失了。使用 Python 的 pickle 数据包可以轻松完成这一功能，并且支持多个数组的保存，当然缺点是无法打开文件直接查看数据。</p><h4 id="1-2-4-3-pickle-操作"><a href="#1-2-4-3-pickle-操作" class="headerlink" title="1.2.4.3. pickle 操作"></a>1.2.4.3. pickle 操作</h4><p>这里定义了两个函数，用于一次保存或者加载多个 Python 对象，显然这些对象也可以是 ndarray。</p><pre><code>def db_pickle_save(file, data, overwrite=False):    import pickle,gzip    '''    file:        file path, to save gize pickle    data:        with style [] or ()    '''    if overwrite== False and os.path.exists(file):        print("Can't over write {}.".formate(file))        return    with gzip.open(file, "w") as f:        pickle.dump(data, f)def db_pickle_load(file):    import pickle,gzip    '''    file:        file path, to save gize pickle    data:        with style [] or ()    '''    if not os.path.exists(file):        print("File {} do not exist.".formate(file))        return    with gzip.open(file, 'rb') as f:        return pickle.load(f)</code></pre><p>操作很简单，例如：</p><pre><code>a = np.arange(4).reshape(2,2)b = np.arange(9).reshape(3,3)fname = "narray.gzip"dbload.db_pickle_save(fname, [a, b])a, b = dbload.db_pickle_load(fname)print(a.dtype, b.dtype)print(a)&gt;&gt;&gt;int32 int32[[0 1] [2 3]]</code></pre><p>通过 pickle 可以完整保存 python 对象的所有信息。</p><h3 id="1-2-5-数列数组"><a href="#1-2-5-数列数组" class="headerlink" title="1.2.5. 数列数组"></a>1.2.5. 数列数组</h3><h4 id="1-2-5-1-等差数列-arange"><a href="#1-2-5-1-等差数列-arange" class="headerlink" title="1.2.5.1. 等差数列 arange"></a>1.2.5.1. 等差数列 arange</h4><p>arange 可以生成整型或者浮点型数列，这与 Python 的 range 函数不同。</p><pre><code>arange([start,] stop[, step,], dtype=None)</code></pre><p>从 [start, stop) 中每隔 step 取值，生成等差数列，不含 stop。不指定 dtype 则根据数据使用最小满足类型。</p><pre><code>np.arange(0, 5, 2)  # 生成一个线性序列 &gt;&gt;&gt; [0 2 4 6 8] </code></pre><p>默认 start = 0，step = 1，下面示例生成 0-7 组成的行向量。</p><pre><code>np.arange(8) &gt;&gt;&gt; [0 1 2 3 4 5 6 7] </code></pre><p>尽管 arange 声称不含 stop，但是当参数为浮点数时，由于浮点数舍入误差（round-off error）的影响，可能会包含 stop，例如：</p><pre><code>In [1]: np.arange(1.5, 1.8, 0.3) Out[1]: array([ 1.5,  1.8]) </code></pre><p>浮点数在计算机内无法精确存储，例如这里的 0.3 实际存储的不是准确的 0.3，这导致 1.5 + 2.9. 后再进行舍入操作得到了 1.8：</p><pre><code>In [188]: a = np.array([1.8,0.3]) In [189]: a[1] Out[189]: 0.29999999999999999 </code></pre><p><strong>注意</strong></p><p>通常使用 np.linespace 来生成浮点型的差数列，而 np.arange 用于生成整型的等差数列以和 range 函数保持一致，并避免浮点误差问题。</p><h4 id="1-2-5-2-等差数列-linespace"><a href="#1-2-5-2-等差数列-linespace" class="headerlink" title="1.2.5.2. 等差数列 linespace"></a>1.2.5.2. 等差数列 linespace</h4><pre><code>linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><p>linspace() 通过个数自动推断 step，均匀地从 [start, stop] 中取等差数列。</p><p>endpoint 是否包含 stop 元素，如果为 True，则差值等于 (stop - start)/(num-1)，否则差值为  (stop - start)/(num)，如果 num 为 1，则直接取 start。</p><p>retstep 如果为 True，返回  (‘等差数列’, ‘step’)。</p><pre><code>print(np.linspace(1, 10, 4, endpoint=True)) # 步长为 (10-1)/(4-1) = 3print(np.linspace(1, 10, 4, endpoint=False))# 步长为 (10-1)/4 = 2.25# 同时返回数组和步长A,step = np.linspace(1, 10, 4, endpoint=False, retstep=True)print(A, step)&gt;&gt;&gt;[  1.   4.   7.  10.][ 1.    3.25  5.5   7.75][ 1.    3.25  5.5   7.75] 2.25</code></pre><h4 id="1-2-5-3-等比数列-logspace"><a href="#1-2-5-3-等比数列-logspace" class="headerlink" title="1.2.5.3. 等比数列 logspace"></a>1.2.5.3. 等比数列 logspace</h4><pre><code>logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><p>logspace() 等价于先等差再对元素以底数 base 乘幂：</p><pre><code>y = np.linspace(start, stop, num=num, endpoint=endpoint) power(base, y).astype(dtype) </code></pre><p>生成比例为 2 的等比数列：</p><pre><code>print(np.logspace(0, 5, num=6, endpoint=True, base=2.0)) &gt;&gt;&gt; [  1.   2.   4.   8.  16.  32.] </code></pre><h2 id="1-3-索引和切片"><a href="#1-3-索引和切片" class="headerlink" title="1.3. 索引和切片"></a>1.3. 索引和切片</h2><h3 id="1-3-1-数组索引"><a href="#1-3-1-数组索引" class="headerlink" title="1.3.1. 数组索引"></a>1.3.1. 数组索引</h3><h4 id="1-3-1-1-简单索引"><a href="#1-3-1-1-简单索引" class="headerlink" title="1.3.1.1. 简单索引"></a>1.3.1.1. 简单索引</h4><p>类似 Python 列表， 在一维数组中，可以通过中括号指定索引获取某个元素，支持正负索引：</p><pre><code>A = np.array([0,1,2]) print(A[0], A[-1]) &gt;&gt;&gt; 0 2 </code></pre><p>简单索引会把原数组元素拿出来（复制一份），并且会改变返回数组的维度。</p><p>在多维数组中， 可以用逗号分隔的索引元组获取元素：</p><pre><code>A = np.arange(9).reshape(3,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]]print(A[0,0], A[-1, -1])  # 逗号方式print(A[0][0], A[-1][-1]) # 类list方式&gt;&gt;&gt;0 80 8</code></pre><h4 id="1-3-1-2-列表索引"><a href="#1-3-1-2-列表索引" class="headerlink" title="1.3.1.2. 列表索引"></a>1.3.1.2. 列表索引</h4><p>列表索引是花式索引（fancy indexing）的一种，使用列表索引，结合切片索引，可以选择特定的多行或多列。切片索引参考  <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#array-slice">数组切片</a> 。</p><pre><code>print(A[[1,2], :]) # 选择 1,2 行&gt;&gt;&gt;[[3 4 5] [6 7 8]]print(A[:, [1,2]]) # 选择 1,2 列&gt;&gt;&gt;[[1 2] [4 5] [7 8]]</code></pre><p>如果要同时选择 1,2 行和 1,2 列需要分步进行：</p><pre><code># 此方式选择元素并组合为向量print(A[[1,2],[1,2]])print(A[[1,2], :][:,[1,2]])&gt;&gt;&gt;[4 8][[4 5] [7 8]]</code></pre><p>第一种的方式，会选择 [1,2] 和 [1,2] 作为行列坐标，并生成向量 [A[1,1], A[2,2]]，注意它们的区别。</p><h4 id="1-3-1-3-修改元素值"><a href="#1-3-1-3-修改元素值" class="headerlink" title="1.3.1.3. 修改元素值"></a>1.3.1.3. 修改元素值</h4><p>如果可以索引到某个元素，那么也可以通过索引赋值，来更新元素：</p><pre><code>A = np.array([[0,1,2],[3,4,5]])print(A)A[0,0] = -1print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5]][[-1  1  2] [ 3  4  5]]A[:, [1,2]] = -1 # 列表索引把 1,2 列所有元素赋值为 -1print(A)&gt;&gt;&gt;[[ 0 -1 -1] [ 3 -1 -1]]</code></pre><p><strong>注意</strong></p><p>ndarray 对象元素必须为相同类型，所以更新元素值时会自动转换类型，也即 A[index,…] = A.dtype(newval)。</p><h3 id="1-3-2-数组切片"><a href="#1-3-2-数组切片" class="headerlink" title="1.3.2. 数组切片"></a>1.3.2. 数组切片</h3><p>类似 Python 中的列表，也可以用切片（slice） 符号获取数组的多个元素， 切片符号用冒号（:） 表示。</p><p>切片操作支持指定步长，格式为 [start:stop:step]，步长可以为负数，此时如果 start 和 stop 如果没有提供默认值，则对应尾部索引和头部索引值。</p><p>如果以上 3 个参数都未指定， 那么它们会被分别设置默认值 start=0、stop= 维度的大小（size of dimension） 和 step=1。</p><p><strong>注意</strong></p><p>ndarray 切片操作不会复制数据，新数组是原数组的一个视图，这和 Python 切片浅拷贝有本质区别，简单索引会复制。可以使用 a.base is not None 查看对象是否为视图。</p><h4 id="1-3-2-1-一维数组切片"><a href="#1-3-2-1-一维数组切片" class="headerlink" title="1.3.2.1. 一维数组切片"></a>1.3.2.1. 一维数组切片</h4><p>一维数组切片和列表切片操作完全相同：</p><pre><code>A = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])print(A[:2])   # 前2个元素print(A[2:])   # 索引 2 之后的元素print(A[3:5])  # 索引 [3-5) 子数组print(A[::2])  # 每隔一个元素print(A[4::2]) # 每隔一个元素， 从索引4开始&gt;&gt;&gt;[0 1][2 3 4 5 6 7 8 9][3 4][0 2 4 6 8][4 6 8]</code></pre><p>指定 step 为 -1，此时 start 指向尾部索引，stop 指向头部，如果指定 start 和 stop，则 start &gt; stop：</p><pre><code>print(A[::-1])   # 逆序print(A[5:1:-2]) # 从索引 [5,1) 逆序间隔取元素&gt;&gt;&gt;[9 8 7 6 5 4 3 2 1 0][5 3]</code></pre><h4 id="1-3-2-2-多维数组切片"><a href="#1-3-2-2-多维数组切片" class="headerlink" title="1.3.2.2. 多维数组切片"></a>1.3.2.2. 多维数组切片</h4><p>多维数组切片格式与一维数组一致，只是分别对每一个维度进行切片。</p><pre><code>A = np.array([[ 0,  1,  2,  3],              [10, 11, 12, 13],              [20, 21, 22, 23]])print(A[:2, :2]) # 取第 0,1 行和第 0,1 列print(A[1:, 1:]) # 去掉第一行和第一列&gt;&gt;&gt;[[ 0  1] [10 11]][[11 12 13] [21 22 23]]</code></pre><p>从示例中可以看出，使用切片很容易取左上角和右下角元素。当然也可按步间隔选取特定行或者列：</p><pre><code>print(A[::2, :])  # 隔行选取行print(A[:, ::2])  # 隔列选取列&gt;&gt;&gt;[[ 0  1  2  3] [20 21 22 23]][[ 0  2] [10 12] [20 22]]</code></pre><p>对多维数组进行逆序操作：</p><pre><code>print(A[::-1, :]) # 逆序行&gt;&gt;&gt;[[20 21 22 23] [10 11 12 13] [ 0  1  2  3]]print(A[:, ::-1]) # 逆序列&gt;&gt;&gt;[[ 3  2  1  0] [13 12 11 10] [23 22 21 20]]print(A[:-1:, ::-1]) # 逆序行和列&gt;&gt;&gt;[[23 22 21 20] [13 12 11 10] [ 3  2  1  0]]</code></pre><p>对于 3 维或以上的多维数组，可以进行如下简写：</p><pre><code>A = np.arange(16).reshape((2, 2, 4))print(A)print(A[1, ...])  # 等价于 A[1,:,:]print(A[..., 1])  # 等价于 A[:,:,1]&gt;&gt;&gt;[[[ 0  1  2  3]  [ 4  5  6  7]] [[ 8  9 10 11]  [12 13 14 15]]][[ 8  9 10 11] [12 13 14 15]][[ 1  5] [ 9 13]]</code></pre><p>需要注意的是 A[1, …] 中的 1 是简单索引，返回 A[1] 对应的元素，它是一个数组形状为 (2,4) 的数组。</p><p>A[…, 1] 则是先找到最后一维的元素，然后拿出其中索引为 [1] 的元素：</p><pre><code>[ 0  1  2  3] # =&gt; 1[ 4  5  6  7] # =&gt; 5[ 8  9 10 11] # =&gt; 9[12 13 14 15] # =&gt; 13# 然后把拿出的元素放回原位置，替代最后一维的元素，也即 1 替代 [ 0  1  2  3][[ 1  5] [ 9 13]]</code></pre><p>注意：A[…, 1] 和 A[…, 1:] 不等价，A[…, 1:] 返回与原数组相同形状的数组。</p><h4 id="1-3-2-3-取行和列"><a href="#1-3-2-3-取行和列" class="headerlink" title="1.3.2.3. 取行和列"></a>1.3.2.3. 取行和列</h4><p>使用切片操作可以选取任意行和列：</p><pre><code>A = np.array([[ 0,  1,  2,  3],              [10, 11, 12, 13],              [20, 21, 22, 23]])print(A[:, 0]) # 取第 0 列print(A[1, :]) # 取第 1 行&gt;&gt;&gt;[ 0 10 20][10 11 12 13]</code></pre><p>需要注意的是，选取的列变成了行向量，而不是列向量，如果要返回 n*1 列向量则需要进行变形。</p><pre><code>column = A[:, 0].reshape((3, 1))print(column)&gt;&gt;&gt;[[ 0] [10] [20]]</code></pre><p>在获取行时，可以省略二维索引，例如 A[1] 和 A[1, :] 是等价的。可以将行赋值给多个元素：</p><pre><code>A = np.arange(4).reshape(2,2)a,b=Aprint(a)print(b)&gt;&gt;&gt;[0 1][2 3]# 以上操作等价于a = A[0]b = A[1]</code></pre><h4 id="1-3-2-4-为任意行列赋值"><a href="#1-3-2-4-为任意行列赋值" class="headerlink" title="1.3.2.4. 为任意行列赋值"></a>1.3.2.4. 为任意行列赋值</h4><p>我们可以任意选取行或列，当然也可以为这些行或列赋值：</p><pre><code>A = np.arange(9).reshape(3,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]]# 将行 1,2 元素赋值为 -1A[[1,2], : ] = -1print(A)&gt;&gt;&gt;[[ 0  1  2] [-1 -1 -1] [-1 -1 -1]]# 将列 1,2 元素赋值为 -2A[:, [1,2]] = -2print(A)&gt;&gt;&gt;[[ 0 -2 -2] [-1 -2 -2] [-1 -2 -2]]</code></pre><h4 id="1-3-2-5-交换行和列"><a href="#1-3-2-5-交换行和列" class="headerlink" title="1.3.2.5. 交换行和列"></a>1.3.2.5. 交换行和列</h4><p>使用切片很容易交换任意行和列，例如：</p><pre><code>A = np.arange(9).reshape(3,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]]# 交换 1 行和 2 行A[[1,2], : ] = A[[2,1], :]print(A)&gt;&gt;&gt;[[0 1 2] [6 7 8] [3 4 5]]# 交换 1 列和 2 列A[:, [1,2]] = A[:, [2,1]]print(A)&gt;&gt;&gt;[[0 2 1] [6 8 7] [3 5 4]]</code></pre><p>也可以使用置换矩阵进行交换，参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#permutation-swap">交换行或列</a>。</p><h2 id="1-4-复制和层叠"><a href="#1-4-复制和层叠" class="headerlink" title="1.4. 复制和层叠"></a>1.4. 复制和层叠</h2><h3 id="1-4-1-复制数组"><a href="#1-4-1-复制数组" class="headerlink" title="1.4.1. 复制数组"></a>1.4.1. 复制数组</h3><p>ndarray 对象 copy() 方法可以方便对数组对象的复制：</p><pre><code>A = np.array([0, 1, 2])row = A[:2].copy()print(row)print(A.copy())&gt;&gt;&gt;[0 1][0 1 2]</code></pre><p>此时修改新数组，原数组不受影响。</p><h3 id="1-4-2-repeat"><a href="#1-4-2-repeat" class="headerlink" title="1.4.2. repeat"></a>1.4.2. repeat</h3><p>np.repeat 对数组进行 <strong>逐元素</strong> 重复以生成新数组，在深入介绍它之前，先看一个例子：</p><pre><code>print(np.repeat(3, 4))&gt;&gt;&gt;[3 3 3 3]</code></pre><p>np.repeat 生成了向量，把 3 重复了 4 次。np.repeat 可以完成更复杂的功能：</p><pre><code>repeat(a, repeats, axis=None)  Repeat elements of an array.</code></pre><ul><li>a 可以是一个数，也可以是数组。</li><li>axis=None，时会进行 a.flatten()，实际上就是变成一向量，否则在指定的轴上重复。</li><li>repeats 可以为一个数，也可以为一个序列或数组，它会被广播以匹配要复制的轴的形状。</li></ul><p>我们分析上面示例的实现过程：</p><ol><li>如果 a 不是数组，首先把 a  转换为 1 维数组，这里 a 为 3，转换为 [3]</li><li>由于 axis = None，所以对 a 展平成一维数组，a.flatten() 也即 [3]</li><li>a.shape 为 (1,)，repeats 转换为 [4]，shape 为 (1,)，形状相同，如果不同按照广播规则扩展为相同</li><li>最后元素 3 对应的重复次数为 4，也即 3 重复 4 次得到 [3 3 3 3]</li></ol><p>再看一个稍微复杂的例子，可以看出最终重复是以单个元素为单位的：</p><pre><code># 等价于 np.repeat(np.array([1,2]), [2])print(np.repeat(np.array([1,2]), 2))&gt;&gt;&gt;[1 1 2 2]# 由于 axis = None，所以先展平为一维数组再重复print(np.repeat(np.array([[1,2],[3,4]]), [2]))&gt;&gt;&gt;[1 1 2 2 3 3 4 4]</code></pre><p>展平后的 shape 为 (4,)，而 repeat.shape 为 (1,)，所以广播扩展为 [2 2 2 2]，然后各元素按照对应的重复次数进行重复。</p><p>下面的示例展示 axis = n 的作用，注意 axis 参数不可以超过指定的数组维数：</p><pre><code>A = np.array([[1,2],[3,4]])B = np.repeat(A, [2], axis = 0)print(A.shape, B.shape)print(B)&gt;&gt;&gt;(2, 2) (4, 2) # 只对 0 轴重复[[1 2] [1 2] [3 4] [3 4]]</code></pre><p>当指定 axis = 0 时，只对 0 轴重复。A 的 shape[0] 为 2, repeat 的 shape 为 1，广播扩展为 [2 2]，然后对 0 轴各个元素重复，使得 A.shape[0] = 4。</p><p>再分析一个更复杂的例子，每个元素进行不同的重复：</p><pre><code>A = np.repeat(np.array([[1,2],[3,4]]), [2,3], axis=1)print(A.shape)print(A)&gt;&gt;&gt;(2, 5)[[1 1 2 2 2] [3 3 4 4 4]]</code></pre><p>这里对 1 轴进行重复，步骤如下：</p><ol><li>A.shape(2,2)，也即 A.shape[1] = 2，repeat.shape 也等于 2，不用扩展</li><li>分别对 1 轴上的元素 1,2 重复 2,3 次，3,4 重复 2,3 次。</li></ol><p>再看一个不符合广播规则的例子：</p><pre><code>A = np.repeat(np.array([[1,2,3],[4,5,6]]), [2,3], axis=1)&gt;&gt;&gt;ValueError: operands could not be broadcast together with shape (3,) (2,)</code></pre><h3 id="1-4-3-层叠"><a href="#1-4-3-层叠" class="headerlink" title="1.4.3. 层叠"></a>1.4.3. 层叠</h3><pre><code>tile(A, reps)    Construct an array by repeating A the number of times given by reps.</code></pre><p>tile 英文原意为“用瓦片、瓷砖等覆盖”，这里引申为复制数组A，复制的过程很像瓦片层叠地铺开，返回一个新数组。</p><ul><li>A 可以是一个数，自动转换为 [A]。</li><li>reps 是 repetitions 的缩写，描述如何进行复制，它是一个数或元组或一维数组，均会转变为一维数组。</li></ul><p>新数组的维度大小由 max(d, A.ndim) 决定，其中 d 为元组 reps 的元素个数。由 d 和 A.ndim之间的大小关系，分三种情况讨论。</p><h4 id="1-4-3-1-A-ndim-lt-d"><a href="#1-4-3-1-A-ndim-lt-d" class="headerlink" title="1.4.3.1. A.ndim < d"></a>1.4.3.1. A.ndim &lt; d</h4><ol><li>A 在左侧添加新轴，以满足 A.ndim == d。</li><li>根据reps中的值对A在相应维度的值进行复制。</li></ol><pre><code>print(np.tile(1, (2,3)))&gt;&gt;&gt;[[1 1 1] [1 1 1]]</code></pre><ol><li>A = 1，转换为 [1]，A.ndim = 1；reps 对应一维数组 [2 3]，d = 2。</li><li>由于 A.ndim &lt; d，所以对 A.shape=(1,) 扩充为 A.shape=(1,1)</li><li>此时 A 对应 [[1]]，然后各 axis 按照 reps[axis] 给定的重复次数重复元素</li><li>首先重复 0 轴 2 次 [[1][1]]，再重复 1 轴 3次 [[1 1 1] [1 1 1]]</li></ol><h4 id="1-4-3-2-A-ndim-gt-d"><a href="#1-4-3-2-A-ndim-gt-d" class="headerlink" title="1.4.3.2. A.ndim > d"></a>1.4.3.2. A.ndim &gt; d</h4><p>将 reps 按广播规则扩充至与A相同的维度：向reps元组中左侧添加1。</p><pre><code>print(np.tile([[1,2]], (2)))&gt;&gt;&gt;[[1 2 1 2]]</code></pre><ol><li>A.ndim = 2, reps.d = 1，将 reps 扩展为 [1 2]</li><li>0 轴重复 1 次，1 轴重复 2 次</li></ol><p>A.ndim = d 的情况比较简单，不用扩充，直接重复即可。</p><h4 id="1-4-3-3-repeat-和-tile-的区别"><a href="#1-4-3-3-repeat-和-tile-的区别" class="headerlink" title="1.4.3.3. repeat 和 tile 的区别"></a>1.4.3.3. repeat 和 tile 的区别</h4><ul><li>repeat 只能对特定轴重复，repeats 参数广播匹配到该轴的任何一个元素</li><li>tile 可以同时对多个轴重复，reps 广播到各个轴。</li></ul><pre><code>A = np.array([[1,2]])print(np.repeat(A, [2], axis=1))print(np.tile(A, [2]))&gt;&gt;&gt;[[1 1 2 2]][[1 2 1 2]]</code></pre><p>tile 示例：</p><pre><code>img = plt.imread("lena.png")# 分别在行和列重复 2,2 第3维RGB数据不重复mpl.image.imsave('tile.png', np.tile(img, [2,2,1]))</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/tile.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/tile.png" alt="tile"></a></p><p>np.tile 的直观示例</p><p>repeat 示例，每列均进行了插值，图像变宽：</p><pre><code># 对轴 1 进行重复 mpl.image.imsave('repeat.png', np.repeat(img, [2], axis=1)) </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/repeat.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/repeat.png" alt="repeat"></a></p><p>np.repeat 的直观示例</p><h2 id="1-5-数组变形"><a href="#1-5-数组变形" class="headerlink" title="1.5. 数组变形"></a>1.5. 数组变形</h2><h3 id="1-5-1-reshape"><a href="#1-5-1-reshape" class="headerlink" title="1.5.1. reshape"></a>1.5.1. reshape</h3><pre><code>reshape(a, newshape, order='C')</code></pre><p>reshape() 函数对输入数组使用新的 newshape 进行变形，返回新数组，数组元素是原数组引用，不会复制。</p><p>使用 reshape() 必须满足原数组的大小和变形后数组大小一致。</p><pre><code>A = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])newA = np.reshape(A, (3, 3))newA[0, 0] = -1print(newA)print(A)&gt;&gt;&gt;[[-1  1  2] [ 3  4  5] [ 6  7  8]][-1  1  2  3  4  5  6  7  8]</code></pre><p>reshape 在某一维度上可以支持 -1 参数，这样该维度将自动由元素个数来计算：</p><pre><code>n [51]: aOut[51]:array([[0, 1],       [2, 3]])In [52]: a.reshape(-1,2) # 自动生成 2*2 数组Out[52]:array([[0, 1],       [2, 3]])In [53]: a.reshape(-1,1) # 自动生成 4*1 数组Out[53]:array([[0],       [1],       [2],       [3]])</code></pre><h3 id="1-5-2-增加维度"><a href="#1-5-2-增加维度" class="headerlink" title="1.5.2. 增加维度"></a>1.5.2. 增加维度</h3><p>np.newaxis 的值被定义为 None，它可以作为索引值传递给 ndarray 对象，并返回一个添加了维度（轴）的新数组，不复制元素。</p><pre><code>A = np.array([1, 2, 3])B = A[np.newaxis, :] # 添加行，变成 1*n 二维数组C = A[:, np.newaxis] # 添加列，变成 n*1 二维数组print(B)print(C)&gt;&gt;&gt;[[1 2 3]][[1] [2] [3]]</code></pre><p>np.newaxis 放在第几个位置，就会在 shape 中相应位置增加一个维数。</p><pre><code>A = np.arange(4).reshape(2,2)print(A.shape)print(A[:,np.newaxis,:].shape)&gt;&gt;&gt;(2, 2)(2, 1, 2)</code></pre><p>通常从二维数组里面抽取一列，取出来之后维度却变成了一维，如果我们需要将其还原为二维，就可以使用上述方法。</p><p>当然，也可以使用 reshape() 来实现这类变形。</p><h3 id="1-5-3-扩展维度"><a href="#1-5-3-扩展维度" class="headerlink" title="1.5.3. 扩展维度"></a>1.5.3. 扩展维度</h3><p>np.expand_dims 是另一个扩展维度函数，可以直接通过 axis 指定要扩展的维度的轴。</p><pre><code>A = np.arange(4).reshape(2,2)print(A.shape)print(np.expand_dims(A, axis=0).shape)print(np.expand_dims(A, axis=1).shape)&gt;&gt;&gt;(2, 2)(1, 2, 2)(2, 1, 2)</code></pre><p>axis 大于当前维度时，在最后的轴上扩展维度</p><pre><code>print(np.expand_dims(A, axis=10).shape)&gt;&gt;&gt;(2, 2, 1)</code></pre><h3 id="1-5-4-数组展平"><a href="#1-5-4-数组展平" class="headerlink" title="1.5.4. 数组展平"></a>1.5.4. 数组展平</h3><p>数组展平，也即多维数组降为一维数组，np.ravel 和 ndarray.flatten 实现该功能，区别在于 ndarray.flatten 返回一份拷贝。</p><pre><code>A = np.arange(4).reshape((2, 2))print(A)print(A.ravel()) # 返回视图print(A.flatten()) # 返回拷贝&gt;&gt;&gt;[[0 1] [2 3]][0 1 2 3][0 1 2 3]</code></pre><h2 id="1-6-拼接和分割"><a href="#1-6-拼接和分割" class="headerlink" title="1.6. 拼接和分割"></a>1.6. 拼接和分割</h2><h3 id="1-6-1-行列合并和扩展"><a href="#1-6-1-行列合并和扩展" class="headerlink" title="1.6.1. 行列合并和扩展"></a>1.6.1. 行列合并和扩展</h3><h4 id="1-6-1-1-向量拼接"><a href="#1-6-1-1-向量拼接" class="headerlink" title="1.6.1.1. 向量拼接"></a>1.6.1.1. 向量拼接</h4><p>np.r_ 拼接多个向量，标量，列表，元组或切片对象，并返回向量，与 np.concatenate 相比，它可以处理 slice 切片对象。</p><p>该方法通过类实现并重载了索引运算符 []，所以用中括号 [] 调用, 而不是 ()。[] 被称为索引表达式。</p><pre><code>c = np.r_[0.0, np.array([1,2,3,4]), 0.0]print(c)&gt;&gt;&gt;[ 0.  1.  2.  3.  4.  0.]</code></pre><p>切片对象拼接：</p><pre><code># 等价于 np.r_[0.0, slice(1,5), 0.0]print(np.r_[0.0, 1:5, 0.0])&gt;&gt;&gt;[ 0.  1.  2.  3.  4.  0.]</code></pre><p>切片支持虚数，此时按照 np.linspace 扩展元素个数，包含 stop：</p><pre><code>print(np.r_[-1:1:5j, [0]*3, 5, 6])&gt;&gt;&gt;[-1.  -0.5  0.   0.5  1.   0.   0.   0.   5.   6. ]</code></pre><p>np.r_ 的实现等价于如下代码：</p><pre><code>concatenate(map(atleast_1d,args),axis=0) </code></pre><ul><li>如果索引表达式 （index expression）是以逗号分割的数组，在 0 轴合并它们。</li><li>如果表达式包含切片索引，标量则首先使用 np.atleast_1d 把它们转换为 1D 向量。</li></ul><p>np.r_ 可接受一个字符串，用于指定拼接的轴，例如：</p><pre><code>a = np.array([[0, 1, 2], [3, 4, 5]])print(np.r_['-1', a, a]) # -1 表示在最后一轴进行拼接&gt;&gt;&gt;[[0 1 2 0 1 2] [3 4 5 3 4 5]]</code></pre><p>np.r_ 还支持更复杂的字符串参数，例如 ‘0,2,0’：</p><ul><li>其中第一字符 ‘0’ 表示在 0 轴进行拼接。</li><li>第二个字符 ‘2’ 表示返回的数组轴数至少为 2，如果不足则在 0 轴前部插入 1 （pre-pended，最后轴后部插入 1，称为 post-pended）。</li><li>第三个字符 ‘0’ 表示轴 0 与最后一轴 (axis = -1) 进行交换。</li></ul><p>实际上拼接动作在最后进行，先对各个数组进行维度扩充，然后交换轴，最终调用 np.concatenate 进行拼接。</p><pre><code>print(np.r_['0,2,0', [1,2], [3,4]]) &gt;&gt;&gt;[[1] [2]  [3]  [4]] </code></pre><p>以上操作等价于：</p><ul><li>首先使用 atleast_1d 将所有序列参数转化为 1D 向量 ndarray 类型，得到 [1 2] 和 [3 4]。</li><li>接着转换为 2D 数组，也即进行 pre-pended，得到 shape=(1,2) 的 2D 数组 [[1 2]] 和 [[3 4]]。</li><li>由于第三个字符为 ‘0’，继续交换 0 轴和 -1 轴，也即得到 2x1 两个 2D 数组 [[1] [2]] 和 [[3] [4]]。</li><li>最后在 axis = 0 上进行拼接得到 [[1] [2] [3] [4]]。</li></ul><p>np.c_ 的实现等价于：</p><pre><code>np.r_['-1,2,0', index expression] </code></pre><p>显然 np.c_ 总是在最后一轴进行合并，并返回至少是 2D 的数组，且交换 0 轴和最后一轴。</p><pre><code>import numpy as npa = np.array([1, 2, 3])b = np.array([4, 5, 6])c = np.c_[a,b]print(c)&gt;&gt;&gt;[[1 4] [2 5] [3 6]]</code></pre><p>以上操作步骤如下：</p><ul><li>首先转换为 2D 数组，得到 1x2 数组 [[1 2 3]] 和 [[4 5 6]]。</li><li>接着交换 0 轴和 -1 轴，得到 2x1 的 2D 数组，[[1] [2] [3]] 和 [[4] [5] [6]]。</li><li>最后在 axis = -1 轴进行合并，最终得到如上结果。</li></ul><p>通常 np.r_ 和 np.c_ 只用于切片对象的合并，由于它们通过 Python 的类实现，所以效率不高，另外字符参数比较隐晦，包含了多步操作，使得代码难于理解，更易用易读的合并操作应该通过 stack 系列函数完成。</p><h4 id="1-6-1-2-向量合并为矩阵"><a href="#1-6-1-2-向量合并为矩阵" class="headerlink" title="1.6.1.2. 向量合并为矩阵"></a>1.6.1.2. 向量合并为矩阵</h4><p>column_stack 将 1D 向量作为列，合并为 2D 数组，参数只可以为 1D 数组。</p><pre><code>a = np.array([1, 2, 3])b = np.array([4, 5, 6])# 按列合并为二维数组print(np.column_stack([a, b]))&gt;&gt;&gt;[[1 4] [2 5] [3 6]]</code></pre><p>column_stack 代码实现等价于：</p><pre><code>arrays = map( transpose,map(atleast_2d,tup) ) concatenate(arrays, axis=1) </code></pre><ul><li>首先对所有数组通过 pre-pended 扩充，转换为 2D 数组。</li><li>接着进行交换行和列，也即转置操作。</li><li>最后在列上进行拼接。</li></ul><p>row_stack 等价于 vstack，在行上均迭 1D 向量，合并为 2D 数组。</p><pre><code># 按行合并为二维数组print(np.row_stack([a, b]))&gt;&gt;&gt;[[1 2 3] [4 5 6]]</code></pre><p>总结：从数字序列转换为 1D 向量可以使用 np.r_，多个 1D 向量可以使用 column_stack 和 row_stack 转换为 2D 矩阵。</p><h4 id="1-6-1-3-扩展行或列"><a href="#1-6-1-3-扩展行或列" class="headerlink" title="1.6.1.3. 扩展行或列"></a>1.6.1.3. 扩展行或列</h4><pre><code>numpy.insert(arr, obj, values, axis=None)</code></pre><p>numpy.insert 接受四个参数，axis 是可选参数。返回一个插入向量后的数组。若axis=None，则返回一个扁平(flatten)数组。</p><ul><li>arr：要插入元素的数组</li><li>obj：int，指定插入的位置，在第几行/列之前</li><li>values： 要插入的数组</li><li>axis：要插入的的轴，插入某一行(0)，列(1)</li></ul><pre><code>a = np.array([1, 2, 3])b = np.array([0,0])# 0 轴插入c = np.insert(a, 1, b, axis=0)print(c)&gt;&gt;&gt;[1 0 0 2 3]a = np.array([1, 2, 3, 4]).reshape(2,2)b = np.array([0,0])print(a)&gt;&gt;&gt;[[1 2] [3 4]]</code></pre><p>行插入和列插入通过 axis 指定插入轴：</p><pre><code># 行插入print(np.insert(a, 1, b, axis=0))&gt;&gt;&gt;[[1 2] [0 0] [3 4]]# 列插入print(np.insert(a, 1, b, axis=1))&gt;&gt;&gt;[[1 0 2] [3 0 4]]</code></pre><h3 id="1-6-2-数组堆叠和拼接"><a href="#1-6-2-数组堆叠和拼接" class="headerlink" title="1.6.2. 数组堆叠和拼接"></a>1.6.2. 数组堆叠和拼接</h3><p>堆叠和拼接操作会复制原数组元素。</p><h4 id="1-6-2-1-任意轴拼接"><a href="#1-6-2-1-任意轴拼接" class="headerlink" title="1.6.2.1. 任意轴拼接"></a>1.6.2.1. 任意轴拼接</h4><p>concatenate(tuple) 将相同轴数的数组元组进行拼接。结果数组不改变轴数。之所以首先介绍该函数，在于下面的 stack 系列函数最终都是通过它实现的（np.c_ 和 np.r_ 最终也通过它实现，实际上它是 C 语言的接口函数）。</p><pre><code>A = np.array([1, 2, 3])B = np.array([4, 5, 6])AB = np.concatenate((A, B))print(AB)&gt;&gt;&gt;[1 2 3 4 5 6]</code></pre><p>拼接二维数组可以指定要拼接的轴，默认 axis = 0。</p><pre><code>A = np.array([[1, 2, 3]])B = np.array([[4, 5, 6]])C = np.concatenate((A, B), axis=0) # 增加行数print(C)D = np.concatenate((A, B), axis=1) # 增加列数print(D)&gt;&gt;&gt;[[1 2 3] [4 5 6]][[1 2 3 4 5 6]]</code></pre><p>与聚合操作比较，可以发现聚合操作默认会减少轴数，而拼接操作不会改变轴数。concatenate 要求所有数组除了拼接的轴上的 shape 值无需相同，其他的轴上的 shape 值必须相同，否则无法拼接。</p><h4 id="1-6-2-2-垂直堆叠"><a href="#1-6-2-2-垂直堆叠" class="headerlink" title="1.6.2.2. 垂直堆叠"></a>1.6.2.2. 垂直堆叠</h4><p>vstack(tuple) 接受一个由数组组成的元组，每个数组在列上的元素个数必须相同：</p><pre><code>A = np.array([1, 2, 3])B = np.array([[4, 5, 6], [7, 8, 9]])print(np.vstack((A, B, A)))&gt;&gt;&gt;[[1 2 3] [4 5 6] [7 8 9] [1 2 3]]</code></pre><p>vstack 依次处理各个数组，按第一个轴依次取数据，生成新数组。看起来像是在垂直方向上堆叠数据。等价于如下操作：</p><pre><code>concatenate( map(atleast_2d,tup), axis=0) </code></pre><p>显然要进行垂直堆叠操作，数组至少是 2D 的，转换后在行上堆叠：vstack 在 1D 上堆叠会返回 2D 数组。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/vstack.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/vstack.png" alt="borders"></a></p><p>vstack 垂直堆叠示意图</p><h4 id="1-6-2-3-水平堆叠"><a href="#1-6-2-3-水平堆叠" class="headerlink" title="1.6.2.3. 水平堆叠"></a>1.6.2.3. 水平堆叠</h4><p>hstack(tuple) 与 vstack(tuple) 类似，按第二个轴依次取数据，数组行数必须相同，看起来像是在水平方向堆叠数据。</p><pre><code>A = np.array([0, 1, 2])B = np.array([30,40])print(np.hstack((A, B, A)))&gt;&gt;&gt;[0, 1, 2, 30, 40, 0, 1, 2]</code></pre><p>hstack 等价于如下操作：</p><pre><code>concatenate( map(atleast_1d,tup), axis=1) </code></pre><p>水平堆叠只需要保证数组有 1D 即可，所以结果不会增加向量的轴数。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/hstack.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/hstack.png" alt="borders"></a></p><p>hstack 水平堆叠示意图</p><h3 id="1-6-3-数组分割"><a href="#1-6-3-数组分割" class="headerlink" title="1.6.3. 数组分割"></a>1.6.3. 数组分割</h3><p>与数组拼接对应的是分割操作。垂直分割和水平分割均作用在 0 轴上，也即 axis = 0。</p><p>分割不会复制原数组元素。</p><h4 id="1-6-3-1-垂直分割"><a href="#1-6-3-1-垂直分割" class="headerlink" title="1.6.3.1. 垂直分割"></a>1.6.3.1. 垂直分割</h4><pre><code>vsplit(ary, indices_or_sections)</code></pre><p>vsplit() 在垂直方向上对 ary 进行分割，indices_or_sections 有两种方式指定：</p><ul><li>整数 n ，该整数在垂直方向必须可以均分各行，也即 shape[0] % n == 0。</li><li>[indeices]，逗号分割的索引值，也即行的索引值，n 个索引分割出 n + 1 个新数组。</li></ul><pre><code> = np.arange(6).reshape(6, 1)print(A)subs = np.vsplit(A, 2) # 垂直 2 等分for i in subs:    print(i)&gt;&gt;&gt;[[0] [1] [2] [3] [4] [5]][[0] [1] [2]][[3] [4] [5]]# 使用索引分割，各个数组对应索引范围 [0:2] [2:4] [4:]subs = np.vsplit(A, [2,4])for i in subs:    print(i)&gt;&gt;&gt;[[0] [1]][[2] [3]][[4] [5]]</code></pre><h4 id="1-6-3-2-水平分割"><a href="#1-6-3-2-水平分割" class="headerlink" title="1.6.3.2. 水平分割"></a>1.6.3.2. 水平分割</h4><pre><code>hsplit(ary, indices_or_sections)</code></pre><p>hsplit() 在水平方向上对 ary 进行分割，indices_or_sections 有两种方式指定：</p><ul><li>整数 n ，该整数在水平方向必须可以均分各列，也即 shape[0] % n == 0。</li><li>[indeices]，逗号分割的索引值，也即列的索引值，n 个索引分割出 n + 1 个新数组。</li></ul><pre><code>A = np.arange(10)print(A)&gt;&gt;&gt;[0 1 2 3 4 5 6 7 8 9]subs = np.hsplit(A, 2) # 2 等分for i in subs:    print(i)&gt;&gt;&gt;[0 1 2 3 4][5 6 7 8 9]# 使用索引分割，各个数组对应索引范围 [0:4] [4:6] [6:]subs = np.hsplit(A, [4,6])for i in subs:    print(i)[0 1 2 3][4 5][6 7 8 9]</code></pre><h4 id="1-6-3-3-任意轴分割"><a href="#1-6-3-3-任意轴分割" class="headerlink" title="1.6.3.3. 任意轴分割"></a>1.6.3.3. 任意轴分割</h4><pre><code>split(ary, indices_or_sections, axis=0)</code></pre><p>split() 可以指定用于分割的轴，其余参数与 vsplit() 和 hsplit() 一致。</p><pre><code>A = np.arange(16).reshape(4, 4)print(A)&gt;&gt;&gt;[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]]subs = np.split(A, 2, axis=0) # 行 2 等分for i in subs:    print(i)&gt;&gt;&gt;[[0 1 2 3] [4 5 6 7]][[ 8  9 10 11] [12 13 14 15]]subs = np.split(A, 2, axis=1) # 列 2 等分for i in subs:    print(i)&gt;&gt;&gt;[[ 0  1] [ 4  5] [ 8  9] [12 13]][[ 2  3] [ 6  7] [10 11] [14 15]]</code></pre><h4 id="1-6-3-4-非均匀分割"><a href="#1-6-3-4-非均匀分割" class="headerlink" title="1.6.3.4. 非均匀分割"></a>1.6.3.4. 非均匀分割</h4><p>split 函数只能进行均匀分割，例如上例中 A 有 4 行，那么分为 3 个数组就会报异常，此时可以使用 array_split，它不是均分，它尝试把多余部分依次塞入子数组中。</p><pre><code>subs = np.split(A, 3, array_split=1) # 非均匀分割for i in subs:    print(i)&gt;&gt;&gt;[[0 1 2 3] [4 5 6 7]]  # 第一个子数组行数为 2[[ 8  9 10 11]][[12 13 14 15]]</code></pre><h2 id="1-7-数组运算"><a href="#1-7-数组运算" class="headerlink" title="1.7. 数组运算"></a>1.7. 数组运算</h2><h3 id="1-7-1-算术运算"><a href="#1-7-1-算术运算" class="headerlink" title="1.7.1. 算术运算"></a>1.7.1. 算术运算</h3><h4 id="1-7-1-1-算术运算符"><a href="#1-7-1-1-算术运算符" class="headerlink" title="1.7.1.1. 算术运算符"></a>1.7.1.1. 算术运算符</h4><p>数组和标量之间的运算类似 Python 中的算术运算，支持运算符 + - * / //（地板除），** （幂） %（取余）等。</p><p>数组中所有元素均和标量发生对应运算。数组和标量运算符合交换律。</p><pre><code>A = np.arange(1, 5).reshape(2,2)print(A)&gt;&gt;&gt;[[1 2] [3 4]]print(A + 1)  # 加&gt;&gt;&gt;[[2 3] [4 5]]print(A - 1)  # 减&gt;&gt;&gt;[[0 1] [2 3]]print(A * 2)  # 乘&gt;&gt;&gt;[[2 4] [6 8]]print(A / 2)  # 除&gt;&gt;&gt;[[ 0.5  1. ] [ 1.5  2. ]]</code></pre><pre><code>print(A // 2) # 地板除&gt;&gt;&gt;[[0 1] [1 2]]print(A ** 2) # 求平方&gt;&gt;&gt;[[ 1  4] [ 9 16]]print(A % 2) # 取余&gt;&gt;&gt;[[1 0] [1 0]]</code></pre><p>我们可以将以上运算符任意组合，注意运算符的优先级，必要时需要添加小括号改变运算顺序:</p><pre><code>print(A)print(2 + (A ** 2 - 1) * 5)[[1 2] [3 4]][[ 2 17] [42 77]]</code></pre><h4 id="1-7-1-2-算术运算符和函数"><a href="#1-7-1-2-算术运算符和函数" class="headerlink" title="1.7.1.2. 算术运算符和函数"></a>1.7.1.2. 算术运算符和函数</h4><p>所有算术运算符在 NumPy 中都有内置函数的函数实现， 例如 + 运算符对应 np.add 函数，这和 Python 中的 operator 模块类似。</p><blockquote><table><thead><tr><th>运算符</th><th>对应函数</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>np.add</td><td>加法运算</td></tr><tr><td>-</td><td>np.subtract</td><td>减法运算</td></tr><tr><td>-</td><td>np.negative</td><td>负数运算</td></tr><tr><td>*</td><td>np.multiply</td><td>星乘，表示矩阵内各对应位置相乘，注意和外积内积区分</td></tr><tr><td>/</td><td>np.divide</td><td>除法运算</td></tr><tr><td>//</td><td>np.floor_divide</td><td>地板除法运算（floor division，即 5 // 2 = 2）</td></tr><tr><td>**</td><td>np.power</td><td>指数运算（即 2 ** 3 = 8）</td></tr><tr><td>%</td><td>np.mod</td><td>模 / 余数（即 5 % 2 = 1）</td></tr></tbody></table></blockquote><h3 id="1-7-2-其他数学函数"><a href="#1-7-2-其他数学函数" class="headerlink" title="1.7.2. 其他数学函数"></a>1.7.2. 其他数学函数</h3><h4 id="1-7-2-1-数值修约"><a href="#1-7-2-1-数值修约" class="headerlink" title="1.7.2.1. 数值修约"></a>1.7.2.1. 数值修约</h4><p>数值修约，又称数字修约，是指在数值进行运算前, 按照一定的规则确定一致的位数，然后舍去某些数字后面多余的尾数的过程。比如 4 舍 5 入就属于数值修约中的一种。</p><blockquote><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>np.around(A,n,out)</td><td>四舍五入到指定的小数位 n，默认 0</td></tr><tr><td>np.round(A,n,out)</td><td>等价于 np.around</td></tr><tr><td>np.rint(A)</td><td>圆整每个元素到最接近的整数，保留dtype</td></tr><tr><td>np.fix(A,out)</td><td>向原点 0 舍入到最接近的整数，out可选，拷贝返回值</td></tr><tr><td>np.floor(A)</td><td>上取整，取数轴上右侧最接近的整数</td></tr><tr><td>np.ceil(A)</td><td>下取整，取数轴上左侧最接近的整数</td></tr><tr><td>np.trunc(A,out)</td><td>截断到整数，直接删除小数部分，与 np.fix 效果等同</td></tr></tbody></table></blockquote><p>由于 python2.7 以后的 round 策略使用的是 decimal.ROUND_HALF_EVEN，也即整数部分为偶数则舍去，奇数则舍入，这有利于更好地保证数据的精确性。numpy 的四舍五入同样使用此策略。</p><pre><code>print(round(2.55, 1))  # 2.5import decimalfrom decimal import Decimalcontext = decimal.getcontext()context.rounding = decimal.ROUND_05UPprint(round(Decimal(2.55), 1))         # 2.6&gt;&gt;&gt;2.52.6</code></pre><p>以上是 python 自带的 round 函数示例，可以通过调整 decimal 四舍五入策略，并数值转化为 Decimal 对象来获取通常意义的四舍五入数值。</p><pre><code># 四舍五入，round 等价于 around 函数print('np.around([1.43,-1.55]):\t', np.around([1.43,-1.55]), 1)print('np.round(1.43,-1.55):\t\t', np.round([1.43,-1.55], 1))# 圆整每个元素到最接近的整数print('np.rint([0.5,1.5)):\t\t', np.around([0.5,1.5]))# 向原点 0 舍入到最接近的整数print('np.fix([-0.9,1.9)):\t\t', np.fix([-0.9, 1.9]))&gt;&gt;&gt;np.around([1.43,-1.55]):         [ 1. -2.] 1np.round(1.43,-1.55):            [ 1.4 -1.6]np.rint([0.5,1.5)):              [ 0.  2.]np.fix([-0.9,1.9)):              [-0.  1.]</code></pre><p>上下取整示例：</p><pre><code>print('np.ceil([-0.9,1.9)):\t\t', np.ceil([-0.1, 1.9]))print('np.floor([-0.9,1.9)):\t\t', np.floor([-0.1, 1.9]))&gt;&gt;&gt;np.ceil([-0.9,1.9)):             [-0.  2.]np.floor([-0.9,1.9)):            [-1.  1.]</code></pre><p>截断到整数，直接删除小数部分，与 np.fix 效果等同：</p><pre><code>print('np.trunc([-0.9,1.9)):\t\t', np.trunc([-0.1, 1.9]))&gt;&gt;&gt;np.trunc([-0.9,1.9)):            [-0.  1.]</code></pre><h4 id="1-7-2-2-三角函数"><a href="#1-7-2-2-三角函数" class="headerlink" title="1.7.2.2. 三角函数"></a>1.7.2.2. 三角函数</h4><blockquote><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>np.sin(A)</td><td>正弦函数</td></tr><tr><td>np.cos(A)</td><td>余弦函数</td></tr><tr><td>np.tan(A)</td><td>正切函数</td></tr><tr><td>np.arcsin(A)</td><td>反正弦函数</td></tr><tr><td>np.arccos(A)</td><td>反余弦函数</td></tr><tr><td>np.arctan(A)</td><td>反正切函数</td></tr><tr><td>np.hypot(A1,A2)</td><td>直角三角形求斜边</td></tr><tr><td>np.degrees(A)</td><td>弧度转换为度</td></tr><tr><td>np.rad2deg(A)</td><td>弧度转换为度</td></tr><tr><td>np.radians(A)</td><td>度转换为弧度</td></tr><tr><td>np.deg2rad(A)</td><td>度转换为弧度</td></tr></tbody></table></blockquote><p>示例中使用的均是数值，不要忘记，在 numpy 中这些函数自然是支持数组的。</p><pre><code>print('np.sin(np.pi):\t', np.sin(np.pi/2))print('np.cos(np.pi/2):\t', np.cos(np.pi/2))print('np.tan(np.pi/4):\t', np.tan(np.pi/4))&gt;&gt;&gt;np.sin(np.pi):   1.0np.cos(np.pi/2):         6.12323399574e-17np.tan(np.pi/4):         1.0print('np.arcsin(1):\t', np.sin(1))print('np.arccos(-1):\t', np.cos(-1))print('np.arctan(1):\t', np.tan(1))&gt;&gt;&gt;np.arcsin(1):    0.841470984808np.arccos(-1):   0.540302305868np.arctan(1):    1.55740772465# 直角三角形求斜边print('np.hypot(3,4):\t', np.hypot(3,4))&gt;&gt;&gt;np.hypot(3,4):   5.0# 弧度转换为度，两函数等价print('np.rad2deg(np.pi/2):\t', np.rad2deg(np.pi/2))print('np.degrees(np.pi/2):\t', np.degrees(np.pi/2))# 度转换为弧度，两函数等价print('np.radians(180):\t', np.radians(180))print('np.deg2rad(180):\t', np.deg2rad(180))&gt;&gt;&gt;np.rad2deg(np.pi/2):     90.0np.degrees(np.pi/2):     90.0np.radians(180):         3.14159265359np.deg2rad(180):         3.14159265359</code></pre><h4 id="1-7-2-3-双曲函数"><a href="#1-7-2-3-双曲函数" class="headerlink" title="1.7.2.3. 双曲函数"></a>1.7.2.3. 双曲函数</h4><blockquote><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>np.sinh(A)</td><td>双曲正弦</td></tr><tr><td>np.cosh(A)</td><td>双曲余弦</td></tr><tr><td>np.tanh(A)</td><td>双曲正切</td></tr><tr><td>ny.arcsinh(A)</td><td>反双曲正弦</td></tr><tr><td>np.arccosh(A)</td><td>反双曲余弦</td></tr><tr><td>np.arctanh(A)</td><td>反双曲正切</td></tr></tbody></table></blockquote><h4 id="1-7-2-4-其他数学函数"><a href="#1-7-2-4-其他数学函数" class="headerlink" title="1.7.2.4. 其他数学函数"></a>1.7.2.4. 其他数学函数</h4><p>有些数学函数没有对应的运算符，例如：</p><blockquote><table><thead><tr><th>数学函数</th><th>描述</th></tr></thead><tbody><tr><td>np.abs(A)</td><td>绝对值，np.absolute() 的缩写</td></tr><tr><td>np.reciprocal(A)</td><td>求倒数，和 1/A 有区别，默认不做类型转换，也即 1/2 = 0</td></tr><tr><td>np.exp(A)</td><td>以 e 为底的指数运算 e**A</td></tr><tr><td>np.exp2(A)</td><td>以 2 为底的指数运算 2**A</td></tr><tr><td>np.power(2, A)</td><td>通用指数函数</td></tr><tr><td>np.log(A)</td><td>以 e 为底的对数运算 ln(A)</td></tr><tr><td>np.log2(A)</td><td>以 2 为底的对数运算 log2(A)</td></tr><tr><td>np.log10(A)</td><td>以 2 为底的对数运算 log10(A)</td></tr></tbody></table></blockquote><p>np.reciprocal(A) 和 1/A 并不等同，它默认的结果数组和原数组类型相同：</p><pre><code>print(1/A)                    # 浮点数组print(np.reciprocal(A))       # 整数数组print(np.reciprocal(A * 1.0)) # 对原数组浮点转换&gt;&gt;&gt;[[ 1.          0.5       ] [ 0.33333333  0.25      ]][[1 0] [0 0]][[ 1.          0.5       ] [ 0.33333333  0.25      ]]</code></pre><p>如果对任意底数求对数，则需用到换底公式，例如以 3 为底的 4 的对数求法： np.log(4)/np.log(3)。</p><pre><code>print(np.log(A)/np.log(3))&gt;&gt;&gt;[[ 0.          0.63092975][ 1.          1.26185951]]</code></pre><p>NumPy 还提供了很多通用函数， 包括比特位运算、 比较运算符等等。</p><h3 id="1-7-3-通用函数特性"><a href="#1-7-3-通用函数特性" class="headerlink" title="1.7.3. 通用函数特性"></a>1.7.3. 通用函数特性</h3><p>通用函数有两种存在形式： 一元通用函数（unary ufunc） 对单个输入操作， 例如 np.abs(A)。 二元通用函数（binary ufunc） 对两个输入操作，例如 add(A, B)。</p><h4 id="1-7-3-1-指定输出数组"><a href="#1-7-3-1-指定输出数组" class="headerlink" title="1.7.3.1. 指定输出数组"></a>1.7.3.1. 指定输出数组</h4><p>在进行大量运算时，将结果输出到特定的用于存放运算结果的数组是非常有用的。 不同于创建临时数组， 可以用这个特性将计算结果直接写入到你期望的存储位置。 所有的通用函数都可以通过 out 参数来指定计算结果的存放位置：</p><pre><code>A = np.arange(3)B = np.empty(3)np.multiply(A, 2, out=B)print('{}\n{}'.format(A, B))&gt;&gt;&gt;[0 1 2][ 0.  2.  4.]</code></pre><p>通过为 out 指定输出数组的切片可以将计算结果写入指定数组的特定位置：</p><pre><code>A = np.zeros(10)np.add(2, np.arange(5), out=A[::2])print(A)&gt;&gt;&gt;[ 2.  0.  3.  0.  4.  0.  5.  0.  6.  0.]</code></pre><h4 id="1-7-3-2-聚合-Reduce"><a href="#1-7-3-2-聚合-Reduce" class="headerlink" title="1.7.3.2. 聚合 Reduce"></a>1.7.3.2. 聚合 Reduce</h4><p>二元通用函数具有聚合功能，这些聚合可以直接在对象上计算。 如果我们希望用一个特定的运算 reduce 一个数组， 那么可以用任何通用函数的 reduce 方法。</p><p>例如对 add 通用函数调用 reduce 方法会返回数组中所有元素的和：</p><pre><code>A = np.arange(1, 5)np.add.reduce(A)&gt;&gt;&gt;10</code></pre><p>如果需要存储每次计算的中间累积结果，可以使用 accumulate，以累乘为例：</p><pre><code>A = np.arange(1, 5)B = np.multiply.accumulate(A)print('{}\n{}'.format(A, B))&gt;&gt;&gt;[1 2 3 4][ 1  2  6 24]</code></pre><p>NumPy 也提供了专用的统计函数（np.sum、 np.prod、 np.cumsum、 np.cumprod ）来实现这类聚合。</p><h4 id="1-7-3-3-外积"><a href="#1-7-3-3-外积" class="headerlink" title="1.7.3.3. 外积"></a>1.7.3.3. 外积</h4><p>任何通用函数都可以用 outer 方法获得两个不同输入数组所有元素对的函数运算结果。 这意味着你可以用一行代码实现一个乘法表：</p><pre><code>A = np.arange(1, 4)B = np.multiply.outer(A, [2,3])print(B)&gt;&gt;&gt;[[2 3] [4 6] [6 9]]</code></pre><p>一个列向量乘以一个行向量称作向量的外积（Outer product），外积是一种特殊的克罗内克积，结果是一个矩阵，任意矩阵之间均可进行外积运算。A * B 实现步骤如下：</p><ol><li>依次使用 A[i,j…] 元素与 B 乘得到和B形状相同的矩阵 C，使用 C 替换 A 中的 [i,j…] 元素</li><li>生成的矩阵维数为 A.ndim + B.ndim</li></ol><p>分析上面例子中的计算步骤：</p><ol><li>A 为 [1 2 3]，B 为 [2 3]，首先使用 A[0,0] 1 乘以 B，得到 C = [2 3]</li><li>C 替换 A 中的 A[0,0]，得到 [[2 3] 2 3]</li><li>依次重复以上步骤，直至所有 A 中元素被替换完毕</li></ol><p>np.multiply.outer(A, 2) 等同于 A * 2，不会改变维度。</p><p>更规范的方法是使用 np.outer 求外积，np.outer 和 np.multiply.outer 有区别，它会把标量 b 转换为向量 [b]，这一点说明 NumPy 实现上有些混乱，不如 octave 简明：</p><pre><code>A = np.arange(1, 4)# 等价于print(np.outer(A, 2))print(np.outer(A, [2]))&gt;&gt;&gt;[[2] [4] [6]]print(np.outer(A, [2,3]))&gt;&gt;&gt;[[2 3] [4 6] [6 9]]</code></pre><p>一个行向量乘以一个列向量称作向量的内积，又叫作点积，结果是一个标量，矩阵间点积需要满足 A 的列等于 B 的行，结果为矩阵。参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#dot-product">点积</a> 。</p><h3 id="1-7-4-聚合统计"><a href="#1-7-4-聚合统计" class="headerlink" title="1.7.4. 聚合统计"></a>1.7.4. 聚合统计</h3><p>聚合在信息科学中是指对有关的数据进行内容挑选、分析、归类，最后分析得到人们想要的结果，主要是指任何能够从数组产生标量值的数据转换过程。</p><p>常用统计方法由下表列出，它们也被称为聚合。</p><blockquote><table><thead><tr><th>方法名称</th><th>NaN安全版本</th><th>描述</th></tr></thead><tbody><tr><td>np.sum</td><td>np.nansum</td><td>计算元素的和</td></tr><tr><td>np.prod</td><td>np.nanprod</td><td>计算元素的积</td></tr><tr><td>np.cumsum</td><td>np.nancumsum</td><td>从 0 元素开始的累计和。</td></tr><tr><td>np.cumprod</td><td>np.nancumprod</td><td>从 1 元素开始的累计乘。</td></tr><tr><td>np.mean</td><td>np.nanmean</td><td>计算元素的平均值</td></tr><tr><td>np.average</td><td>N/A</td><td>计算加权平均数</td></tr><tr><td>np.std</td><td>np.nanstd</td><td>计算元素的标准差</td></tr><tr><td>np.var</td><td>np.nanvar</td><td>计算元素的方差</td></tr><tr><td>np.min</td><td>np.nanmin</td><td>求最小值</td></tr><tr><td>np.max</td><td>np.nanmax</td><td>求最大值</td></tr><tr><td>np.argmin</td><td>np.nanargmin</td><td>找出最小值的索引</td></tr><tr><td>np.argmax</td><td>np.nanargmax</td><td>找出最大值的索引</td></tr><tr><td>np.median</td><td>np.nanmedian</td><td>计算元素的中位数</td></tr><tr><td>np.percentile</td><td>np.nanpercentile</td><td>计算基于元素排序的统计值，百分位数</td></tr><tr><td>np.any</td><td>N/A</td><td>验证任何一个元素是否为真</td></tr><tr><td>np.all</td><td>N/A</td><td>验证所有元素是否为真</td></tr></tbody></table></blockquote><p>这些方法通常支持 axis 参数指定需要聚合（统计）的轴，默认对整个数组进行聚合。对某个轴进行聚合操作后，这个轴就会被移除（collapsed）。</p><p>使用聚合函数时通常直接通过对象引用，可以让代码更简洁。某些函数，例如 average 和 NaN 安全版本不可使用对象引用，只能通过 np. 调用，它们在聚合时忽略 NaN 元素。</p><pre><code>a = np.arange(16).reshape(4,4)sum = np.sum(a, axis=0)print(sum.shape, sum)&gt;&gt;&gt;(4,) [24 28 32 36]</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sum.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/sum.png" alt="sum"></a></p><p>axis = 0 上的加法聚合示例</p><p>可以看到当指定 axis = 0 时，会在 0 轴方向进行聚合，聚合后的结果数组中 0 轴就消失了。</p><pre><code>a = np.arange(16).reshape(4,4)sum = np.sum(a, axis=1)print(sum.shape, sum)&gt;&gt;&gt;(4,) [ 6 22 38 54]</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/sumaxis1.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/sumaxis1.png" alt="sumaxis1"></a></p><p>axis = 1 上的加法聚合示例</p><p>上图中尽管画成了列向量，实际上在 numpy 中就是向量，这只是为了方便理解聚合如何作用在 1 轴上。当指定 axis = 1 时，会在 1 轴方向进行聚合，聚合后的结果数组中 1 轴就消失了，成为了 1D 向量。</p><p>聚合函数均支持 keepdims 布尔开关选项，指明是否保留结果数组的维度不变：</p><pre><code>a = np.arange(16).reshape(4,4)sum = np.sum(a, axis=1, keepdims=True)print(sum.shape)print(sum)&gt;&gt;&gt;(4, 1)[[ 6] [22] [38] [54]] </code></pre><h4 id="1-7-4-1-求和与积"><a href="#1-7-4-1-求和与积" class="headerlink" title="1.7.4.1. 求和与积"></a>1.7.4.1. 求和与积</h4><p>sum() 方法默认求所有元素和，可以指定求和的轴：</p><pre><code>A = np.arange(1,7).reshape(2,3)print(A)print(A.sum())print(A.sum(axis=0))&gt;&gt;&gt;[[1 2 3] [4 5 6]]21         # 1+2+3+...+6[5 7 9]    # [1+4 2+5 3+6]</code></pre><p>prod() 方法求元素乘积，可以指定特定轴：</p><pre><code>print(A.prod())print(A.prod(axis=0))&gt;&gt;&gt;720         # 1*2*3*...*6[ 4 10 18]  # [1*4 2*5 3*6]</code></pre><h4 id="1-7-4-2-最大最小值"><a href="#1-7-4-2-最大最小值" class="headerlink" title="1.7.4.2. 最大最小值"></a>1.7.4.2. 最大最小值</h4><p>max() 和 min() 方法统计最大最小值：</p><pre><code>A = np.arange(1,7).reshape(2,3)print(A)print(A.max(), A.min()) # 对整个数组求最大最小值&gt;&gt;&gt;[[1 2 3] [4 5 6]]6 1print(A.max(axis=0))    # 对 0 轴统计最大值&gt;&gt;&gt;[4 5 6]print(A.max(axis=1))    # 对 1 轴统计最大值&gt;&gt;&gt;[3 6]</code></pre><h4 id="1-7-4-3-最大最小值索引"><a href="#1-7-4-3-最大最小值索引" class="headerlink" title="1.7.4.3. 最大最小值索引"></a>1.7.4.3. 最大最小值索引</h4><p>argmax() 和 argmin() 求最大最小值对应的索引。</p><pre><code>A = np.arange(1,7).reshape(2,3)print(A)print(A.argmax(), A.argmin()) # 对整个数组求最大最小值的索引print(A.argmax(axis=0), A.argmin(axis=0)) # 对特定轴求做大最小索引&gt;&gt;&gt;[[1 2 3] [4 5 6]]5 0[1 1 1] [0 0 0]</code></pre><h4 id="1-7-4-4-求均值"><a href="#1-7-4-4-求均值" class="headerlink" title="1.7.4.4. 求均值"></a>1.7.4.4. 求均值</h4><p>平均数：一组数据的总和除以这组数据个数所得到的商叫这组数据的平均数，也即均值。</p><p>mean() 用于求元素和的均值，等价于 sum()/size。</p><pre><code>A = np.arange(1,7).reshape(2,3)print(A.mean())         # 所有元素均值print(A.mean(axis = 0)) # 0 轴元素均值&gt;&gt;&gt;3.5[ 2.5  3.5  4.5]print(A.mean() == A.sum()/A.size)print(A.mean(axis=0) == A.sum(axis=0)/A.shape[0])&gt;&gt;&gt;True[ True  True  True]</code></pre><h4 id="1-7-4-5-中位数"><a href="#1-7-4-5-中位数" class="headerlink" title="1.7.4.5. 中位数"></a>1.7.4.5. 中位数</h4><p>中位数：将数据按照从小到大或从大到小的顺序排列，如果数据个数是奇数，则处于最中间位置的数就是这组数据的中位数；如果数据的个数是偶数，则中间两个数据的平均数是这组数据的中位数。</p><pre><code>A = np.arange(1, 10).reshape(3, 3)print(A)print(np.median(A))print(np.median(A,axis=0))&gt;&gt;&gt;[[1 2 3] [4 5 6] [7 8 9]]5.0[ 4.  5.  6.]</code></pre><p>median() 不是对象方法，只能通过 np. 引用。</p><h4 id="1-7-4-6-加权均值"><a href="#1-7-4-6-加权均值" class="headerlink" title="1.7.4.6. 加权均值"></a>1.7.4.6. 加权均值</h4><p>np.average() 只能通过 np. 调用，不是对象的方法，如果不提供 weights 则等同于 np.mean()。</p><pre><code>print(A)&gt;&gt;&gt;[[1 2 3] [4 5 6]]print(np.average(A))print(np.average(A, axis=0))&gt;&gt;&gt;3.5[ 2.5  3.5  4.5]# 3 = (1*1 + 4*2) / (1+2)print(np.average(A, axis=0, weights=([1,2]))) # 加权平均&gt;&gt;&gt;[ 3.  4.  5.]</code></pre><h4 id="1-7-4-7-方差和标准差"><a href="#1-7-4-7-方差和标准差" class="headerlink" title="1.7.4.7. 方差和标准差"></a>1.7.4.7. 方差和标准差</h4><p>方差（Variance）在概率统计中，用于描述样本离散程度。 标准差（Standard Deviation） = sqrt(var)。</p><pre><code>def var(A):    return np.sum((A - A.mean()) ** 2) / A.sizedef std(A):    return var(A) ** 0.5</code></pre><p>方差和标准差的实现如上，方差公式如下，其中 $\rho$为标准差， ${\rho}^2$为方差，$X$为样本值，$N$ 为样本数，$\mu$为样本均值。<br>$${\rho}^2 = \frac{\sum(X - \mu)^2}{N}$$<br>均值相同的两组数据，标准差/方差未必相同，越大说明数据离散程度越大。</p><pre><code>A = np.arange(0,2)print(A)&gt;&gt;&gt;[0 1]print(var(A), A.var()) # 方差print(A.var(axis=0))   # 特定轴方差&gt;&gt;&gt;0.25 0.250.25print(A.std(), std(A)) # 标准差&gt;&gt;&gt;0.5 0.5</code></pre><h3 id="1-7-5-矩阵转换"><a href="#1-7-5-矩阵转换" class="headerlink" title="1.7.5. 矩阵转换"></a>1.7.5. 矩阵转换</h3><p>numpy 库提供了 matrix 类，它对应 matrix 对象。matrix 类继承了 ndarray，因此它们和 ndarray 有相同的属性和方法。</p><p>np.mat 实现从 2 维的 ndarray 转换为 matrix。同时可以接受一个字符串参数，形如 ‘1 2 3; 4 5 6’</p><h4 id="1-7-5-1-转矩阵"><a href="#1-7-5-1-转矩阵" class="headerlink" title="1.7.5.1. 转矩阵"></a>1.7.5.1. 转矩阵</h4><p>字符串参数转矩阵：</p><pre><code>M = np.mat('1 2 3; 4 5 6')print(M)print(type(M).__name__)&gt;&gt;&gt;[[1 2 3] [4 5 6]]matrix</code></pre><p>二维数组转矩阵：</p><pre><code>A = np.arange(1,5).reshape(2,2)M = np.mat(A)  # 等价于 np.asmatrixprint(M)print(M.shape)&gt;&gt;&gt;[[1 2] [3 4]](2, 2)</code></pre><p>np.mat 不接受更高维 ndarray 作为参数。</p><h4 id="1-7-5-2-矩阵属性"><a href="#1-7-5-2-矩阵属性" class="headerlink" title="1.7.5.2. 矩阵属性"></a>1.7.5.2. 矩阵属性</h4><p>矩阵对象具有一些特性：</p><ul><li>只有两个维度，也即 ndim 永远为 2</li><li>M.ravel 和 M.flatten 展平操作返回的还是二维数组，只是第一维为 shape 为 1，形如 [[1 2 3 4]]</li><li>matrix 重载了 * (星乘) 运算符，实现矩阵的乘积，M * M 等同于 np.dot(ndarray)</li><li>matrix 重载了 ** (乘幂) 的运算，M ** 2 等价于 M * M</li><li>matrix 具有一些特殊使用，让矩阵计算更方便，例如 M.T（转置），M.I（逆矩阵），M.H（共轭矩阵）和 M.A（以 ndarray 对象返回）</li></ul><p>矩阵乘积：</p><pre><code># 等价于 print(M.dot(M))print(M * M)&gt;&gt;&gt;[[ 7 10] [15 22]]</code></pre><p>矩阵展平：</p><pre><code>print(M.ravel)&gt;&gt;&gt; [[1 2 3 4]] </code></pre><p>矩阵乘幂：</p><pre><code># 等价于 M * M 也即 M.dot(M) print(M ** 2) &gt;&gt;&gt; [[ 7 10]  [15 22]] </code></pre><p>矩阵内置属性：</p><pre><code># 矩阵转置print(M.T)&gt;&gt;&gt;[[1 3] [2 4]]# 逆矩阵，等价于 la.inv(M)print(M.I)&gt;&gt;&gt;[[-2.   1. ] [ 1.5 -0.5]]# 共轭矩阵print(M.H)&gt;&gt;&gt;[[1 3] [2 4]]# 以 ndarray 对象返回print(M.A)print(type(M.A).__name__)&gt;&gt;&gt;[[1 2] [3 4]]ndarray</code></pre><h4 id="1-7-5-3-置换矩阵"><a href="#1-7-5-3-置换矩阵" class="headerlink" title="1.7.5.3. 置换矩阵"></a>1.7.5.3. 置换矩阵</h4><p>我们使用使用切割和拼接的方式来调换数组的行或者列，但是对于矩阵来说，我们可以根据矩阵的性质，使用置换矩阵来快速交换和行或列。</p><p>置换矩阵（permutation matrix）在矩阵理论中定义为一个方形0/1矩阵，它在每行和每列中只有一个1，而在其他地方则为0。</p><p>我们可使用单位矩阵逆序取得一个常规的置换矩阵，它的斜对角线元素均为 1：</p><pre><code>A = np.eye(3, dtype='uint8')P = A[:, ::-1]  # 行逆序取得置换矩阵print(P)&gt;&gt;&gt;[[0 0 1] [0 1 0] [1 0 0]]</code></pre><p>一个矩阵左点乘一个置换矩阵，交换的是该矩阵的行；一个矩阵右点乘一个置换矩阵，交换的是该矩阵的列。</p><pre><code>A = np.arange(9).reshape(3,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]]# 交换行print(P.dot(A))&gt;&gt;&gt;[[6 7 8] [3 4 5] [0 1 2]]# 交换列print(A.dot(P))&gt;&gt;&gt;[[2 1 0] [5 4 3] [8 7 6]]</code></pre><h4 id="1-7-5-4-置换矩阵扩展"><a href="#1-7-5-4-置换矩阵扩展" class="headerlink" title="1.7.5.4. 置换矩阵扩展"></a>1.7.5.4. 置换矩阵扩展</h4><p>置换矩阵的一般性推广，通过观察可以发现：</p><ul><li>如果置换矩阵 P i 行元素全为0，AP 中的 i 行被清 0，PA 则 i 列被清 0</li><li>如果置换矩阵元素 P[i,j] = 1，P[i,^j] = 0, 如果被左乘则表示用 j 行填充到 i 行上。</li><li>如果被右乘则表示用 j 列填充到 i 列上。</li><li>交行置换矩阵的行或列，等同于交换矩阵的行或列。</li></ul><p>这样就理解了为何单位矩阵乘以任何矩阵和任何矩阵乘以单位矩阵不会改变原矩阵了。</p><h4 id="1-7-5-5-清0行或列"><a href="#1-7-5-5-清0行或列" class="headerlink" title="1.7.5.5. 清0行或列"></a>1.7.5.5. 清0行或列</h4><p>根据置换矩阵的性质，进行扩展，可以实现清0特定行或列</p><pre><code>P = np.eye(3, dtype='uint8')P[1,1] = 0  # 清 0 行或列 1# 等价于 A[1,:] = 0，清 0 行 1print(P.dot(A))&gt;&gt;&gt;[[0 1 2] [0 0 0] [6 7 8]]# 等价于 A[:,1] = 0，清 0 列 1print(A.dot(P))&gt;&gt;&gt;[[0 0 2] [3 0 5] [6 0 8]]</code></pre><p>这种方法没有切片赋值方式简便，只是用来理解置换矩阵的本质。 我们使用切片方式封装为一个函数，用于清零特定的行或列：</p><pre><code>def zerorows(A, rows, val=0):    arr = np.array([rows]).ravel()    A[arr, :] = val    return Adef zerocols(A, cols, val=0):    arr = np.array([cols]).ravel()    A[:, arr] = val    return A# 对行 0,2 清0print(zerorows(A, [0,2]))&gt;&gt;&gt;[[0 0 0] [3 4 5] [0 0 0]]# 对列 0,2 清0print(zerocols(A, [0,2]))&gt;&gt;&gt;[[0 0 0] [0 4 0] [0 0 0]]</code></pre><p>使用以上函数不仅仅可以清零任意行和列，还可以赋任何值。</p><h4 id="1-7-5-6-交换行或列"><a href="#1-7-5-6-交换行或列" class="headerlink" title="1.7.5.6. 交换行或列"></a>1.7.5.6. 交换行或列</h4><p>交换行或列可以使用切片，参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#slice-swap">交换行和列</a>。这里作为理解置换矩阵的方法。由于只要交换置换矩阵的行 a 和 行 b 就可以实现矩阵行列的交换。由于置换矩阵只有斜对角线上的元素为 1，交换等同于把行上的 1 移动位置。</p><pre><code># 交换 a,b 行等同于 P[a,b] = 1 P[b,a] = 1def swaprow(P, rowa, rowb):    P[rowa, rowa] = 0    P[rowb, rowb] = 0    P[rowa, rowb] = 1    P[rowb, rowa] = 1    return PP = swaprow(P, 1, 2) # 交换行 1 和行 2print(P)print(P.dot(A))&gt;&gt;&gt;[[1 0 0] [0 0 1] [0 1 0]][[0 1 2] [6 7 8] [3 4 5]]</code></pre><p>我们可以扩展以上函数，以完成任意行列之间的交换：</p><pre><code># swap=1 swap colsdef swaprowcols(A, vecm, vecn, swap=0):    P = np.eye(A.shape[0], dtype='uint8')    M = np.array([vecm]).ravel()    N = np.array([vecn]).ravel()    if M.shape != N.shape:        print("vecm and vecn must have same dims")        return    # swap permutation matrix    P[M, M] = 0    P[N, N] = 0    P[M, N] = 1    P[N, M] = 1    if swap == 0:        return P.dot(A)    return A.dot(P)A = np.arange(16).reshape(4, 4)print(swaprowcols(A, 0, 2)) # 交换行 0 和 行 2&gt;&gt;&gt;[[ 8  9 10 11] [ 4  5  6  7] [ 0  1  2  3] [12 13 14 15]]# 交换列 0 和 列 2，列 1 和 列 3print(swaprowcols(A, [0,1], [2,3], 1))&gt;&gt;&gt;[[ 2  3  0  1] [ 6  7  4  5] [10 11  8  9] [14 15 12 13]]</code></pre><h3 id="1-7-6-线性代数"><a href="#1-7-6-线性代数" class="headerlink" title="1.7.6. 线性代数"></a>1.7.6. 线性代数</h3><p>线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。</p><p>常用运算有矩阵乘法，分解，变换，行列式等，对任何一个数组库来说都是重要的部分。</p><p>以下函数直接使用 np 引用：</p><blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>diag</td><td>数组和对角线向量互转</td></tr><tr><td>trace</td><td>计算对角线上元素的和</td></tr><tr><td>dot</td><td>行列式乘积</td></tr></tbody></table></blockquote><p>numpy.linalg 有一个关于矩阵分解和像转置和行列式等的一个标准集合。常用 numpy.linglg 函数如下表所示：</p><blockquote><table><thead><tr><th>基本函数</th><th>描述</th></tr></thead><tbody><tr><td>norm</td><td>向量或矩阵的范数</td></tr><tr><td>inv</td><td>方阵逆矩阵</td></tr><tr><td>pinv</td><td>方阵 Moore-Penrose pseudo-inverse 广义逆矩阵</td></tr><tr><td>solve</td><td>求解线性系统方程 Ax = b 的x，其中A是一个方阵</td></tr><tr><td>det</td><td>求行列式</td></tr><tr><td>slogdet</td><td>行列式的符号和自然对数</td></tr><tr><td>lstsq</td><td>计算Ax=b的最小二乘解</td></tr><tr><td>matrix_power</td><td>矩阵乘幂</td></tr><tr><td>matrix_rank</td><td>基于奇异值分解法(SVD)求矩阵的秩</td></tr></tbody></table></blockquote><p>特征值相关函数如下：</p><blockquote><table><thead><tr><th>特征值与分解</th><th>描述</th></tr></thead><tbody><tr><td>eig</td><td>向量或方阵的特征值和特征向量</td></tr><tr><td>eigh</td><td>自共轭矩阵的特征值和特征向量</td></tr><tr><td>eigvals</td><td>Eigenvalues of a square matrix</td></tr><tr><td>eigvalsh</td><td>Eigenvalues of a Hermitian matrix</td></tr><tr><td>qr</td><td>计算 QR 分解</td></tr><tr><td>svd</td><td>计算奇异值分解（SVD）</td></tr><tr><td>cholesky</td><td>Cholesky 矩阵分解</td></tr></tbody></table></blockquote><p>引用以上函数，需要导入 linalg：</p><pre><code>from numpy import linalg as la </code></pre><h4 id="1-7-6-1-矩阵对角线"><a href="#1-7-6-1-矩阵对角线" class="headerlink" title="1.7.6.1. 矩阵对角线"></a>1.7.6.1. 矩阵对角线</h4><p>np.diag 在数组和对角线向量互转，传入参数必须是向量或者矩阵。</p><pre><code>A = np.arange(9).reshape(3,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]]print(np.diag(A)) # 返回对角线向量&gt;&gt;&gt;[0 4 8]# 如果参数为向量，则返回以该向量为对角线的方阵print(np.diag([1,2,3]))&gt;&gt;&gt;[[1 0 0] [0 2 0] [0 0 3]]</code></pre><p>如果不是方阵，也会返回“对角线”向量：</p><pre><code>A = np.arange(8).reshape(2,4)print(A)print(np.diag(A))&gt;&gt;&gt;[[0 1 2 3] [4 5 6 7]][0 5]</code></pre><h4 id="1-7-6-2-对角线元素和"><a href="#1-7-6-2-对角线元素和" class="headerlink" title="1.7.6.2. 对角线元素和"></a>1.7.6.2. 对角线元素和</h4><p>np.trace 返回对角线元素和，等价于 np.sum(np.diag(A)):</p><pre><code>A = np.arange(1,10,1).reshape(3,3)print(A)print(A.trace(), np.sum(np.diag(A)))&gt;&gt;&gt;[[1 2 3] [4 5 6] [7 8 9]]15 15    # 15 = 1+5+9</code></pre><h4 id="1-7-6-3-点积"><a href="#1-7-6-3-点积" class="headerlink" title="1.7.6.3. 点积"></a>1.7.6.3. 点积</h4><p>注意点积(Dot product) 和 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#outer-product">外积</a> 的区别。</p><pre><code>dot(a, b, out=None)</code></pre><p>np.dot 实现向量点积或矩阵乘积，如果 b 为标量则等同为 a * b，返回标量值：</p><ul><li>点积：用于向量相乘，表示为C = A.*B，A 与 B均为向量，C 为标量，也称标量积（scalar  product）、内积、数量积等。两个向量a = [a1, a2,…, an]和b = [b1, b2,…, bn]的点积定义为:a.*b =  a1b1 + a2b2 + … + anbn。</li><li>乘积： 用于矩阵相乘，表示为C=A*B，A的列数与B的行数必须相同，C 也是矩阵，C 的行数等于 A 的行数，C 的列数等于 B 的列数。Cij 为 A 的第 i 行与 B 的第 j 列的点积。</li></ul><p>向量点积：</p><pre><code>print(np.dot(np.array([1,2]), np.array([3,4])))&gt;&gt;&gt;11 # 1*3 + 2*4</code></pre><p>标量乘标量，向量乘标量，以及矩阵乘标量，均等于各个元素与标量相乘：</p><pre><code># 等同 2 * 2print(np.dot(2, 2))&gt;&gt;&gt;4# 等同 [1 2] * 2print(np.dot(np.array([1,2]), 2))&gt;&gt;&gt;[2 4]A = np.arange(4).reshape(2,2)print(A)&gt;&gt;&gt;[[0 1] [2 3]]print(A.dot(2))&gt;&gt;&gt;[[0 2] [4 6]]</code></pre><p>矩阵乘积，注意 np.dot 和 * （星乘）的区别：</p><pre><code>print(A.dot([1,2]))&gt;&gt;&gt;[2 8]</code></pre><p>还有一个 np.inner 函数在向量乘的时候与 np.dot 行为一致，但是在矩阵乘时行为不一致，通常应该使用 np.dot。</p><h4 id="1-7-6-4-矩阵乘向量"><a href="#1-7-6-4-矩阵乘向量" class="headerlink" title="1.7.6.4. 矩阵乘向量"></a>1.7.6.4. 矩阵乘向量</h4><p>由于向量是 1 维的，所以它转置之后还是自身。通常我们使用矩阵和向量相乘，均是指列向量，而 np.dot 把一维向量自动作为行向量，并且结果还是行向量。</p><pre><code>A = np.arange(4).reshape(2,2)print(A)&gt;&gt;&gt;[[0 1] [2 3]]# 矩阵点乘行向量V = np.array([1,2]) # V 为 [1 2]，shape 为 (2,)print(A.dot(V))&gt;&gt;&gt;[2 8]</code></pre><p>np.dot 乘以列向量，实际上执行的是矩阵点乘，列向量是 shape 为 (n, 1) 的二维矩阵，结果还是shape 为 (n, 1) 的二维矩阵（列向量）。</p><pre><code># 矩阵点乘列向量V = B.reshape(2,1)print(A.dot(V))&gt;&gt;&gt;[[2] [8]] </code></pre><p>所以 np.dot 可以根据向量类型自动计算矩阵和向量的点积，并生成对应的向量。</p><h4 id="1-7-6-5-叉乘"><a href="#1-7-6-5-叉乘" class="headerlink" title="1.7.6.5. 叉乘"></a>1.7.6.5. 叉乘</h4><p>向量积，数学中又称叉积，物理中称矢积、叉乘，是一种在向量空间中向量的二元运算。与点积不同，它的运算结果是一个向量而不是一个标量。并且两个向量的叉积与这两个向量和垂直。</p><p>向量积 ≠ 向量的积（向量的积一般指点乘）。</p><pre><code>print(np.cross([1,0,0], [0,1,0]))&gt;&gt;&gt;[0 0 1]</code></pre><p>在物理学光学和计算机图形学中，叉积被用于求物体光照相关问题。</p><h4 id="1-7-6-6-逆矩阵和多项式求解"><a href="#1-7-6-6-逆矩阵和多项式求解" class="headerlink" title="1.7.6.6. 逆矩阵和多项式求解"></a>1.7.6.6. 逆矩阵和多项式求解</h4><p>$$np.dot(A,A^{-1} = 1)$$单位矩阵，则称 $A^{-1}$为 A的逆矩阵，A 必须为方阵。如果 A 没有逆矩阵，则称 A 为奇异矩阵 (Sigular matrix)。</p><pre><code>from numpy import linalg as laA = np.array([[1, 1], [2, 3]])print(la.inv(A))&gt;&gt;&gt;[[ 3. -1.] [-2.  1.]]# A 的逆矩阵点乘 A 等于单位矩阵print(la.inv(A).dot(A))&gt;&gt;&gt;[[ 1.  0.] [ 0.  1.]]</code></pre><p>逆矩阵类似一个矩阵的倒数，$AB = C$，已知 A 和 C 求 B，则左侧同时乘以 $A^{−1}$，则 $B=A^{−1}C$。最简单的应用是用来求线性方程组的解：</p><pre><code># 求如下多项的解x + y = 102x + 3y = 25A = np.array([[1, 1], [2, 3]])C = np.array([10, 25])print(np.dot(la.inv(A), C))&gt;&gt;&gt;[ 5.  5.]</code></pre><p>实际上 linglg 中提供了 solve 函数用于求解线性方程组的解，以上解法等价于：</p><pre><code>print(la.solve(A, C))&gt;&gt;&gt;[ 5.  5.]</code></pre><p>实际上很少使用逆矩阵求解线性返程组，因为它的计算量大约使用行变换方法的3倍，而且行变换方法更为精确。</p><h4 id="1-7-6-7-伪逆-pinv"><a href="#1-7-6-7-伪逆-pinv" class="headerlink" title="1.7.6.7. 伪逆 pinv"></a>1.7.6.7. 伪逆 pinv</h4><p>la.pinv （pseudo-inverse）和 la.inv 不同，pinv是求广义逆，也即伪逆。</p><p>对于方阵A，若有方阵B，使得：AB = BA = I，则称B为A的逆矩阵。</p><p>如果矩阵 A 不是一个方阵，或者 A 是一个非满秩的方阵时（奇异矩阵），矩阵 A 没有逆矩阵，但可以找到一个与 A 的转置矩阵同型的矩阵 B，使得： ABA = A 并且 BAB = B，此时称矩阵 B 为矩阵 A 的伪逆，即广义逆矩阵。因此伪逆阵与原阵相乘不一定是单位阵。</p><p>满足上面关系的 A, B 矩阵，有很多和逆矩阵相似的性质。</p><p>当 A 可逆时，B 就是 A 的逆矩阵，pinv 结果和 inv 的结果相同，否则 pinv 返回伪逆。和 inv 相比，pinv 会消耗大量的计算时间。</p><h4 id="1-7-6-8-行列式"><a href="#1-7-6-8-行列式" class="headerlink" title="1.7.6.8. 行列式"></a>1.7.6.8. 行列式</h4><p>二阶的行列式计算方式如下，行列式 det 如果为0，说明矩阵是奇异矩阵，不可逆：</p><pre><code>[[a b] [c d]] = a*d - b*c</code></pre><p>linalg 中的 det 函数用于计算行列式：</p><pre><code>from numpy import linalg as laA = np.arange(4).reshape(2,2)print(A)print(la.det(A))&gt;&gt;&gt;[[0 1] [2 3]]-2.0   # 0*3 - 1*2</code></pre><p>slogdet 用于求行列式的符号和以自然数 e 为底的对数：</p><p># 等价于 print(np.log(np.abs(la.det(A)))) print(la.slogdet(A))</p><pre><code>&gt;&gt;&gt;(-1.0, 0.69314718055994529)</code></pre><h4 id="1-7-6-9-QR-因式分解"><a href="#1-7-6-9-QR-因式分解" class="headerlink" title="1.7.6.9. QR 因式分解"></a>1.7.6.9. QR 因式分解</h4><p>QR 分解是将矩阵分解为一个正交矩阵与上三角矩阵的乘积。A = Q.dot(R)，如果 A.shape(m,n)，则 Q.shape(m,n)，R.shape(n,n)。</p><p>Q 的各列由 A 的一组标准正交基构成，并且 Q 的转置点乘 Q 等于单位矩阵。R 则是上三角矩阵。</p><pre><code>from numpy import linalg as laA = np.arange(6).reshape(2,3)print(A)&gt;&gt;&gt;[[0 1 2] [3 4 5]]Q,R = la.qr(A)print(Q)print(R)&gt;&gt;&gt;[[ 0. -1.] [-1.  0.]][[-3. -4. -5.] [ 0. -1. -2.]]# 使用 A = Q.dot(R) 验证print(Q.dot(R))&gt;&gt;&gt;[[ 0.  1.  2.] [ 3.  4.  5.]]</code></pre><p>验证 Q 的转置点乘 Q 等于单位矩阵：</p><pre><code>print(Q.T.dot(Q))&gt;&gt;&gt;[[ 1.  0.] [ 0.  1.]]</code></pre><h4 id="1-7-6-10-QR-求最小二乘解"><a href="#1-7-6-10-QR-求最小二乘解" class="headerlink" title="1.7.6.10. QR 求最小二乘解"></a>1.7.6.10. QR 求最小二乘解</h4><p>QR 分解常用于求取 Ax = b 的最小二乘解（结果差值的平方和的开方根最小），求取公式为 x = inv(R) * (Q.T) * b：</p><pre><code># 求解 Ax = b 的最小二乘解 x = [[Xa],[Xb]]A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])b = np.array([[1], [0], [2], [1]])Q, R = la.qr(A)lst = la.inv(R).dot(Q.T.dot(b))print(lst)&gt;&gt;&gt;[[  2.22044605e-16] # Xa = 0 Xb = 1 是最小二乘解 [  1.00000000e+00]]print(la.norm(A.dot(lst) - b)) # 最小二乘解的误差值&gt;&gt;&gt;1.41421356237</code></pre><p>以上过程等同于求解以下线性方程组的最小二乘解：</p><pre><code>0Xa + 1Xb = 1 1Xa + 1Xb = 0 1Xa + 1Xb = 2 2Xa + 1Xb = 1 </code></pre><p>也可以理解为对 A 中的列向量如何进行 X1 和 X2 的权重组合来最接近向量 b。矩阵理论证明 b 距离 X1 和 X2  构成的空间的最短距离是向该空间的正交投影点，所以 X1 和 X2 组合成的向量如果构成 b 的正交投影向量，那么 X1 和 X2  就是最小二乘解。</p><h4 id="1-7-6-11-最小二乘法拟合"><a href="#1-7-6-11-最小二乘法拟合" class="headerlink" title="1.7.6.11. 最小二乘法拟合"></a>1.7.6.11. 最小二乘法拟合</h4><p>lstsq （LeaST SQuare 的缩写）函数用最小二乘法拟合数据，得到一个形如 y = mx + c 的线性函数，也即目标是求出参数 m 和 c。</p><p>求得的结果 m 和 c 满足所有点距直线的距离的平方和的平方根最小。</p><pre><code># 以 y = m*x + c 直线为例x = np.array([0, 1, 2, 3, 4])y = np.array([-1, 0.2, 0.9, 2.1, 3])# 增加对应常数项 c 的列A = np.vstack([x, np.ones(x.shape[0])]).Tm, c = np.linalg.lstsq(A, y)[0]</code></pre><p>为了查看效果，我们把 x,y 构成的点，和返回的拟合直线画出来：</p><pre><code>plt.rcParams['font.sans-serif']=['SimHei']plt.rcParams['axes.unicode_minus'] = Falseplt.title('最小二乘解', fontsize=20)plt.plot(x, y, 'o', label='原数据', markersize=8)plt.plot(x, m*x + c, 'r', label='拟合直线')plt.legend(fontsize=16)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/lstsq.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/lstsq.png" alt="lstsq"></a></p><p>最小二乘解示例</p><p>在一些应用中，必须将数据点拟合为非直线形式，例如 y = ax^2 + bx + c：</p><pre><code># 以 y = 2x^2 + 10x + 2 曲线为例x = np.array([1,2,3,4,5,6,7,8])#y = 2*x*x + 10*x + 2 # 如果使用此 y 值，则会精确拟合到指定的参数，可用于测试y = np.array([13,28,49,75,102,134,170,215]) # 观测值# 增加对应常数项 c 的列A = np.vstack([x**2, x, np.ones(x.shape[0])]).Ta, b, c = np.linalg.lstsq(A, y)[0]print(a, b, c)&gt;&gt;&gt;2.14285714286 9.35714285714 1.5</code></pre><p>画图方式相同，只要改变拟合曲线的 y 坐标生成方式为 a * x**2 + b * x + c：</p><pre><code>plt.title('最小二乘解', fontsize=20)plt.plot(x, y, 'o', label='原数据', markersize=8)plt.plot(x, a * x**2 + b * x + c, 'r', label='拟合曲线')plt.legend(fontsize=16)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/lstsq0.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/lstsq0.png" alt="lstsq"></a></p><p>最小二乘解曲线示例</p><h4 id="1-7-6-12-傅里叶逼近"><a href="#1-7-6-12-傅里叶逼近" class="headerlink" title="1.7.6.12. 傅里叶逼近"></a>1.7.6.12. 傅里叶逼近</h4><p>傅里叶逼近是曲线逼近的一种，当使用傅里叶逼近的函数阶数越高，均方误差可以趋近于 0。</p><p>傅里叶级数形式：f(t) = A0/2 + sum(Am<em>cos(mt) + Bm</em>sin(mt)) m 取 1 到无穷，这里以 2 阶傅里叶级数拟合曲线：</p><pre><code># 2 阶傅里叶逼近x = np.array(np.linspace(0, np.pi * 2, 40))# 直接使用函数值并对其中的项微调，作为观察值进行测试y = 3.0 - 2.0*np.sin(x) + 5.0*np.sin(2.0*x) - 5.0*np.cos(2.0*x)y[0] = -1  # 微调第一项的值# 生成 A 矩阵A = np.vstack([np.ones(x.shape[0]), np.sin(x), np.sin(2.0*x), np.cos(2.0*x)]).Ta, b, c, d = np.linalg.lstsq(A, y)[0]print(a, b, c, d)&gt;&gt;&gt;3.02380952381 -2.0 5.0 -4.95238095238plt.title('最小二乘解', fontsize=20)plt.plot(x, y, 'o', label='原数据', markersize=8)plt.plot(x, a + b*np.sin(x) + c*np.sin(2.0*x) + d*np.cos(2.0*x), 'r', label='拟合曲线')plt.legend(fontsize=16)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/lstsq1.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/lstsq1.png" alt="lstsq"></a></p><p>最小二乘解傅里叶级数拟合曲线</p><h4 id="1-7-6-13-范数"><a href="#1-7-6-13-范数" class="headerlink" title="1.7.6.13. 范数"></a>1.7.6.13. 范数</h4><p>范数（Norm）是对向量或矩阵大小的度量。通常有 0,1,2 和无穷范数。la.norm 中的 ord 参数可以指定要求的范数的类型：</p><blockquote><table><thead><tr><th>ord</th><th>矩阵的范数类型</th><th>向量的范数类型</th></tr></thead><tbody><tr><td>None</td><td>Frobenius norm</td><td>2-norm 向量长度</td></tr><tr><td>‘fro’</td><td>Frobenius norm</td><td>–</td></tr><tr><td>‘nuc’</td><td>nuclear norm</td><td>–</td></tr><tr><td>inf</td><td>max(sum(abs(x), axis=1))</td><td>max(abs(x))</td></tr><tr><td>-inf</td><td>min(sum(abs(x), axis=1))</td><td>min(abs(x))</td></tr><tr><td>0</td><td></td><td>sum(x != 0)</td></tr><tr><td>1</td><td>max(sum(abs(x), axis=0))</td><td>as below</td></tr><tr><td>-1</td><td>min(sum(abs(x), axis=0))</td><td>as below</td></tr><tr><td>2</td><td>2-norm (largest sing. value)</td><td>as below</td></tr><tr><td>-2</td><td>smallest singular value</td><td>as below</td></tr><tr><td>other</td><td>–</td><td>sum(abs(x)<strong>ord)</strong>(1./ord)</td></tr></tbody></table></blockquote><p>以上范数解释如下：</p><ul><li>0 范数，向量中非零元素的个数，sum(x != 0)。</li><li>1 范数，各个元素的绝对值之和。</li><li>2 范数，Frobenius norm 称为弗罗贝尼乌斯，也即矩阵或者向量各个元素的平方和的开方，对于向量来说就是 2 范数，也即向量的长度（模）。</li><li>正无穷范数，就是取向量的各元素绝对值的最大值。</li><li>负无穷范数，就是取向量的各元素绝对值的最小值。</li></ul><p>一个向量各类范数的示例：</p><pre><code>from numpy import linalg as laA = np.array([0,3,4,-1])print("Norm0:", la.norm(A, 0))  # 非0元素个数print("Norm1:", la.norm(A, 1))  # 各元素绝对值之和print("Norm2:", la.norm(A, 2))  # 欧氏距离print("NormInf:", la.norm(A, np.inf))  # 绝对值的最大值print("Norm-Inf:", la.norm(A, -np.inf))# 绝对值的最小值&gt;&gt;&gt;Norm0: 3.0Norm1: 8.0Norm2: 5.09901951359NormInf: 4.0Norm-Inf: 0.0</code></pre><h4 id="1-7-6-14-向量距离和角度"><a href="#1-7-6-14-向量距离和角度" class="headerlink" title="1.7.6.14. 向量距离和角度"></a>1.7.6.14. 向量距离和角度</h4><p>由于 u.dot(v) = |u||u|cosa， 可以借助 2 范数求两个向量的夹角 a：</p><pre><code>def vector_angle(V0, V1):    V0 = np.array(V0)    V1 = np.array(V1)    cos_rad = V0.dot(V1) / (la.norm(V0, 2)*la.norm(V1, 2))    return np.rad2deg(np.arccos(cos_rad))print(vector_angle([0,1], [1,0]))&gt;&gt;&gt;90.0</code></pre><p>cosa 在统计学中也被称为 u 和 v 的相关系数，它越大说明夹角越小，相关性越大。</p><p>范数也可以用来计算两个向量间的距离，即两个向量相减得到的新向量的 2 范数：</p><pre><code>def vector_dist(V0, V1):    V0 = np.array(V0)    V1 = np.array(V1)    return la.norm(V1 - V0)print(vector_dist([0,1],[0,3]))&gt;&gt;&gt;2.0</code></pre><h4 id="1-7-6-15-向量正交投影"><a href="#1-7-6-15-向量正交投影" class="headerlink" title="1.7.6.15. 向量正交投影"></a>1.7.6.15. 向量正交投影</h4><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/proj.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/proj.png" alt="proj"></a></p><p>二维向量正交投影</p><p>图中的 Vproj 为 Vy 在 Vu 上的投影，点 Vproj 是 Vy 到 Vu 所在直线上的最短距离点，经过 Vy 和 Vproj 点的直线 L 垂直于 Vu。</p><p>如果把 L 看做一个向量，那么 Vy = Vproj + L。由于 L 垂直于 Vu，这是两个正交向量。所以 (Vy - Vproj)Vu = 0，其中 Vproj = cVu，c 为以常数，从而得出 c = (VyVu)/VuVu。</p><pre><code>from numpy import linalg as la# 计算Vy 在 Vu 上的正交投影，返回的是投影向量def vector_proj(Vu, Vy):    Vu = np.array(Vu)    Vy = np.array(Vy)    # Vproj = cVu，系数 c = (VyVu)/VuVu    c = Vy.dot(Vu)/Vu.dot(Vu)    return c * Vu# 返回最短距离def vector_proj_dist(Vu, Vy):    Vproj = vector_proj(Vu, Vy)    return la.norm(Vproj - Vy)Vu = np.array([4,2])Vy = np.array([7,6])Vproj = vector_proj(Vu, Vy)print(Vproj)print(vector_proj_dist(Vu, Vy))&gt;&gt;&gt;[ 8.  4.]2.2360679775</code></pre><p>向量投影可以推广到多维空间。对于 n 维向量来说这意味着 Vy 可以被投影到 n 维的各个正交基上，同时 Vy 等于各个正交基上投影的和。对于 Rn 空间的子空间，Vy 到子空间的投影点就是 Vy 到子空间的最短距离。</p><p>使用向量投影原理，可以找到垂直于某个向量的向量，例如 L 和 Vu，所以可以将一个空间中不相关的基转换为正交基，格拉姆施密特方法基于向量投影原理来进行矩阵的 QR 分解。</p><p>著名的最小二乘法也是基于向量投影原理实现的。</p><h2 id="1-8-广播和迭代"><a href="#1-8-广播和迭代" class="headerlink" title="1.8. 广播和迭代"></a>1.8. 广播和迭代</h2><h3 id="1-8-1-数据间运算"><a href="#1-8-1-数据间运算" class="headerlink" title="1.8.1. 数据间运算"></a>1.8.1. 数据间运算</h3><h4 id="1-8-1-1-相同形状数组"><a href="#1-8-1-1-相同形状数组" class="headerlink" title="1.8.1.1. 相同形状数组"></a>1.8.1.1. 相同形状数组</h4><p>相同形状的数组间运算，作用在对应的元素之间，例如：</p><pre><code>A = np.array([1, 1, 1])B = np.array([2, 2, 2])print(A + B)print(A - B)print(A * B)print(A / B)print(A % B)print(A // B)&gt;&gt;&gt;[3 3 3][-1 -1 -1][2 2 2][ 0.5  0.5  0.5][1 1 1][0 0 0]</code></pre><h4 id="1-8-1-2-广播可视化"><a href="#1-8-1-2-广播可视化" class="headerlink" title="1.8.1.2. 广播可视化"></a>1.8.1.2. 广播可视化</h4><p>参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#array-scalar">算术运算</a>，数组和标量之间的运算，相当于把标量扩展为相同形状的数组，然后再进行运算。</p><pre><code>&gt;&gt;&gt;A = np.array([1, 1, 1])print(A + 5) # 等价于 print(A + [5,5,5])&gt;&gt;&gt;[6 6 6]</code></pre><p>NumPy 这种对数据扩展以适应操作的行为被称为广播。实际上这种对数组的重复实际上并没有发生，但是这是一种很好用的理解广播的模型。</p><p><a href="http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html">Broadcast Visualization</a> 中提供了一张理解广播扩展的图片。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/fig_broadcast_visual_1.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/fig_broadcast_visual_1.png" alt="fig_broadcast_visual"></a></p><p>广播扩展可视化</p><h3 id="1-8-2-广播规则"><a href="#1-8-2-广播规则" class="headerlink" title="1.8.2. 广播规则"></a>1.8.2. 广播规则</h3><p>NumPy 的广播遵循一组严格的规则，设定这组规则是为了决定两个数组间的操作，从规则1到规则3依次尝试：</p><ol><li>规则1，如果两个数组的维度（ndim，轴数）不相同，那么小轴数的数组形状在最左边补 1 以使得维度（轴数）相同。</li><li>规则2，如果两个数组的形状在各轴的维数（元素数）不匹配， 那么数组的形状会沿着元素个数为 1 的轴扩展以匹配另外一个数组的形状。</li><li>规则3，扩展后两个数组的形状不匹配并且任何一个数组都不再有维度为 1 的轴， 报错处理，否则继续规则 2。</li></ol><p>来看两个数组均需要广播的示例：</p><pre><code>A = np.arange(3).reshape((3, 1))B = np.arange(3)print(A)print(B)print(A.ndim, A.shape)print(B.ndim, B.shape)&gt;&gt;&gt;[[0] [1] [2]][0 1 2]2 (3, 1)1 (3,)</code></pre><p>由于两个数组的轴数 2 != 1，按照规则1 对小数组 B 在最左边补 1，也即 B.shape 变为 (1,3)。</p><p>此时按照规则2，发现 A.shape = (3,1) 与 B.shape = (1,3)  在各轴的元素数目不同，需要更新这两个数组的各轴的维度来相互匹配，也即 A 在维度为 1 的轴上扩展为 A.shape  = (3,3)，B  在元素数为 1 的轴上扩展，B.shape 变为 (3,3)。</p><p>扩展以后 A 和 B 的 shape 是相等的，此时完成对应元素的相应操作。</p><pre><code>print(A + B)&gt;&gt;&gt;[[0 1 2] [1 2 3] [2 3 4]]</code></pre><p>这里再看一个两个数组不能进行广播扩展的例子。</p><pre><code>A = np.arange(4).reshape((2, 2))B = np.arange(3)print(A, A.shape)print(B, B.shape)print(A + B)&gt;&gt;&gt;[[0 1] [2 3]] (2, 2)[0 1 2] (3,)ValueError: operands could not be broadcast together with shapes (2,2) (3,)</code></pre><p>B 的维度小于 A，把 B.shape 扩展为 (1, 3)，然后按照 A 的第0轴扩展为 (2, 3)，此时两个数组没有维数为 1 的轴，但是形状不同，无法进行扩展操作。</p><p>这些广播规则对于任意二元通用函数都是适用的。 例如 power(a, b) 函数。</p><h4 id="1-8-2-1-广播实现"><a href="#1-8-2-1-广播实现" class="headerlink" title="1.8.2.1. 广播实现"></a>1.8.2.1. 广播实现</h4><p>np.broadcast_to 函数提供广播实现，我们可以使用它观察数组广播的行为，只需提供 shape 参数即可：</p><pre><code>a = np.array([1, 2, 3])print(np.broadcast_to(a, (3, 3)))&gt;&gt;&gt;[[1 2 3] [1 2 3] [1 2 3]]</code></pre><p>此外 np.broadcast_arrays 可以直接对多个数组进行广播扩展：</p><pre><code>x = np.array([[1,2,3]])y = np.array([[4],[5]])a, b = np.broadcast_arrays(x, y)print(a)print(b)&gt;&gt;&gt;[[1 2 3] [1 2 3]][[4 4 4] [5 5 5]]</code></pre><p>当参数不止 2 个时，可以使用列表扩展来返回多个数组，这样更方便：</p><pre><code>[np.array(a) for a in np.broadcast_arrays(x, y)] </code></pre><h3 id="1-8-3-广播应用"><a href="#1-8-3-广播应用" class="headerlink" title="1.8.3. 广播应用"></a>1.8.3. 广播应用</h3><h4 id="1-8-3-1-数据中心化"><a href="#1-8-3-1-数据中心化" class="headerlink" title="1.8.3.1. 数据中心化"></a>1.8.3.1. 数据中心化</h4><p>中心化也成为零均值化（Zero-centered 或 Mean-subtraction），所有数据减去均值，中心化后的数据均值为零。中心化在坐标轴上看起来是把数据移动到了原点附近。</p><p>我们的样本空间有 4 个样本，每个样本有 5 个特征值，我们对每个特征值进行中心化：</p><pre><code>A = np.random.randint(0,10,20).reshape(4,5)print(A, A.mean(0))&gt;&gt;&gt;[[3 5 2 4 7] [6 8 8 1 6] [7 7 8 1 5] [9 8 9 4 3]] [ 6.25  7.    6.75  2.5   5.25]</code></pre><p>对特征值（每列）中心化的过程就是减去 0 轴上的均值：</p><pre><code>A_centered = A - A.mean(0) print(A_centered, A_centered.mean()) # 中心化后数据均值为 0 [[-3.25 -2.   -4.75  1.5   1.75] [-0.25  1.    1.25 -1.5   0.75] [ 0.75  0.    1.25 -1.5  -0.25] [ 2.75  1.    2.25  1.5  -2.25]] 0.0 </code></pre><p>这里以第一个特征为例（第一列），通过 matplob 画图，可以看出数据（Y方向）中心化后向原点聚集。</p><pre><code>import matplotlib.pyplot as pltimport matplotlib as mplprint(A[:, 0:1])plt.figure(figsize=(6,4))X = np.arange(A.shape[0])plt.xlim(-4, 5)plt.rcParams['font.sans-serif']=['SimHei']plt.rcParams['axes.unicode_minus'] = Falseplt.scatter(X, A[:, 0:1], label='原数据')plt.scatter(X, A_centered[:, 0:1], label='中心化数据')plt.scatter(0,0, s=500, c='r', marker='+')plt.legend(loc='upper left', fontsize='large')</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/centered.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/centered.png" alt="centered"></a></p><p>数据中心化</p><h4 id="1-8-3-2-数据标准化"><a href="#1-8-3-2-数据标准化" class="headerlink" title="1.8.3.2. 数据标准化"></a>1.8.3.2. 数据标准化</h4><p>标准化（Standardization）处理又称为正态化，是指数值减去均值（中心化）后，再除以标准差。标准化处理后，得到均值为0，标准差为1的服从标准正态分布的数据。</p><p>在一些实际问题中，我们得到的样本数据都是多个维度的，即一个样本是用多个特征来表征的。很显然，这些特征的量纲和数值得量级都是不一样的，而通过标准化处理，可以使得不同的特征具有相同的尺度（Scale）。这样，在学习参数的时候，不同特征对参数的影响程度就一样了。简言之，当原始数据不同维度上的特征的尺度（单位）不一致时，需要标准化步骤对数据进行预处理。</p><pre><code>A_standard = A_centered / A.std(0)print(A_standard)print("A_standard mean:", A_standard.mean())print("A_standard std:", A_standard.std())&gt;&gt;&gt;[[-1.5011107  -1.63299316 -1.71317231  1.          1.18321596] [-0.11547005  0.81649658  0.45083482 -1.          0.50709255] [ 0.34641016  0.          0.45083482 -1.         -0.16903085] [ 1.27017059  0.81649658  0.81150267  1.         -1.52127766]]A_standard mean: -2.22044604925e-17A_standard std: 1.0</code></pre><p>通过 matplob 画图，可以看出数据（Y方向）标准化后向原点继续被压缩靠拢。</p><pre><code>plt.figure(figsize=(6,4))X = np.arange(A.shape[0])plt.xlim(-4, 5)plt.rcParams['font.sans-serif']=['SimHei']plt.rcParams['axes.unicode_minus'] = False  # 解决保存图像是负号'-'显示为方块的问题plt.scatter(X, A[:, 0:1], label='原数据')plt.scatter(X, A_centered[:, 0:1], label='中心化数据')plt.scatter(X, A_standard[:, 0:1], label='标准化数据', c='m')plt.scatter(0,0, s=500, c='r', marker='+')plt.legend(loc='upper left', fontsize='large')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/standard.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/standard.png" alt="standard"></a></p><p>数据标准化</p><h4 id="1-8-3-3-数据归一化"><a href="#1-8-3-3-数据归一化" class="headerlink" title="1.8.3.3. 数据归一化"></a>1.8.3.3. 数据归一化</h4><p>数据归一化（Normalization）是一种数据预处理方法，就是把待处理数据经某种算法限制在需要的一定范围内，为了后面数据处理的方便，其次是保正程序运行时收敛加快，一般指将数据限制在[0,1]之间。</p><p>比如说，对于奇异样本数据(奇异样本数据数据是相对于其他输入样本特别大或特别小的样本矢量)，该数据引起的网络训练时间增加，并可能引起网络无法收敛，所以对于训练样本存在奇异样本数据的数据集在训练之前，最好先进形归一化，若不存在奇异样本数据，则不需要事先归一化。</p><p>数据归一化另一个作用是将一个有量纲的表达式转化为无量纲的表达式，成为一个纯量，避免具有不同物理意义和量纲的输入变量不能平等使用。而且在统计学中，数据归一化的具体作用是归纳统一样本的统计分布性。归一化在 0-1 之间是统计的概率分布，归一化在[-1, 1]之间是统计的坐标分布。</p><p>数据归一化的方法有:</p><ul><li>若是区间上的值，则可以用区间上的相对位置来归一化，即选中一个相位参考点，用相对位置和整个区间的比值或是整个区间的给定值作比值，得到一个归一化的数据，比如概率值范围[0,1]。</li><li>若是物理量，则一般可以统一度量衡之后归一，实在没有统一的方法，则给出一个自定义的概念来描述亦可。</li><li>若是数值，则可以用很多常见的数学函数进行归一化，使它们之间的可比性更显然，比如对数归一，指数归一，三角或反三角函数归一等，归一的目的可能是使得没有可比性的数据变得具有可比性，同时还会保持相比较的两个数据之间的相对关系，如大小关系，或是为了作图，原来很难在一张图上作出来，归一化后就可以很方便的给出图上的相对位置等，通用的有线性函数转换(最大最小值转换法)、对数函数转换和反余切函数转换等。</li></ul><ol><li>线性函数转换(最大最小值转换法)</li></ol><pre><code>y = (x-min)/(max-min) </code></pre><p>x、y 分别表示输入、输出值，max、min表示样本中的最大、最小值。</p><ol><li>对数函数转换</li></ol><pre><code>y = log(x) or log2(x) or log10(x) </code></pre><p>x、y 分别表示输入、输出值，y 为 x 的以 e，2 或 10 为底的对数函数转换值。</p><ol><li>反余切函数转换</li></ol><pre><code>y = atan(x)*2/pi </code></pre><p>此外，从集合的角度来看，有些数据或者对象不具备可比性，但是可以通过做维度的维一，即抽象化归一，把不重要的，不具可比性的集合中的元素的属性去掉，保留人们关心的那些属性，这样，本来不具有可比性的对象或是事物，就可以实现归一，即归为一类，然后就可以比较了。并且，人们往往喜欢用相对量来比较，比如人和牛，身高体重都没有可比性，但“身高/体重”的值，就可能有了可比性，这些，从数学角度来看，可以认为是把有纲量变成了无纲量了。</p><p>这里使用线性函数进行归一化：</p><pre><code>A_normal = (A - A.min(0)) / (A.max(0) - A.min(0))print(A_normal)[[ 0.          0.          0.          1.          1.        ] [ 0.5         1.          0.85714286  0.          0.75      ] [ 0.66666667  0.66666667  0.85714286  0.          0.5       ] [ 1.          1.          1.          1.          0.        ]]</code></pre><p>显然归一化后的数据均落在 [0-1] 之间，使用 matplotlib 作图：</p><pre><code>plt.figure(figsize=(6,4))X = np.arange(A.shape[0])plt.xlim(-4, 5)plt.rcParams['font.sans-serif']=['SimHei']plt.rcParams['axes.unicode_minus'] = False  # 解决保存图像是负号'-'显示为方块的问题plt.scatter(X, A[:, 0:1], label='原数据')plt.scatter(X, A_centered[:, 0:1], label='中心化数据')plt.scatter(X, A_standard[:, 0:1], label='标准化数据', c='m')plt.scatter(X, A_normal[:, 0:1], label='归一化数据', c='r')plt.scatter(0,0, s=500, c='r', marker='+')plt.plot([-4,5], [0,0], c='gray', linewidth=1)plt.plot([-4,5], [1,1], c='gray', linewidth=1)plt.legend(loc='upper left', fontsize='large')plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/normal.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/normal.png" alt="Normalization"></a></p><p>数据归一化</p><h4 id="1-8-3-4-二维函数作图"><a href="#1-8-3-4-二维函数作图" class="headerlink" title="1.8.3.4. 二维函数作图"></a>1.8.3.4. 二维函数作图</h4><p>广播另外一个非常有用的地方在于， 它能基于二维函数显示图像。</p><p>我们希望定义一个函数 z = f(x, y)， 可以用广播沿着数值区间计算该函数：</p><pre><code>X = np.linspace(0, np.pi * 4, 250)Y = np.linspace(0, np.pi * 4, 250)[:, np.newaxis]Z = np.sin(X) + np.cos(Y)fig = plt.figure()ax = plt.axes(projection='3d')ax.set_title('sin(X) + cos(Y)')ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis')ax.set_xlabel('x')ax.set_ylabel('y')ax.set_zlabel('z')ax.view_init(30, -60)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/funcmap.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/funcmap.png" alt="funcmap"></a></p><p>二维函数图</p><h3 id="1-8-4-数组迭代"><a href="#1-8-4-数组迭代" class="headerlink" title="1.8.4. 数组迭代"></a>1.8.4. 数组迭代</h3><p>如果我们要一次取元素，并对元素进行特殊的处理，就会用到数组迭代。</p><p>首先我们看下默认 Python 的 for 循环，如何返回数组元素：</p><pre><code>AA = np.arange(4).reshape((2, 2))print(A)for i in A:    print('-&gt;', i)&gt;&gt;&gt;[[0 1] [2 3]]-&gt; [0 1]-&gt; [2 3]</code></pre><p>可以看到默认的 for 循环，始终从第一维取元素，也即逐行取。</p><p>我们可以使用 ndarry 的 data 属性来遍历一维数组：</p><pre><code>A = np.arange(4)for i in A.data:    # A的视图，仅支持1维    print(i, end=' ')&gt;&gt;&gt;0 1 2 3</code></pre><h4 id="1-8-4-1-flat"><a href="#1-8-4-1-flat" class="headerlink" title="1.8.4.1. flat"></a>1.8.4.1. flat</h4><p>参考 <a href="https://mlhowto.readthedocs.io/en/latest/numpy.html#flatten">数组展平</a>，np.flatten 将数组转换为一维数组，而 np.flat 将数组转换为 1-D的迭代器。可以用for访问迭代器中每一个元素。</p><pre><code>A = np.arange(4).reshape((2, 2))print(A)&gt;&gt;&gt;[[0 1] [2 3]]A_flat = A.flatprint(type(A_flat).__name__)for i in A_flat:    print('-&gt;', i)flatiter-&gt; 0       # 逐个返回元素-&gt; 1-&gt; 2-&gt; 3</code></pre><p>可以看出 flat 迭代器按照索引大小顺序来生成返回的元素。</p><h4 id="1-8-4-2-广播迭代"><a href="#1-8-4-2-广播迭代" class="headerlink" title="1.8.4.2. 广播迭代"></a>1.8.4.2. 广播迭代</h4><p>np.nditer 可以同时对多个数组进行迭代，如果数组形状不匹配，则使用广播规则进行扩展。</p><pre><code>A = np.arange(4).reshape(2, 2)B = np.array([1, 2])&gt;&gt;&gt;[[0 1] [2 3]][1 2]# 数组 B 广播扩展到 A 的大小print(A)print(B)for x,y in np.nditer([A, B]):    print('({},{})'.format(x,y))&gt;&gt;&gt;(0,1)(1,2)(2,1)(3,2)</code></pre><p>可以通过 op_flags 传递一些标志，例如 no_broadcast 禁止广播，此时 A 和 B的形状必须相同，否则报错。</p><pre><code>for x,y in np.nditer([A, B], op_flags = ['readonly', 'no_broadcast']):    print('({},{})'.format(x,y))</code></pre><h4 id="1-8-4-3-迭代对象创建数组"><a href="#1-8-4-3-迭代对象创建数组" class="headerlink" title="1.8.4.3. 迭代对象创建数组"></a>1.8.4.3. 迭代对象创建数组</h4><pre><code>np.fromiter(iterabe, dtype, count=-1)</code></pre><p>np.fromiter 从可迭代对象中建立1维数组，可以指定个数。</p><pre><code>iterator = iter(range(10))print(np.fromiter(iterator, dtype=int, count=2))print(np.fromiter(iterator, dtype=int, count=3))&gt;&gt;&gt;[0 1][2 3 4]</code></pre><h2 id="1-9-布尔数组和掩码"><a href="#1-9-布尔数组和掩码" class="headerlink" title="1.9. 布尔数组和掩码"></a>1.9. 布尔数组和掩码</h2><p>如果我们有大量数据需要进行统计，比如大于某值的数据有多少个如何处理呢？</p><h3 id="1-9-1-比较操作"><a href="#1-9-1-比较操作" class="headerlink" title="1.9.1. 比较操作"></a>1.9.1. 比较操作</h3><p>和算数运算类似，Numpy 同时支持比较运算符和内置函数：</p><blockquote><table><thead><tr><th>比较运算符</th><th>对应通用函数</th></tr></thead><tbody><tr><td>==</td><td>np.equal</td></tr><tr><td>!=</td><td>np.not_equal</td></tr><tr><td>&lt;</td><td>np.less</td></tr><tr><td>&lt;=</td><td>np.less_equal</td></tr><tr><td>&gt;</td><td>np.greater</td></tr><tr><td>&gt;=</td><td>np.greater_equal</td></tr></tbody></table></blockquote><pre><code>A = np.arange(4).reshape(2, 2)print(A)print(A &gt; 1) # 符合交换律print(1 &lt; A)&gt;&gt;&gt;[[0 1] [2 3]][[False False] [ True  True]][[False False] [ True  True]]</code></pre><p>对应的函数操作如下：</p><pre><code>print(np.greater(A, 1)) </code></pre><p>可以看出比较运算返回的结果是一个布尔数组：所有元素都是布尔值 True 或 False，每个元素只有 1 个 bit 的存储空间。</p><h3 id="1-9-2-布尔数组统计"><a href="#1-9-2-布尔数组统计" class="headerlink" title="1.9.2. 布尔数组统计"></a>1.9.2. 布尔数组统计</h3><p>布尔数组的统计函数如下表所示，它们均支持指定轴 axis 参数。此外必须通过 np. 引用。</p><blockquote><table><thead><tr><th>统计函数</th><th>描述</th></tr></thead><tbody><tr><td>np.count_nonzero</td><td>统计布尔数组中 True 记录的个数</td></tr><tr><td>np.sum</td><td>等价于 np.count_nonzero</td></tr><tr><td>np.any</td><td>有没有值满足条件，只要有一个满足就返回 True</td></tr><tr><td>np.all</td><td>所有值都满足条件时返回 True</td></tr></tbody></table></blockquote><pre><code>A = np.arange(4).reshape(2, 2)print(A)print(np.count_nonzero(A &gt; 1), np.sum(A &gt; 1))print(np.any(A &gt; 1), np.all(A &gt; 1))&gt;&gt;&gt;[[0 1] [2 3]]2 2True False</code></pre><h3 id="1-9-3-逻辑运算"><a href="#1-9-3-逻辑运算" class="headerlink" title="1.9.3. 逻辑运算"></a>1.9.3. 逻辑运算</h3><p>NumPy 借用了 Python 的位运算符 &amp;、 |、 ~ 和 ^ 来实现逻辑运算，对应 Python 中的 and，or，not，^ 是异或，没有对应的符号。</p><p>布尔数组可以被当作是由比特字符组成的， 其中 1 = True、 0 = False。 这样在数组上使用上面介绍的位运算符操作就易于理解了。</p><blockquote><table><thead><tr><th>运算符</th><th>对应通用函数</th></tr></thead><tbody><tr><td>&amp;</td><td>np.bitwise_and</td></tr><tr><td>|</td><td>np.bitwise_or</td></tr><tr><td>^</td><td>np.bitwise_xor</td></tr><tr><td>~</td><td>np.bitwise_not</td></tr></tbody></table></blockquote><p>有了逻辑运算符，我们就可以进行指定多个过滤条件：</p><pre><code>A = np.arange(4).reshape(2, 2)print(A)print(np.sum((A &gt;= 1) &amp; (A &lt; 4))) # 统计 [1,4) 之间值的个数&gt;&gt;&gt;[[0 1] [2 3]]3</code></pre><p>需要注意的是布尔数组的每个元素只有 1 个 bit 的存储空间，所以 A &amp; (A &gt; 0) 返回的是 A 中每个元素的最后一位组成的数组：</p><pre><code>print(A &amp; (A &gt; 0))&gt;&gt;&gt;[[0 1] [0 1]]</code></pre><h3 id="1-9-4-布尔数组作为掩码"><a href="#1-9-4-布尔数组作为掩码" class="headerlink" title="1.9.4. 布尔数组作为掩码"></a>1.9.4. 布尔数组作为掩码</h3><p>布尔数组不仅可以用于统计个数，还可以用于掩码来提取数据值。</p><pre><code>A = np.arange(4).reshape(2, 2)print(A)# 等价于 A_mask = (np.bitwise_and(A &gt;= 1, A &lt; 4))A_mask = (A &gt;= 1) &amp; (A &lt; 4)print(A_mask)print(A[A_mask]) # 布尔数组作为索引，提取 True 对应的值&gt;&gt;&gt;[[0 1] [2 3]][[False  True] [ True  True]][1 2 3]</code></pre><p>返回的是一个一维数组，所有的这些值是掩码数组对应位置为 True 的值。</p><p>如果我们不需要查看 A_mask，可以直接把比较表达式作为索引，例如：</p><pre><code>print(A[(A &gt;= 1) &amp; (A &lt; 4)]) </code></pre><h3 id="1-9-5-保留形状筛选"><a href="#1-9-5-保留形状筛选" class="headerlink" title="1.9.5. 保留形状筛选"></a>1.9.5. 保留形状筛选</h3><p>以上示例可以看到，布尔数组直接作为索引，返回的是一个一维数组。使用布尔数组也可以在保留原数组形状的情况下提取特定数据。</p><p>首先使用布尔数组乘以 1 转换为整型的 0/1 筛选数组，然后使用乘法进行筛选：</p><pre><code>A = np.array([[0, 1], [2, 3]])print(A)&gt;&gt;&gt;[[0 1] [2 3]]# 提取所有数据为 1 的元素，其余元素置为 0print(A * (A==1)*1)&gt;&gt;&gt;[[0 1] [0 0]]</code></pre><p>筛选数组中每个 1 对应的元素被保留，每个 0 对应的数组被过滤掉，只留下 0。当然也可以使用逻辑运算来组合生成布尔数组：</p><pre><code># 返回 (0, 3) 之间的所有元素B = ((A &gt; 0) &amp; (A &lt; 3)) * 1print(A * B)[[0 1] [2 0]]</code></pre><p>保留形状筛选同样可以使用 np.where 实现。</p><h3 id="1-9-6-where条件筛选"><a href="#1-9-6-where条件筛选" class="headerlink" title="1.9.6. where条件筛选"></a>1.9.6. where条件筛选</h3><p>当元素满足条件(condition)时，输出 x 中对应元素，不满足输出 y 中对应元素。x, y 和 condition 自动进行广播扩展，以进行筛选。</p><pre><code>A = np.array([0,0,1,2]).reshape(2,2)print(A)&gt;&gt;&gt;[[0 0] [1 2]]# 0 元素(False)被替换为 -1, (True)被替换为 1print(np.where(A, 1, -1))&gt;&gt;&gt;[[-1 -1] [ 1  1]]</code></pre><p>此时 1 和 -1 会自动根据 A 的形状进行广播扩展。下面的这个示例更清晰的看到了这一点：</p><pre><code>A = np.array([0,1])print(np.where(True, A, -1))&gt;&gt;&gt;[0 1]print(np.where(False, A, -1))&gt;&gt;&gt;[-1 -1]</code></pre><p>只有条件 (condition)参数，没有x和y，等价于numpy.nonzero。这里的坐标以元组的形式给出，通常原数组有多少维，输出的元组中就包含几个数组，分别对应符合条件元素的各维坐标。</p><pre><code>A = np.array([0,1,2,3]).reshape(2,2)print(A)&gt;&gt;&gt;[[0 1] [2 3]]B = np.where(A)print(type(B).__name__) # 元组print(len(B))           # 2个数组，对应各个维度的索引print(B)&gt;&gt;&gt;tuple2(array([0, 1, 1], dtype=int64), array([1, 0, 1], dtype=int64))</code></pre><p>A[0,1]，A[1,0] 和 A[1,1] 对应元素均大于 0。A[B] 等价于 A[np.where(A)]。</p><h2 id="1-10-花式索引和组合索引"><a href="#1-10-花式索引和组合索引" class="headerlink" title="1.10. 花式索引和组合索引"></a>1.10. 花式索引和组合索引</h2><p>我们已经了解了如何利用简单的索引值（A[0]） 切片（A[:5]） 和布尔掩码（A[A &gt; 0]） 获得数组元素。</p><p>花式索引（fancy indexing）提供更复杂的索引方式：索引数组。</p><h3 id="1-10-1-花式索引"><a href="#1-10-1-花式索引" class="headerlink" title="1.10.1. 花式索引"></a>1.10.1. 花式索引</h3><p>花式索引指的是用整数列表（array-likes）或者整数数组进行索引。与切片索引不同，花式索引会对原数组数据进行复制以生成新数组。</p><h4 id="1-10-1-1-索引列表"><a href="#1-10-1-1-索引列表" class="headerlink" title="1.10.1.1. 索引列表"></a>1.10.1.1. 索引列表</h4><p>传递由整数索引组成的索引列表，用于提取索引对应的元素：</p><pre><code>A = np.arange(4)print(A)&gt;&gt;&gt;[0 1 2 3]# 索引列表提取元素print(A[[0, 3]])&gt;&gt;&gt;[0 3]</code></pre><p>更高维度的数组需要传递每个维度上的索引列表：</p><pre><code>A = np.arange(4).reshape(2, 2)print(A)&gt;&gt;&gt;[[0 1] [2 3]]row = [0, 1]column = [0, 1]print(A[row, column])&gt;&gt;&gt;[0 3]   # 对应 [A[0,0] A[1,1]]</code></pre><p>每个维度上的索引列表长度必须一致，以进行行列的索引配对，使用列表作为索引的结果均是一维数组。</p><h4 id="1-10-1-2-索引数组"><a href="#1-10-1-2-索引数组" class="headerlink" title="1.10.1.2. 索引数组"></a>1.10.1.2. 索引数组</h4><p>一个更简单的方式是使用索引数组。生成的数组形状与索引数组相同，与原数组无关。</p><pre><code>A = np.arange(9)print(A)index_array = np.array([[3, 7], [4, 5]])print(A[index_array])&gt;&gt;&gt;[0 1 2 3 4 5 6 7 8][[3 7] [4 5]]</code></pre><p>再看一个更复杂的例子，可以更明确这里的 index_array 指定的是对第一维的索引值：</p><pre><code>A = np.arange(4).reshape(2, 2)print(A)index_array = np.array([[0,1],[1,0]])print(index_array)&gt;&gt;&gt;[[0 1]    # 原数组 [2 3]][[0 1]    # 索引数组 [1 0]]print(A[index_array])&gt;&gt;&gt;[[[0 1]  [2 3]] [[2 3]  [0 1]]]</code></pre><p>依次根据索引数组中的值 index = index_array[i][j] 取 A[index] 放在索引数组的 [i][j] 位置，最终生成新的数组。</p><p>我们已经看到索引数组对多维度数组同样适用，如果只提供一个索引数组则对应第一维的索引，如果为每一个轴指定一个索引向量（1维数组），就可以索引到特定元素。</p><pre><code>A = np.arange(9).reshape((3, 3))print(A)row = np.array([0, 1, 2]) # 0 轴索引向量col = np.array([2, 1, 2]) # 1 轴索引向量print(A[row, col])&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]][2 4 8]   # 2 对应 A[0,2]，也即 A[row[0], col[0]]</code></pre><p>在花式索引中，索引值的配对遵循广播规则。 因此当我们将一个列向量和一个行向量组合在一个索引中时， 会得到一个二维的结果：</p><pre><code>A = np.arange(9).reshape((3, 3))print(A)row = np.array([0, 1, 2])col = np.array([2, 1, 2])print(A[row[:, np.newaxis], col])&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]][[2 1 2] [5 4 5] [8 7 8]]</code></pre><p>在 A[row[:, np.newaxis], col] 进行索引时，会根据广播规则自动生成对应 0 轴的索引数组和 1 轴的索引数组：</p><pre><code># 0 轴索引[[0 0 0] [1 1 1] [2 2 2]]# 1 轴索引[[2 1 2] [2 1 2] [2 1 2]]# 生成的数组对应的索引[[[0,2] [0,1] [0,2]] [[1,2] [1,1] [1,2]] [[2,2] [2,1] [2,2]]]</code></pre><p>用于索引的数组形状如下所示，花式索引返回的值反映的是广播后的索引数组的形状， 而不是被索引的数组的形状。</p><pre><code>print(row[:, np.newaxis] * col)&gt;&gt;&gt;[[0 0 0] [2 1 2] [4 2 4]]</code></pre><h3 id="1-10-2-组合索引"><a href="#1-10-2-组合索引" class="headerlink" title="1.10.2. 组合索引"></a>1.10.2. 组合索引</h3><p>花式索引可以和其他索引方案结合起来形成更强大的索引操作。</p><p>和简单的索引组合使用：</p><pre><code>AA = np.arange(9).reshape((3, 3))print(A)print(A[2, [0,1,2]]) # 进行广播，也即[[2,2,2], [0,1,2]]&gt;&gt;&gt;[[0 1 2] [3 4 5] [6 7 8]][6 7 8]</code></pre><p>和切片组合使用：</p><pre><code># 切片选择多行 1: 等价于 [[1],[2]]print(A[1:, [0,1,2]])&gt;&gt;&gt;[[3 4 5] [6 7 8]]</code></pre><p>和掩码组合使用：</p><pre><code>mask = np.array([1, 0, 0])row = np.array([0, 1, 2])print(A[row[:, np.newaxis], mask])&gt;&gt;&gt;[[1 0 0] [4 3 3] [7 6 6]]</code></pre><p>索引选项的组合可以实现非常灵活的获取和修改数组元素的操作。</p><h3 id="1-10-3-各类索引总结"><a href="#1-10-3-各类索引总结" class="headerlink" title="1.10.3. 各类索引总结"></a>1.10.3. 各类索引总结</h3><ul><li>简单索引：返回的数组元素是原数组的拷贝</li><li>切片：返回原数组视图</li><li>花式索引：返回数组拷贝，提供几个索引数组，它所在的位置决定了它的值要索引的维。几个索引数组通过广播规则进行扩展，扩展后的形状必须相同。</li></ul><p>花式索引中的索引数组个数小于被索引数组维数时，则取到的元素为一个数组，此时生成的新数组维数将大于索引数组的维数。</p><pre><code> = np.arange(8).reshape(2, 2, 2)print(A)index_array = np.array([[0,1],[1,0]])print(index_array)C = A[index_array, index_array]print(C)&gt;&gt;&gt;[[[0 1]   # 原数组  [2 3]] [[4 5]  [6 7]]][[0 1]    # 索引数组，shape(2,2) [1 0]][[[0 1]   # 结果，shape(2,2,2)  [6 7]] [[6 7]  [0 1]]]</code></pre><h2 id="1-11-转置和滚动"><a href="#1-11-转置和滚动" class="headerlink" title="1.11. 转置和滚动"></a>1.11. 转置和滚动</h2><h3 id="1-11-1-数组转置"><a href="#1-11-1-数组转置" class="headerlink" title="1.11.1. 数组转置"></a>1.11.1. 数组转置</h3><p>np.transpose 实现数组的形状逆序，例如 shape(1,2,3,4) 的数组经 transpose 处理后返回 shape(4,3,2,1) 的数组视图。所以对于 1 维数组来说，转换后还是其自身。</p><pre><code>A = np.arange(6).reshape((2, 3, 1))print(A.transpose().shape)print(A.T)  # A.transpose() 的快捷方式&gt;&gt;&gt;(1, 3, 2)[[[0 3]  [1 4]  [2 5]]]</code></pre><p>transpose() 可以直接使用对象引用它。作用在二维数组（矩阵）上，相当于对矩阵进行转置：</p><pre><code>A = np.arange(4).reshape((2, 2))print(A)print(A.transpose()) # 转置矩阵&gt;&gt;&gt;[[0 1] [2 3]][[0 2] [1 3]]</code></pre><p>对于更高维数组的转换，我们继续第一个例子，来了解元素是怎么被转换的：</p><pre><code>A = np.arange(6).reshape((2, 3, 1))print(A)   # A.shape(2,3,1)print(A.T) # A.T.shape(1,3,2)&gt;&gt;&gt;[[[0]  [1]  [2]] [[3]  [4]  [5]]][[[0 3]  [1 4]  [2 5]]]</code></pre><p>转换的第一步是以元组方式从大到小列出 A 中元素的所有索引，接着按照转换规则调换索引。</p><p>根据 A.T.shape(1,3,2) 我们列出转换后数组的元素索引：</p><pre><code>|  0  |  1  |  2  |  3  |  4  |  5  | 索引对应的值---------------------------------------------------| 000 | 010 | 020 | 100 | 110 | 120 | A元素的索引---------------------------------------------------| 000 | 010 | 020 | 001 | 011 | 021 | A调换0/2轴的索引---------------------------------------------------| 000 | 001 | 010 | 011 | 020 | 021 | A.T元素的索引</code></pre><p>可以发现 A 数组调换0/2轴的索引和 A.T 元素的索引的组合是一致的，由排列组合可知它们一一对应。</p><p>根据 A调换0/2轴的索引对应的元素，填入到 A.T 相同索引处。例如 001 对应 3，放到 A.T[0,0,1]处。</p><h3 id="1-11-2-指定转换索引"><a href="#1-11-2-指定转换索引" class="headerlink" title="1.11.2. 指定转换索引"></a>1.11.2. 指定转换索引</h3><p>np.transpose 默认对所有轴按中心对称方式交换。我们也可以通过 axes 参数指定转换索引。</p><pre><code>A = np.arange(6).reshape((2, 3, 1))AT = A.transpose((2,0,1)) # 索引交换规则：2-&gt;0, 0-&gt;1, 1-&gt;2print(A, AT.shape)print(AT)&gt;&gt;&gt;[[[0]  [1]  [2]] [[3]  [4]  [5]]] (1, 2, 3)[[[0 1 2]  [3 4 5]]]</code></pre><p>按照以上转换规则，我们可以列出如下索引，按照交换后的索引，找到对应元素。</p><pre><code>|  0  |  1  |  2  |  3  |  4  |  5  | 索引对应的值---------------------------------------------------| 000 | 010 | 020 | 100 | 110 | 120 | A元素的索引---------------------------------------------------| 000 | 001 | 002 | 010 | 011 | 012 | 2-&gt;0, 0-&gt;1, 1-&gt;2---------------------------------------------------| 000 | 001 | 002 | 010 | 011 | 012 | A.transpose元素的索引</code></pre><h3 id="1-11-3-按轴滚动"><a href="#1-11-3-按轴滚动" class="headerlink" title="1.11.3. 按轴滚动"></a>1.11.3. 按轴滚动</h3><p>np.roll(a, shift, axis=None) 将数组  a 沿着 axis 的方向，滚动 shift 长度可以向后滚动特定的轴到一个指定位置。如果不指定 axis 则默认先进行展平操作，然后按照向量滚动，最后按原 shape 返回。</p><pre><code># a 为向量a = np.arange(10)print(a)&gt;&gt;&gt;[0 1 2 3 4 5 6 7 8 9]# shift 为正数表示向右滚动b = np.roll(a, 2)print(b)&gt;&gt;&gt;[8 9 0 1 2 3 4 5 6 7]# shift 为负数表示向左滚动c = np.roll(a, -2)print(c)&gt;&gt;&gt;[2 3 4 5 6 7 8 9 0 1</code></pre><p>a 为向量，只有一个轴，滚动操作默认 axis = 0，可以不指定。shift 正负决定了滚动方向。多维矩阵：</p><pre><code>a = np.reshape(np.arange(12), (4,3))print(a)&gt;&gt;&gt;[[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]]# 沿着 0 轴（垂直方向滚动 1 行）print(np.roll(a, 1, axis=0))&gt;&gt;&gt;[[ 9 10 11] [ 0  1  2] [ 3  4  5] [ 6  7  8]]# 沿着 1 轴（水平方向滚动 1 行）print(np.roll(a, 1, axis=1))&gt;&gt;&gt;[[ 2  0  1] [ 5  3  4] [ 8  6  7] [11  9 10]]# 展平后滚动再按原 shape 返回print(np.roll(a, 1))&gt;&gt;&gt;[[11  0  1] [ 2  3  4] [ 5  6  7] [ 8  9 10]]</code></pre><p>对于二维或者多维矩阵，shift 和 axis 可以指定滚动某一维，也可以通过 tuple 指定多维。</p><pre><code># 相当于多次滚动操作，先在 0 轴滚动 1 次，然后再在 1 轴滚动 1次print(np.roll(a, (1,1), axis=(0,1)))&gt;&gt;&gt;[[11  9 10] [ 2  0  1] [ 5  3  4] [ 8  6  7]]</code></pre><h3 id="1-11-4-滚动轴"><a href="#1-11-4-滚动轴" class="headerlink" title="1.11.4. 滚动轴"></a>1.11.4. 滚动轴</h3><p>np.rollaxis 可以向后滚动特定的轴到一个指定位置，格式如下：</p><pre><code>A = np.ones((3,4,5,6))print(np.rollaxis(A, 2).shape)    # 轴2放到shape[0]，其他轴顺序不变print(np.rollaxis(A, 3, 1).shape) # 轴3放到shape[1]，其他轴顺序不变print(np.rollaxis(A, 1, 4).shape) # 轴1放到shape[4]，其他轴顺序不变&gt;&gt;&gt;(5, 3, 4, 6)(3, 6, 4, 5)(3, 5, 6, 4)</code></pre><p>类似 np.transpose 的处理流程，我们可以根据索引交换规则，来写出交换后的索引然后把元素映射到新的数组视图中。</p><h3 id="1-11-5-交换轴"><a href="#1-11-5-交换轴" class="headerlink" title="1.11.5. 交换轴"></a>1.11.5. 交换轴</h3><p>np.swapaxes() 交换两个指定的轴。</p><pre><code>swapaxes(a, axis1, axis2)    Interchange two axes of an array.</code></pre><pre><code>A = np.arange(6).reshape((2, 3, 1))print(A.shape)print(np.swapaxes(A, 0, 2).shape, np.swapaxes(A, 0, 1).shape)&gt;&gt;&gt;(2, 3, 1)(1, 3, 2) (3, 2, 1)</code></pre><p>类似 np.transpose 的处理流程，我们可以根据索引交换规则，来写出交换后的索引然后把元素映射到新的数组视图中。</p><h2 id="1-12-数组排序"><a href="#1-12-数组排序" class="headerlink" title="1.12. 数组排序"></a>1.12. 数组排序</h2><p>在进行大数据排序时，NumPy 提供的排序函数要比 Python 提供的 sort 和 sorted 函数高效得多。</p><blockquote><table><thead><tr><th>排序函数</th><th>说明</th></tr></thead><tbody><tr><td>np.sort()</td><td>快速排序，返回复制的新数组</td></tr><tr><td>A.sort()</td><td>对象内置排序，作用在数组上</td></tr><tr><td>np.argsort()</td><td>原数组排好序的索引值</td></tr></tbody></table></blockquote><h3 id="1-12-1-快速排序"><a href="#1-12-1-快速排序" class="headerlink" title="1.12.1. 快速排序"></a>1.12.1. 快速排序</h3><p>排序函数默认使用快速排序，并作用在最后一个轴上。</p><pre><code>A = np.array([1, 3, 2, 4])print(A)&gt;&gt;&gt;[1 3 2 4][1 2 3 4]</code></pre><p>np.sort() 返回复制元素的新数组，尝试修改 B 中元素，不影响 A。</p><pre><code>A = np.array([1, 3, 2, 4])print(A)B = np.sort(A)  # B 中元素是拷贝print(B)&gt;&gt;&gt;[1 3 2 4][1 2 3 4]B[0] = -1       # 不影响 Aprint(A)&gt;&gt;&gt;[1 3 2 4]</code></pre><p>为了节省空间，可以直接在 ndarray 上排序：</p><pre><code>A = np.array([1, 3, 2, 4]) print(A) A.sort() # 无返回 print(A) &gt;&gt;&gt; [1 3 2 4] [1 2 3 4] </code></pre><p>获取排序的索引数组，并使用索引数组获取排序后的数组。</p><pre><code>A = np.array([1, 3, 2, 4])print(A)I = np.argsort(A)print(I, A[I])&gt;&gt;&gt;[1 3 2 4][0 2 1 3] [1 2 3 4] </code></pre><h3 id="1-12-2-归并排序和堆排序"><a href="#1-12-2-归并排序和堆排序" class="headerlink" title="1.12.2. 归并排序和堆排序"></a>1.12.2. 归并排序和堆排序</h3><p>以上排序函数均支持 kind 参数来指定排序方法：’quicksort’, ‘mergesort’ 和 ‘heapsort’，默认为快速排序。</p><pre><code>A = np.array([1, 3, 2, 4])B = A.copy()print(A)A.sort(kind='mergesort')B.sort(kind='heapsort')print(A, B)&gt;&gt;&gt;[1 3 2 4][1 2 3 4] [1 2 3 4]</code></pre><h3 id="1-12-3-指定轴排序"><a href="#1-12-3-指定轴排序" class="headerlink" title="1.12.3. 指定轴排序"></a>1.12.3. 指定轴排序</h3><p>指定轴，可以沿着行或列排序。以上排序函数均支持 axis 参数。axis 默认为 -1，也即作用在最后一个轴上。</p><pre><code>A = np.array([[4, 1], [2, 3]])B = A.copy()print(A)print(np.sort(A)) # 作用在最后一维上，对于二维数组也即行排序&gt;&gt;&gt;[[4 1] [2 3]][[1 4] [2 3]]</code></pre><p>指定 axis = 0，进行列排序：</p><pre><code>print(np.sort(A, axis=0))&gt;&gt;&gt;[[2 1] [4 3]]</code></pre><p>若要进行逆序排序，排序函数为提供对应参数，可以对结果进行切片逆序实现：</p><pre><code>print(np.sort(A, axis=0)[::-1])&gt;&gt;&gt;[[4 3] [2 1]]</code></pre><h3 id="1-12-4-部分排序"><a href="#1-12-4-部分排序" class="headerlink" title="1.12.4. 部分排序"></a>1.12.4. 部分排序</h3><p>有时候我们不希望对整个数组进行排序， 仅仅希望找到数组中第 K 小的值， NumPy 的 np.partition 函数提供了该功能。</p><p>np.partition 函数的输入是数组和数字 kth， 输出结果是一个新数组， 最左边是前 kth 索引的排序， 往右是任意顺序的其他值：</p><pre><code>A = np.array([2, 0, 3, 1, 6, 5, 4])print(A)print(np.partition(A, 1))print(np.partition(A, 3))&gt;&gt;&gt;[2 0 3 1 6 5 4][0 1 3 2 6 5 4] # 索引[0],[1] 排序 2 个最小元素[0 1 2 3 4 5 6] # 索引[0],[1],[2],[3] 排序 4 个最小元素</code></pre><p>与排序类似，也可以沿着多维数组任意的轴进行分隔，默认 axis=-1：</p><pre><code>A = np.array([[2, 0, 3, 5], [1, 6, 5, 4]])print(A)print(np.partition(A, 1, axis=1)) # 对行排序，2个最小元素&gt;&gt;&gt;[[2 0 3 5] [1 6 5 4]][[0 2 3 5] [1 4 5 6]]</code></pre><p>与 np.partition 对应，np.argpartition 返回部分排序的索引：</p><pre><code>print(np.argpartition(A, 1, axis=1))&gt;&gt;&gt;[[1 0 2 3] [0 3 2 1]]</code></pre><h2 id="1-13-结构化数据"><a href="#1-13-结构化数据" class="headerlink" title="1.13. 结构化数据"></a>1.13. 结构化数据</h2><p>大多数时候， 我们的数据可以通过一个异构类型值组成的数组表示， 但有时却并非如此。 本节介绍 NumPy 的结构化数组和记录数组，  它们为复合的、 异构的数据提供了非常有效的存储。 尽管这里列举的模式对于简单的操作非常有用， 但是这些场景通常也可以用 Pandas 的  DataFrame 来实现。</p><p>假定现在有关于一些学生的分类数据（如姓名、 年龄和体重） ， 我们需要存储这些数据用于 Python 项目， 那么一种可行的方法是将它们存在三个单独的数组中。</p><pre><code>name = ['Tom', 'Bob', 'John', 'George']age = [18, 25, 22, 19]weight = [58.0, 65.5, 68.0, 61.5]</code></pre><p>但是这种方法有点笨， 因为并没有任何信息告诉我们这三个数组是相关联的。 如果可以用一种单一结构来存储所有的数据， 那么看起来会更自然。 NumPy 可以用结构化数组实现这种存储，这些结构化数组是复合数据类型的。</p><h3 id="1-13-1-结构化数组"><a href="#1-13-1-结构化数组" class="headerlink" title="1.13.1. 结构化数组"></a>1.13.1. 结构化数组</h3><p>通过 dtype 参数可以生成复合数据类型的结构化数组：</p><pre><code># 使用复合数据结构的结构化数组data = np.zeros(4, dtype={'names':('name', 'age', 'weight'),                'formats':('U10', 'i4', 'f8')})print(data.dtype)&gt;&gt;&gt;[('name', '&lt;U10'), ('age', '&lt;i4'), ('weight', '&lt;f8')]</code></pre><p>这里 U10 表示“长度不超过 10 的 Unicode 字符串”， i4 表示“4 字节（即32 比特） 整型”， f8 表示“8 字节（即 64 比特） 浮点型”。</p><p>现在生成了一个空的数组容器， 可以将列表数据放入数组中：</p><pre><code>data['name'] = namedata['age'] = agedata['weight'] = weightprint(data)print(data.shape)&gt;&gt;&gt;[('Tom', 18,  58. ) ('Bob', 25,  65.5) ('John', 22,  68. )('George', 19,  61.5)](4,)</code></pre><p>结构化数组的方便之处在于，可以通过索引或名称查看相应的值：</p><pre><code>print(data['name'])     # 获取所有名字print(data[0])          # 获取数据第一行print(data[-1]['name']) # 获取最后一行的名字&gt;&gt;&gt;['Tom' 'Bob' 'John' 'George']('Tom', 18,  58.)George</code></pre><p>利用布尔掩码， 还可以做一些更复杂的操作， 如按照年龄进行筛选：</p><pre><code># 获取年龄大于20岁的人的名字print(data[data['age'] &gt; 20]['name'])&gt;&gt;&gt;['Bob' 'John']</code></pre><p>如果你希望实现比上面更复杂的操作， 那么你应该考虑使用 Pandas。</p><h3 id="1-13-2-定制数据类型"><a href="#1-13-2-定制数据类型" class="headerlink" title="1.13.2. 定制数据类型"></a>1.13.2. 定制数据类型</h3><p>结构化数组的数据类型有多种制定方式。 此前我们看过了采用字典的方法：</p><pre><code>np.dtype({'names':('name', 'age', 'weight'),         'formats':('U10', 'i4', 'f8')})</code></pre><p>数值数据类型可以用 Python 类型或 NumPy 的 dtype 类型指定：</p><pre><code>np.dtype({'names':('name', 'age', 'weight'),         'formats':((np.str_, 10), int, np.float32)})</code></pre><p>复合类型也可以通过元组列表指定：</p><pre><code>np.dtype([('name', 'S10'), ('age', 'i4'), ('weight', 'f8')])</code></pre><p>如果类型的名称对你来说并不重要， 那你可以仅仅用一个字符串来指定它。 在该字符串中数据类型用逗号分隔：</p><pre><code>np.dtype('S10,i4,f8') </code></pre><p>简写的字符串格式的代码可能看起来令人困惑， 但是它们其实基于非常简单的规则。</p><ul><li><p>第一个（可选） 字符是 &lt; 或者 &gt;， 分别表示“低字节序”（little endian） 和“高字节序”（bid endian），表示字节（bytes）类型的数据在内存中存放顺序的习惯用法。</p></li><li><p>后一个字符指定的是数据的类型： 字符、 字节、 整型、 浮点型， 等等（如下表所示）。</p></li><li><p>最后一个字符表示该对象的字节大小。</p><table><thead><tr><th>类型符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>‘b’</td><td>字节型</td><td>np.dtype(‘b’)</td></tr><tr><td>‘i’</td><td>有符号整型</td><td>np.dtype(‘i4’) == np.int32</td></tr><tr><td>‘u’</td><td>无符号整型</td><td>np.dtype(‘u1’) == np.uint8</td></tr><tr><td>‘f’</td><td>浮点型</td><td>np.dtype(‘f8’) == np.int64</td></tr><tr><td>‘c’</td><td>复数浮点型</td><td>np.dtype(‘c16’) == np.complex128</td></tr><tr><td>‘S’,’a’</td><td>字符串</td><td>np.dtype(‘S5’)</td></tr><tr><td>‘U’</td><td>Unicode 编码字符串</td><td>np.dtype(‘U’) == np.str_</td></tr><tr><td>‘V’</td><td>原生数据(raw data)</td><td>np.dtype(‘V’) == np.void</td></tr></tbody></table></li></ul><h3 id="1-13-3-高级复合类型"><a href="#1-13-3-高级复合类型" class="headerlink" title="1.13.3. 高级复合类型"></a>1.13.3. 高级复合类型</h3><p>NumPy 中也可以定义更高级的复合数据类型。 例如， 你可以创建一种类型， 其中每个元素都包含一个数组或矩阵。 我们会创建一个数据类型，该数据类型用 mat 组件包含一个 3×3 的浮点矩阵：</p><pre><code>tp = np.dtype([('id', 'i8'), ('mat', 'f8', (3, 3))])X = np.zeros(1, dtype=tp)print(X[0])print(X['mat'][0])&gt;&gt;&gt;(0, [[ 0.,  0.,  0.], [ 0.,  0.,  0.], [ 0.,  0.,  0.]])[[ 0.  0.  0.] [ 0.  0.  0.] [ 0.  0.  0.]]</code></pre><p>现在 X 数组的每个元素都包含一个 id 和一个 3×3 的矩阵。 为什么我们宁愿用这种方法存储数据， 也不用简单的多维数组， 或者  Python 字典呢？ 原因是 NumPy 的 dtype 直接映射到 C 结构的定义， 因此包含数组内容的缓存可以直接在 C 程序中使用。  如果你想写一个 Python 接口与一个遗留的 C 语言或 Fortran 库交互， 从而操作结构化数据， 你将会发现结构化数组非常有用！</p><p>NumPy 还提供了 np.recarray 类。 它和前面介绍的结构化数组几乎相同， 但是它有一个独特的特征： 域可以像属性一样获取， 而不是像字典的键那样获取。 前面的例子通过以下代码获取年龄：</p><pre><code>print(data['age'])&gt;&gt;&gt;[18 25 22 19]</code></pre><p>如果将这些数据当作一个记录数组， 我们可以用更简短的方式来获取这个结果：</p><pre><code>data_rec = data.view(np.recarray)print(data_rec.age)&gt;&gt;&gt;[18 25 22 19]</code></pre><p>记录数组的不好的地方在于， 即使使用同样的语法， 在获取域时也会有一些额外的开销。</p><h2 id="1-14-应用实例"><a href="#1-14-应用实例" class="headerlink" title="1.14. 应用实例"></a>1.14. 应用实例</h2><p>更复杂和专业的图像处理应该使用 PIL，PIL(Python Image  Library)是python的第三方图像处理库，由于其强大的功能与众多的使用人数，几乎已经被认为是python官方图像处理库了。图形处理相关模块还有 OpenCV, SciKit-Image 和 Pillow。</p><h3 id="1-14-1-矩阵和图像变换"><a href="#1-14-1-矩阵和图像变换" class="headerlink" title="1.14.1. 矩阵和图像变换"></a>1.14.1. 矩阵和图像变换</h3><p>在图像处理软件中对图像的变换均是通过矩阵操作来完成的，这种矩阵被称为变换矩阵。</p><p>基本的常用矩阵变换操作包括平移、缩放、旋转、斜切。每种变换都对应一个变换矩阵，通过矩阵乘法，可以把多个变换矩阵相乘得到复合变换矩阵。矩阵乘法不支持交换律，因此不同的变换顺序得到的变换矩阵也是不相同的。</p><p>首先，我们使用四个坐标点来生成一个正方形，然后基于它进行各类变换：</p><pre><code>P = np.array([[0,1,1,0],  # x 轴坐标              [0,0,1,1]]) # y 轴坐标plt.figure(figsize=(7,7))plt.title('Square', fontsize=16)plt.xlim(-2, 2)plt.ylim(-2, 2)plt.fill(P[0], P[1], facecolor='r', alpha=0.5)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/square.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/square.png" alt="square"></a></p><p>原始正方形</p><p>可以看到该正方形左下角为坐标原点，单位边长为 1，使用矩阵进行线性变换，原点是不会移动的，所以平移操作并不是线性的，后面在平移小结会介绍。</p><h4 id="1-14-1-1-旋转"><a href="#1-14-1-1-旋转" class="headerlink" title="1.14.1.1. 旋转"></a>1.14.1.1. 旋转</h4><p>首先看一个围绕原点旋转的示例，然后分析为何乘以某个矩阵就会实现旋转的效果。</p><pre><code># P 为二维数组，包含需要转换的坐标点数据，angle 为转换角度def rotate(P, angle):    rad = angle/180 * np.pi    # 2D 旋转变换矩阵    R = np.array([[np.cos(rad), -np.sin(rad)],                  [np.sin(rad), np.cos(rad)]])    return R.dot(P)</code></pre><p>rotate 函数实现逆时针旋转，当然只要把参数 angle 改为 -angle 就可以实现顺时针旋转。</p><pre><code>plt.figure(figsize=(7,7))plt.title('Rotate', fontsize=16)plt.xlim(-2, 2)plt.ylim(-2, 2)plt.fill(P[0], P[1], facecolor='r', alpha=0.5)# 依次旋转 45 度for i in range(1,5,1):    rr = rotate(P, i*45)    plt.fill(rr[0], rr[1], alpha=1) # 自动填充不同颜色</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/rotate.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/rotate.png" alt="rotate"></a></p><p>矩阵旋转变换</p><p>从图中可以看出，原始位置的正方形围绕原点向左逆时针依次旋转 45 度，这里旋转了四次。</p><h4 id="1-14-1-2-缩放"><a href="#1-14-1-2-缩放" class="headerlink" title="1.14.1.2. 缩放"></a>1.14.1.2. 缩放</h4><p>缩放通过缩放变换矩阵完成：</p><pre><code># scalex 和 scaley 分别对应 x 轴和 y 轴缩放系数def scale(P, scalex, scaley):  # 2 维缩放矩阵  S = np.array([[scalex, 0],                [0, scaley]])  return S.dot(P)plt.figure(figsize=(7,7))plt.xlim(-2, 2)plt.ylim(-2, 2)plt.title('Scale', fontsize=16)plt.fill(P[0], P[1], facecolor='r', alpha=0.5)for i in range(1,5,1):    rr = scale(P, 1/i, 1/i)    rr = rotate(rr, -i*45) # 为了查看缩放效果，同时进行旋转    plt.fill(rr[0], rr[1], alpha=1) </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/scale.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/scale.png" alt="scale"></a></p><p>矩阵缩放变换</p><h4 id="1-14-1-3-镜像"><a href="#1-14-1-3-镜像" class="headerlink" title="1.14.1.3. 镜像"></a>1.14.1.3. 镜像</h4><p>所谓镜像，也即关于某根线进行对称映射。</p><pre><code># x 轴镜像def xmirror(P):    MX = np.array([[1, 0],                   [0, -1]])    return MX.dot(P)# y 轴镜像def ymirror(P):    MY = np.array([[-1, 0],                   [0, 1]])    return MY.dot(P)# 关于 y=x 镜像def xymirror(P):    XY = np.array([[0, 1],                   [1, 0]])    return XY.dot(P)# 关于 y=-x 镜像def nxymirror(P):    XY = np.array([[0, -1],                   [-1, 0]])    return XY.dot(P)# 关于原点镜像def omirror(P):    XY = np.array([[-1, 0],                   [0, -1]])    return XY.dot(P)</code></pre><p>使用以上镜像函数生成一组效果图：</p><pre><code>dic =  {'XMirror'  : xmirror(P),        'YMirror'  : ymirror(P),        'Y=x Mirror' : xymirror(P),        'Y=-x Mirror' : nxymirror(P),        'OriginMirror'  : omirror(P)        }# 调整坐标轴位置def set_axis(plt):    ax = plt.gca()    ax.spines['left'].set_color('none')    ax.spines['top'].set_color('none')    ax.xaxis.set_ticks_position('bottom')    ax.spines['bottom'].set_position(('data', 0))    ax.yaxis.set_ticks_position('right')    ax.spines['right'].set_position(('data', 0))    plt.xlim(-2, 2)    plt.ylim(-2, 2)    plt.xticks([-2,-1,0,1,2])    plt.yticks([-2,-1,0,1,2])index = 0plt.figure(figsize=(12, 8))for i in dic:    plt.subplot(2,3,index+1)    plt.title(i, fontsize=16)    set_axis(plt)    plt.fill(P[0], P[1], facecolor='r', alpha=0.5)    T = dic[i]    plt.fill(T[0], T[1], facecolor='g', alpha=0.5)    index += 1</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/mirror.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/mirror.png" alt="mirror"></a></p><p>矩阵镜像变换</p><h4 id="1-14-1-4-斜切"><a href="#1-14-1-4-斜切" class="headerlink" title="1.14.1.4. 斜切"></a>1.14.1.4. 斜切</h4><p>图像斜切是一种变形：</p><pre><code>def oblique(P, shearx, sheary):    S = np.array([[1, shearx],                  [sheary, 1]])    return S.dot(P)dic =  {'X Oblique'  : oblique(P, -1, 0),      'Y Oblique'  : oblique(P, 0, -1)}index = 0plt.figure(figsize=(8, 4))for i in dic:    plt.subplot(1,2,index+1)    plt.title(i, fontsize=16)    set_axis(plt)    plt.fill(P[0], P[1], facecolor='r', alpha=0.5)    M = dic[i]    plt.fill(M[0], M[1], facecolor='m', alpha=0.5)    index += 1</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/oblique.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/oblique.png" alt="oblique"></a></p><p>矩阵斜切变换</p><h4 id="1-14-1-5-位移"><a href="#1-14-1-5-位移" class="headerlink" title="1.14.1.5. 位移"></a>1.14.1.5. 位移</h4><p>位移变换不是线性变换，需要借助第三个维度的齐次坐标实现。</p><pre><code># x 和 y 参数表示在 x 和 y 轴上的位移距离def move(P, x, y):    S = np.array([[1, 0, x],                  [0, 1, y],                  [0, 0, 1]])    # 填充第三维坐标以适配矩阵点乘    P = np.vstack([P, np.ones((P.shape[1]))])    return S.dot(P)plt.figure(figsize=(8,8))set_axis(plt)plt.fill(P[0], P[1], facecolor='r', alpha=0.5)M = move(P, -1, -2)plt.fill(M[0], M[1], facecolor='m', alpha=0.5)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/move.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/move.png" alt="move"></a></p><p>矩阵位移变换</p><h4 id="1-14-1-6-组合变换"><a href="#1-14-1-6-组合变换" class="headerlink" title="1.14.1.6. 组合变换"></a>1.14.1.6. 组合变换</h4><p>组合变换即将多个变换组合在一起，例如旋转和位移。</p><p>由于所有的线性变换都是基于原点的（针对整个坐标系的），图像的处理先把原图移动到原点，然后基于原点缩放剪切处理后再移动到原位置 ，如果包含了移动，那么就要使用齐次坐标，所有的其他矩阵也要变为齐次坐标，这样可以得到复合变换矩阵，然后一次性点乘需要变换的坐标矩阵即可。</p><pre><code>def homo_rotate(P, angle):    rad = angle/180 * np.pi    P = np.vstack([P, np.ones((P.shape[1]))])    m0 = move_matrix(-P[0][0], -P[1][0])    m1 = move_matrix(P[0][0], P[1][0])    # 齐次坐标组合旋转变换    R = np.array([[np.cos(rad), -np.sin(rad), 0],                  [np.sin(rad), np.cos(rad),  0],                  [0,           0,            1]])    T = m1.dot(R).dot(m0)    return T.dot(P)P = np.array([[0.5,1.5,1.5,0.5],              [0.5,0.5,1.5,1.5]])plt.figure(figsize=(8,8))set_axis(plt)plt.fill(P[0], P[1], facecolor='r', alpha=0.5)M = homo_rotate(P, 45)plt.fill(M[0], M[1], facecolor='m', alpha=0.5)plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/mr.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/mr.png" alt="mr"></a></p><p>矩阵非原点旋转组合变换</p><p>缩放和斜切的组合变换实现如下：</p><pre><code>def homo_scale(P, scalex, scaley):    S = np.array([[scalex, 0, 0],                  [0, scaley, 0],                  [0,      0, 1]])    return S.dot(P)def homo_shear(P, shearx, sheary):    S = np.array([[1, shearx, 0],                  [sheary, 1, 0],                  [0,      0, 1]])    return S.dot(P)</code></pre><p>镜像变换的基准线如果通过原点，那么无需移动到原点，直接变换即可。</p><h3 id="1-14-2-简单图像处理"><a href="#1-14-2-简单图像处理" class="headerlink" title="1.14.2. 简单图像处理"></a>1.14.2. 简单图像处理</h3><p>一个图像由若干个像素组成，rows * cols 就是像素数。以著名的手写图片数据集 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a> 为例：</p><pre><code>TEST SET IMAGE FILE (t10k-images-idx3-ubyte):[offset] [type]          [value]          [description]0000     32 bit integer  0x00000803(2051) magic number0004     32 bit integer  10000            number of images0008     32 bit integer  28               number of rows0012     32 bit integer  28               number of columns0016     unsigned byte   ??               pixel0017     unsigned byte   ??               pixel........Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</code></pre><p>这里使用 t10k-images-idx3-ubyte 数据集，它的格式如上所示，一共有 1W 张图片，每个图片有 28*28 = 784 个像素，每个像素占用 1字节，值在 [0-255] 之间，0 表示白色背景，其他值表示灰度。</p><pre><code>import structdef load_mnist(fname):    with open(fname, 'rb') as imgpath:        magic, num, rows, cols = struct.unpack('&gt;IIII', imgpath.read(16))        print("image number:", num)        print("image rows:", rows)        print("image columns:", cols)        images = np.fromfile(imgpath, dtype=np.uint8)    return images.reshape(num, rows * cols), rows, cols</code></pre><p>使用 struct 模块读取文件头部，并返回 images 数组，shape 为 (10000,784)，rows 和 cols 为 28。</p><p>使用 images[0] 这一行数据，并转换为 shape 为 (28,28) 的二维像素数组 img0。</p><pre><code>images,rows,cols  = load_mnist('t10k-images.idx3-ubyte')img0 = images[0].reshape(28, 28)</code></pre><p>接下来使用 numpy 提供的各类函数，对数组进行操作，并使用 matplotlib 作图，比较它们的不同效果：</p><pre><code>def xrotate(img0, step=1):    splits = np.hsplit(img0, [step])    return np.hstack((splits[1], splits[0]))def yrotate(img0, step=1):    splits = np.vsplit(img0, [step])    return np.vstack((splits[1], splits[0]))dic =  {'Original'  : img0,        'Transpose' : img0.transpose(),        'SwapXY'    : np.swapaxes(img0, 0, 1),        'HalfRows'  : img0[0:int(cols/2+1)],        'HalfCols'  : img0[:, 0:int(rows/2+1)],        'ReverseX'  : img0[:, ::-1],        'ReverseY'  : img0[::-1, :],        'ReverseXY' : img0[::-1, ::-1],        'Leftupper' : img0[0:int(cols/2+1), 0:int(rows/2+1)],        'Rightlower': img0[int(cols/2+1):, int(rows/2+1):],        'CompressX' : img0[:, ::2],        'CompressY' : img0[::2, :],        'Bolded'    : (img0 &gt; 0) * 255,        'Lighted'   : img0 &gt;&gt; 7,        'Reverse'   : 255 - img0,        'XRotate'   : xrotate(img0, cols &gt;&gt; 1), # 向右平移 1/2 宽        'YRotate'   : yrotate(img0, rows &gt;&gt; 1), # 向上平移 1/2 高        'XYRotate'  : yrotate(xrotate(img0, cols &gt;&gt; 1), rows &gt;&gt; 1), # 右上平移 1/2宽高        }index = 0plt.figure(figsize=(12, 6))for i in dic:    plt.subplot(2,5,index+1)    plt.title(i, fontsize=16)    plt.imshow(dic[i], cmap='binary')    index += 1plt.show()</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/mnist.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/mnist.png" alt="mnist"></a></p><p>NumPy 图片操作示例</p><h3 id="1-14-3-常规图像处理"><a href="#1-14-3-常规图像处理" class="headerlink" title="1.14.3. 常规图像处理"></a>1.14.3. 常规图像处理</h3><p>通常不会直接使用 NumPy 来作为图像处理工具，但是使用 NumPy 操作图像数据却是最直观了解和学习 NumPy 各类操作的方式。</p><p>这里使用256*256的 Lena.png 样图。</p><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/lena.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/lena.png" alt="lean smaple"></a></p><p>标准 Lena 样图(256x256x3)</p><p>对于普通像素图像的加载，通常借助 matplotlib 模块：</p><pre><code>img = plt.imread("lena.png")print(type(img).__name__)print(img.shape)&gt;&gt;&gt;ndarray(256, 256, 3)</code></pre><p>令人欣喜的是 plt.imread 返回的是 ndarray 对象，它的形状 (256, 256, 3) 分别表示 x,y 轴的像素数为 256，图像通道数为 3，通常为 RGB，如果为 4 通常为 RGBA。</p><h4 id="1-14-3-1-裁剪图片"><a href="#1-14-3-1-裁剪图片" class="headerlink" title="1.14.3.1. 裁剪图片"></a>1.14.3.1. 裁剪图片</h4><p>水平裁剪相当于取特定的行数：</p><pre><code>mpl.image.imsave('horizontal.png', img[:128, :,:]) # 水平裁剪 </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/horizontal.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/horizontal.png" alt="horizontal smaple"></a></p><p>水平裁剪</p><p>垂直裁剪相当于取特定的列数：</p><pre><code>mpl.image.imsave('vertical.png', img[:, :128])     # 垂直裁剪 </code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/vertical.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/vertical.png" alt="vertical smaple"></a></p><p>垂直裁剪</p><h4 id="1-14-3-2-分离通道"><a href="#1-14-3-2-分离通道" class="headerlink" title="1.14.3.2. 分离通道"></a>1.14.3.2. 分离通道</h4><p>分离通道是对第三维 RGB 数据进行操作，分离 R 通道相当于把 G,B 通道赋值为0。</p><pre><code>R,G,B = img.copy(),img.copy(),img.copy()R[:,:,[1,2]] = 0G[:,:,[0,2]] = 0B[:,:,[0,1]] = 0# R 通道mpl.image.imsave('R.png', R)# RGB 三通道图片保存到在一个张图片中mpl.image.imsave('RGB.png', np.hstack([R,G,B]))</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/RGB.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/RGB.png" alt="RGB"></a></p><p>RGB 分离通道</p><h4 id="1-14-3-3-灰阶"><a href="#1-14-3-3-灰阶" class="headerlink" title="1.14.3.3. 灰阶"></a>1.14.3.3. 灰阶</h4><p>如何把彩色图片转换成灰度图？每个彩色像素由三通道（R,G,B）的强度描述，如何把一个像素映射到一个单独的数字作为的灰度值？通常有三种算法：</p><ul><li>lightness方法：是取最突触颜色和最不突出颜色的平均值：(max(R, G, B) + min(R, G, B)) / 2。</li><li>average方法：最简单取R,G,B的平均值：(R + G + B) / 3。</li><li>luminosity方法：它通过加权平均来解释人类感知。我们对绿色比其他颜色更敏感，所以绿色加权最大。其计算公式为亮度为0.21 R + 0.72 G + 0.07 B。</li></ul><p>这里使用第三种方式转换为 8 bits 的灰度图片。</p><pre><code>rgb2grey = [0.21, 0.72, 0.07]grey = img * rgb2grey   # 权重相乘print(grey.shape)grey = grey.sum(axis=2) # 求和后变为 256*256 二维数组print(grey.shape)mpl.image.imsave('grey.png', grey, cmap='Greys')  # 灰度形式输出&gt;&gt;&gt;(256, 256, 3)(256, 256)</code></pre><p><a href="https://mlhowto.readthedocs.io/en/latest/_images/grey.png"><img src="https://mlhowto.readthedocs.io/en/latest/_images/grey.png" alt="grey"></a></p><p>灰度图</p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 语法基础</title>
      <link href="/2020/01/03/20200103-python-basis/"/>
      <url>/2020/01/03/20200103-python-basis/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1. 数值类型"></a>1. 数值类型</h2><h3 id="1-1-数字Numbers"><a href="#1-1-数字Numbers" class="headerlink" title="1.1 数字Numbers"></a>1.1 数字Numbers</h3><p>Python 3支持<strong>int、float、bool、complex</strong>（复数）。在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。内置的<code>type()</code>函数可以用来查询变量所指的对象类型。此外还可以用 isinstance 来判断：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">+</span><span class="token number">3j</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bool'</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'complex'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用del语句删除一些对象引用。如<code>del var_a, var_b</code></p><p><strong>注意：</strong> </p><blockquote><p>1). Python可以同时为多个变量赋值，如a, b = 1, 2。<br>2). 一个变量可以通过赋值指向不同类型的对象。<br>3). 到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。<br>4). 在混合计算时，Python会把整型转换成为浮点数。<br>5). type()不会认为子类是一种父类类型。isinstance()会认为子类是一种父类类型。</p></blockquote><h4 id="1-1-1-整型-int"><a href="#1-1-1-整型-int" class="headerlink" title="1.1.1 整型 int"></a>1.1.1 整型 int</h4><p><code>int</code>可以存储任意大的数：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  ival <span class="token operator">=</span> <span class="token number">17239871</span><span class="token operator">>></span><span class="token operator">></span>  ival <span class="token operator">**</span> <span class="token number">6</span><span class="token number">26254519291092456596965462913230729701102721</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-1-2-浮点型-float"><a href="#1-1-2-浮点型-float" class="headerlink" title="1.1.2 浮点型 float"></a>1.1.2 浮点型 float</h4><p>浮点数使用Python的<code>float</code>类型。每个数都是双精度（占8个字节，64位）的值，其中52位表示底，11位表示指数，剩下的一位表示符号。也可以用科学计数法表示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  fval <span class="token operator">=</span> <span class="token number">7.243</span><span class="token operator">>></span><span class="token operator">></span>  fval2 <span class="token operator">=</span> <span class="token number">6.78e-5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不能得到整数的除法会得到浮点数：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token number">1.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要获得C-风格的整除（去掉小数部分），可以使用底除运算符//：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  <span class="token number">3</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-1-3-复数-complex"><a href="#1-1-3-复数-complex" class="headerlink" title="1.1.3  复数 complex"></a>1.1.3  复数 complex</h4><p>复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。</p><h4 id="1-1-4-布尔类型-bool"><a href="#1-1-4-布尔类型-bool" class="headerlink" title="1.1.4 布尔类型 bool"></a>1.1.4 布尔类型 bool</h4><p>Python中的布尔值有两个，True和False（注意：首字母都是大写，与C++、JavaScript中的小写有所不同）。比较和其它条件表达式可以用True和False判断。布尔值可以与and，or和not结合使用：</p><p>总结一下为假的情况有：</p><ul><li>None, False</li><li>数值中的0, 0.0, 0j(虚数), Decimal(0), Fraction(0, 1)</li><li>空字符串(‘’)、空元组(())、空列表([])</li><li>空字典({})、空集合(set())</li><li>对象默认为True，除非它有bool()方法且返回False或len()方法且返回0.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  <span class="token boolean">True</span> <span class="token operator">and</span> <span class="token boolean">True</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span>  <span class="token boolean">False</span> <span class="token operator">or</span> <span class="token boolean">True</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表列举了布尔运算的结果，优先级为升序：</p><table><thead><tr><th align="center">运算</th><th align="center">表达式</th><th align="center">结果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">或运算</td><td align="center">x or y</td><td align="center">如果x为False则取决于y；如果x为True则不考虑y</td><td align="center">（1）</td></tr><tr><td align="center">与运算</td><td align="center">x and y</td><td align="center">如果x为False则不考虑y；如果x为True则取决于y</td><td align="center">（2）</td></tr><tr><td align="center">非运算</td><td align="center">not x</td><td align="center">如果x为False则为True，否则为False</td><td align="center">（2）</td></tr></tbody></table><p>说明：<br>（1）or 是一种“短路运算符”，只有当第一个为False时才去验证第二个。即：两个变量只要有一个为True则为True。<br>（2）and也是种“短路运算符”，只有当第一个为True时才去验证第二个。即：两个变量都为True时结果才为True。<br>（3）not的优先级比非布尔运算符底，所以not a == b解释为not (a == b)，并且a == not b是语法错误。</p><h3 id="1-2-字符串-str"><a href="#1-2-字符串-str" class="headerlink" title="1.2 字符串 str"></a>1.2 字符串 str</h3><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token string">'one way of writing a string'</span>b <span class="token operator">=</span> <span class="token string">"another way"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于有换行符的字符串，可以使用三引号，’’’或”””都行：</p><pre class="line-numbers language-python"><code class="language-python">c <span class="token operator">=</span> <span class="token triple-quoted-string string">"""This is a longer string thatspans multiple lines"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>字符串<code>c</code>实际包含四行文本，”””后面和lines后面的换行符。可以用<code>count</code>方法计算<code>c</code>中的新的行：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  c<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Python的字符串是不可变的，不能修改字符串：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token string">'this is a string'</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'f'</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>TypeError                                 Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython<span class="token operator">-</span>input<span class="token number">-57</span><span class="token operator">-</span><span class="token number">5ca625d1e504</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'f'</span>TypeError<span class="token punctuation">:</span> <span class="token string">'str'</span> object does <span class="token operator">not</span> support item assignment<span class="token operator">>></span><span class="token operator">></span>  b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">,</span> <span class="token string">'longer string'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>  b<span class="token string">'this is a longer string'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过以上的操作，变量<code>a</code>并没有被修改：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a<span class="token string">'this is a string'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>许多Python对象使用<code>str</code>函数可以被转化为字符串：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token number">5.6</span><span class="token operator">>></span><span class="token operator">></span>  s <span class="token operator">=</span> str<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>  <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token number">5.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>字符串是一个序列的Unicode字符，因此可以像其它序列，比如列表和元组（下一章会详细介绍两者）一样处理：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  s <span class="token operator">=</span> <span class="token string">'python'</span><span class="token operator">>></span><span class="token operator">></span>  list<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token string">'pyt'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法<code>s[:3]</code>被称作切片，适用于许多Python序列。</p><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-python-basis.assets/o99aU.png" alt="img"></p><p>加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p><pre class="line-numbers language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'Runoob'</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 输出字符串</span>Runoob<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 输出第一个到倒数第二个的所有字符</span>Runoo<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 输出字符串第一个字符</span>R<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出从第三个开始到第五个的字符</span>noo <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 输出从第三个开始的后的所有字符</span>noob<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 输出字符串两次</span>RunoobRunoob<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"TEST"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 连接字符串</span>RunoobTEST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ru\noob'</span><span class="token punctuation">)</span>Ruoob<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token string">'Ru\noob'</span><span class="token punctuation">)</span>Ru\noob<span class="token operator">>></span><span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。</p><p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word <span class="token operator">=</span> <span class="token string">'Python'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>P n<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>n P<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p>注意：</p><ul><li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li><li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>4、Python中的字符串不能改变。</li></ul><p>将两个字符串合并，会产生一个新的字符串：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token string">'this is the first half '</span><span class="token operator">>></span><span class="token operator">></span>  b <span class="token operator">=</span> <span class="token string">'and this is the second half'</span> <span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">+</span> b<span class="token string">'this is the first half and this is the second half'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串的模板化或格式化，是另一个重要的主题。Python 3拓展了此类的方法，这里只介绍一些。字符串对象有<code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  template <span class="token operator">=</span> <span class="token string">'{0:.2f} {1:s} are worth US${2:d}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这个字符串中，</p><ul><li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li><li><code>{1:s}</code>表示格式化第二个参数为字符串。</li><li><code>{2:d}</code>表示格式化第三个参数为一个整数。</li></ul><p>要替换参数为这些格式化的参数，我们传递<code>format</code>方法一个序列：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  template<span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">4.5560</span><span class="token punctuation">,</span> <span class="token string">'Argentine Pesos'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'4.56 Argentine Pesos are worth US$1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符串格式化是一个很深的主题，有多种方法和大量的选项，可以控制字符串中的值是如何格式化的。推荐参阅Python官方文档。</p><h4 id="1-2-1-类型转换"><a href="#1-2-1-类型转换" class="headerlink" title="1.2.1 类型转换"></a>1.2.1 类型转换</h4><p>str、bool、int和float也是函数，可以用来转换类型：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  s <span class="token operator">=</span> <span class="token string">'3.14159'</span><span class="token operator">>></span><span class="token operator">></span>  fval <span class="token operator">=</span> float<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>  type<span class="token punctuation">(</span>fval<span class="token punctuation">)</span>float<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>fval<span class="token punctuation">)</span><span class="token number">3</span><span class="token operator">>></span><span class="token operator">></span>  bool<span class="token punctuation">(</span>fval<span class="token punctuation">)</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span>  bool<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-列表-list"><a href="#1-3-列表-list" class="headerlink" title="1.3 列表 list"></a>1.3 列表 list</h3><p>List（列表）是 Python 中使用最频繁的数据类型。列表是写在方括号[]之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同它支持数字，字符串甚至可以包含列表（所谓嵌套）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'him'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'her'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'him'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'her'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。</p><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p><img src="/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-python-basis.assets/list_slicing1.png" alt="img"></p><p>列表还支持串联操作，加号 + 是列表连接运算符，星号 * 是重复操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>```与Python字符串不一样的是，列表中的元素是可以改变的：```python<span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 删除</span><span class="token operator">>></span><span class="token operator">></span>  a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>```<span class="token operator">**</span>要点：<span class="token operator">**</span><span class="token operator">></span> <span class="token number">1</span>、List写在方括号之间，元素用逗号隔开。<span class="token operator">></span> <span class="token number">2</span>、和字符串一样，list可以被索引和切片。<span class="token operator">></span> <span class="token number">3</span>、List可以使用<span class="token operator">+</span>操作符进行拼接。<span class="token operator">></span> <span class="token number">4</span>、星号 <span class="token operator">*</span> 是重复操作。<span class="token operator">></span> <span class="token number">5</span>、List中的元素是可以改变的。<span class="token comment" spellcheck="true">#### 1.3.1 常用方法 </span><span class="token comment" spellcheck="true">##### 1.3.1.1 更新列表 list.append(obj)</span>append<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法向列表的尾部添加一个新的元素。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'Baidu'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"更新后的列表 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>更新后的列表 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.2 list.count(obj)</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法用于统计某个元素在列表中出现的次数。```python<span class="token operator">>></span><span class="token operator">></span> aList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"123 元素个数 : "</span><span class="token punctuation">,</span> aList<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">123</span> 元素个数 <span class="token punctuation">:</span>  <span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Runoob 元素个数 : "</span><span class="token punctuation">,</span> aList<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'Runoob'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Runoob 元素个数 <span class="token punctuation">:</span>  <span class="token number">1</span>```统计字符出现的个数或列表内出现的元素次数等也可以用 Counter。一个 Counter 是一个 dict 的子类，用于计数可哈希对象。```python<span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'sadasfas'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'s'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'su'</span><span class="token punctuation">,</span><span class="token string">'bu'</span><span class="token punctuation">,</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'bu'</span><span class="token punctuation">,</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'bu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'bu'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'su'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token string">'sadasfas'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#添加</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'bu'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'su'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>```<span class="token comment" spellcheck="true">##### 1.3.1.3 list.extend(seq)</span>extend<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。```python<span class="token comment" spellcheck="true"># 语言列表</span><span class="token operator">>></span><span class="token operator">></span> language <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'French'</span><span class="token punctuation">,</span> <span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'German'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 元组</span><span class="token operator">>></span><span class="token operator">></span> language_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Spanish'</span><span class="token punctuation">,</span> <span class="token string">'Portuguese'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 集合</span><span class="token operator">>></span><span class="token operator">></span> language_set <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Chinese'</span><span class="token punctuation">,</span> <span class="token string">'Japanese'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 添加元组元素到列表末尾</span><span class="token operator">>></span><span class="token operator">></span> language<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>language_tuple<span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'新列表: '</span><span class="token punctuation">,</span> language<span class="token punctuation">)</span>新列表<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'French'</span><span class="token punctuation">,</span> <span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'German'</span><span class="token punctuation">,</span> <span class="token string">'Spanish'</span><span class="token punctuation">,</span> <span class="token string">'Portuguese'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加集合元素到列表末尾</span><span class="token operator">>></span><span class="token operator">></span> language<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>language_set<span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'新列表: '</span><span class="token punctuation">,</span> language<span class="token punctuation">)</span>新列表<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'French'</span><span class="token punctuation">,</span> <span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'German'</span><span class="token punctuation">,</span> <span class="token string">'Spanish'</span><span class="token punctuation">,</span> <span class="token string">'Portuguese'</span><span class="token punctuation">,</span> <span class="token string">'Japanese'</span><span class="token punctuation">,</span> <span class="token string">'Chinese'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.4 list.index(obj)</span>index<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于从列表中找出某个值第一个匹配项的索引位置。该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。index<span class="token punctuation">(</span><span class="token punctuation">)</span>方法语法：```python<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">.</span>index<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>``````python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'Runoob 索引值为'</span><span class="token punctuation">,</span> list1<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'Runoob'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Runoob 索引值为 <span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'Taobao 索引值为'</span><span class="token punctuation">,</span> list1<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'Taobao'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Taobao 索引值为 <span class="token number">2</span>```<span class="token comment" spellcheck="true">##### 1.3.1.5 list.insert(index, obj)</span>insert<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于将指定对象插入列表的指定位置。该方法没有返回值，但会在列表指定位置插入对象。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'列表插入元素后为 : '</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表插入元素后为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.6 list.pop([index=-1])</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表现在为 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表现在为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表现在为 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表现在为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.7 list.remove(obj)</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于移除列表中某个值的第一个匹配项。该方法没有返回值但是会移除列表中的某个值的第一个匹配项。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'Taobao'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表现在为 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表现在为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'Baidu'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表现在为 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表现在为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.8 list.reverse()</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于反向列表中元素。该方法没有返回值，但是会对列表的元素进行反向排序。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表反转后: "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表反转后<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Baidu'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.9 list.sort(key=None, reverse=False)</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。该方法没有返回值，但是会对列表的对象进行排序。```python<span class="token operator">>></span><span class="token operator">></span> aList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Facebook'</span><span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">></span> aList<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span> <span class="token string">"List : "</span><span class="token punctuation">,</span> aList<span class="token punctuation">)</span>List <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Facebook'</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">]</span>``````python<span class="token comment" spellcheck="true"># 列表</span><span class="token operator">>></span><span class="token operator">></span> vowels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 降序</span><span class="token operator">>></span><span class="token operator">></span> vowels<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出结果</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span> <span class="token string">'降序输出:'</span><span class="token punctuation">,</span> vowels <span class="token punctuation">)</span>降序输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.3.1.10 list.clear()</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于清空列表，类似于 <span class="token keyword">del</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>。该方法没有返回值。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list1<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"列表清空后 : "</span><span class="token punctuation">,</span> list1<span class="token punctuation">)</span>列表清空后 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span>```调用 clear<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法后，已经赋值给其它变量的列表也会被清空。```python<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'一'</span><span class="token punctuation">,</span><span class="token string">'二'</span><span class="token punctuation">,</span><span class="token string">'三'</span><span class="token punctuation">,</span><span class="token string">'四'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'大写数字'</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token string">'大写数字'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'一'</span><span class="token punctuation">,</span> <span class="token string">'二'</span><span class="token punctuation">,</span> <span class="token string">'三'</span><span class="token punctuation">,</span> <span class="token string">'四'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token string">'大写数字'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> ```<span class="token operator">></span> 通过 clear<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，remove<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，append<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法等改变列表的，相应的已经赋值给其它变量的列表也会被清空。<span class="token comment" spellcheck="true">##### 1.3.1.11 list.copy()</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于复制列表，类似于 a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>。返回复制后的新列表。```python<span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list2 <span class="token operator">=</span> list1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"list2 列表: "</span><span class="token punctuation">,</span> list2<span class="token punctuation">)</span>list2 列表<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">#### 1.3.2 Python列表脚本操作符</span>列表对 <span class="token operator">+</span> 和  <span class="token operator">*</span> 的操作符与字符串相似。<span class="token operator">+</span> 号用于组合列表，<span class="token operator">*</span> 号用于重复列表。如下所示：<span class="token operator">|</span> Python 表达式          <span class="token operator">|</span> 结果          <span class="token operator">|</span> 描述             <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span><span class="token operator">|</span> len<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token operator">|</span> <span class="token number">3</span>             <span class="token operator">|</span> 长度            <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>  <span class="token operator">|</span> 组合      <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">'Hi!'</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>   <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">'Hi!'</span><span class="token punctuation">,</span> <span class="token string">'Hi!'</span><span class="token punctuation">,</span> <span class="token string">'Hi!'</span><span class="token punctuation">,</span> <span class="token string">'Hi!'</span><span class="token punctuation">]</span> <span class="token operator">|</span> 重复      <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">3</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>   <span class="token operator">|</span> <span class="token boolean">True</span>      <span class="token operator">|</span> 元素是否存在于列表中 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>   <span class="token operator">|</span> 迭代    <span class="token operator">|</span><span class="token comment" spellcheck="true">### 1.4 元组 tuple</span>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <span class="token punctuation">(</span><span class="token punctuation">)</span> 里，元素之间用逗号隔开。元组中的元素类型也可以不相同：实例```python<span class="token operator">>></span><span class="token operator">></span> tuple <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token string">'abcd'</span><span class="token punctuation">,</span> <span class="token number">786</span> <span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">70.2</span>  <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> tinytuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 输出完整元组</span><span class="token punctuation">(</span><span class="token string">'abcd'</span><span class="token punctuation">,</span> <span class="token number">786</span><span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">70.2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 输出元组的第一个元素</span>abcd<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 输出从第二个元素开始到第三个元素</span><span class="token punctuation">(</span><span class="token number">786</span><span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 输出从第三个元素开始的所有元素</span><span class="token punctuation">(</span><span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">70.2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tinytuple <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出两次元组</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tuple <span class="token operator">+</span> tinytuple<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 连接元组</span><span class="token punctuation">(</span><span class="token string">'abcd'</span><span class="token punctuation">,</span> <span class="token number">786</span><span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">70.2</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span><span class="token punctuation">)</span>```元组与字符串类似，可以被索引且下标索引从<span class="token number">0</span>开始，<span class="token operator">-</span><span class="token number">1</span> 为从末尾开始的位置。也可以进行截取（）。其实，可以把字符串看作一种特殊的元组。 ```python<span class="token operator">>></span><span class="token operator">></span> tup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>tup<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">1</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>tup<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> tup1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">34.56</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> tup2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 以下修改元组元素操作是非法的。</span><span class="token comment" spellcheck="true"># tup1[0] = 100</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># 创建一个新的元组</span><span class="token operator">>></span><span class="token operator">></span> tup3 <span class="token operator">=</span> tup1 <span class="token operator">+</span> tup2<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span>tup3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">34.56</span><span class="token punctuation">,</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span>```虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。构造包含 <span class="token number">0</span> 个或 <span class="token number">1</span> 个元素的元组比较特殊，所以有一些额外的语法规则：```python<span class="token operator">>></span><span class="token operator">></span> tup1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 空元组</span><span class="token operator">>></span><span class="token operator">></span> tup2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 一个元素，需要在元素后添加逗号</span>```string、list 和 tuple 都属于 sequence（序列）。<span class="token operator">**</span>注意：<span class="token operator">**</span><span class="token operator">-</span> <span class="token number">1</span>、与字符串一样，元组的元素不能修改。<span class="token operator">-</span> <span class="token number">2</span>、元组也可以被索引和切片，方法一样。<span class="token operator">-</span> <span class="token number">3</span>、注意构造包含 <span class="token number">0</span> 或 <span class="token number">1</span> 个元素的元组的特殊语法规则。<span class="token operator">-</span> <span class="token number">4</span>、元组也可以使用<span class="token operator">+</span>操作符进行拼接。<span class="token comment" spellcheck="true">#### 1.4.1 元组内置函数</span>Python元组包含了以下内置函数<span class="token operator">|</span> 序号 <span class="token operator">|</span> 方法及描述    <span class="token operator">|</span> 实例                        <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">1</span>    <span class="token operator">|</span> len<span class="token punctuation">(</span>tuple<span class="token punctuation">)</span> 计算元组元素个数。     <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> tuple1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>tuple1<span class="token punctuation">)</span> <span class="token number">3</span> <span class="token operator">>></span><span class="token operator">></span> ` <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">2</span>    <span class="token operator">|</span> max<span class="token punctuation">(</span>tuple<span class="token punctuation">)</span> 返回元组中元素最大值。 <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> tuple2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> max<span class="token punctuation">(</span>tuple2<span class="token punctuation">)</span> <span class="token string">'8'</span> <span class="token operator">>></span><span class="token operator">></span> `      <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">3</span>    <span class="token operator">|</span> min<span class="token punctuation">(</span>tuple<span class="token punctuation">)</span> 返回元组中元素最小值。 <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> tuple2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> min<span class="token punctuation">(</span>tuple2<span class="token punctuation">)</span> <span class="token string">'4'</span> <span class="token operator">>></span><span class="token operator">></span> `      <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">4</span>    <span class="token operator">|</span> tuple<span class="token punctuation">(</span>seq<span class="token punctuation">)</span> 将列表转换为元组。     <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> list1<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">></span> tuple1<span class="token operator">=</span>tuple<span class="token punctuation">(</span>list1<span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> tuple1 <span class="token punctuation">(</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Baidu'</span><span class="token punctuation">)</span>` <span class="token operator">|</span><span class="token comment" spellcheck="true">### 1.5 字典 dict</span>字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token operator">></span>value<span class="token punctuation">)</span>对用冒号<span class="token punctuation">(</span><span class="token operator">**</span><span class="token punctuation">:</span><span class="token operator">**</span><span class="token punctuation">)</span>分割，每个对之间用逗号<span class="token punctuation">(</span><span class="token operator">**</span><span class="token punctuation">,</span><span class="token operator">**</span><span class="token punctuation">)</span>分割，整个字典包括在花括号<span class="token punctuation">(</span><span class="token operator">**</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">**</span>中 <span class="token punctuation">,</span>格式如下所示：```pythond <span class="token operator">=</span> <span class="token punctuation">{</span>key1 <span class="token punctuation">:</span> value1<span class="token punctuation">,</span> key2 <span class="token punctuation">:</span> value2 <span class="token punctuation">}</span>```键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。一个简单的字典实例：```pythondict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Alice'</span><span class="token punctuation">:</span> <span class="token string">'2341'</span><span class="token punctuation">,</span> <span class="token string">'Beth'</span><span class="token punctuation">:</span> <span class="token string">'9102'</span><span class="token punctuation">,</span> <span class="token string">'Cecil'</span><span class="token punctuation">:</span> <span class="token string">'3258'</span><span class="token punctuation">}</span>```也可如此创建字典：```python<span class="token operator">>></span><span class="token operator">></span> dict1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'abc'</span><span class="token punctuation">:</span> <span class="token number">456</span> <span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'abc'</span><span class="token punctuation">:</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">98.6</span><span class="token punctuation">:</span> <span class="token number">37</span> <span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">#### 1.5.1 访问字典里的值</span>把相应的键放入到方括号中，如下实例<span class="token punctuation">:</span>```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span>  <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Name']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  Runoob<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Age']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token number">7</span>```如果用字典里没有的键访问数据，会输出错误如下：```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span>  <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Alice']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Alice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"test.py"</span><span class="token punctuation">,</span> line <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Alice']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Alice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>KeyError<span class="token punctuation">:</span> <span class="token string">'Alice'</span>```<span class="token comment" spellcheck="true">#### 1.5.2 修改字典</span>向字典添加新内容的方法是增加新的键<span class="token operator">/</span>值对，修改或删除已有键<span class="token operator">/</span>值对如下实例<span class="token punctuation">:</span>```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span>  <span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span>               <span class="token comment" spellcheck="true"># 更新 Age </span><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span><span class="token string">'School'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"菜鸟教程"</span>  <span class="token comment" spellcheck="true"># 添加信息   </span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Age']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token number">8</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['School']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'School'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dict<span class="token punctuation">[</span><span class="token string">'School'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  菜鸟教程```<span class="token comment" spellcheck="true">#### 1.5.3 删除字典元素</span>能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用<span class="token keyword">del</span>命令，如下实例：```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 删除键 'Name' </span><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 清空字典 </span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dict         <span class="token comment" spellcheck="true"># 删除字典  </span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Age']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['School']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'School'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>```但这会引发一个异常，因为用执行 <span class="token keyword">del</span> 操作后字典不再存在：```Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"test.py"</span><span class="token punctuation">,</span> line <span class="token number">9</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Age']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>TypeError<span class="token punctuation">:</span> <span class="token string">'type'</span> object <span class="token keyword">is</span> <span class="token operator">not</span> subscriptable```<span class="token comment" spellcheck="true">#### 1.5.3 字典键的特性</span>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。两个重要的点需要记住：<span class="token number">1</span>）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'小菜鸟'</span><span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Name']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  小菜鸟```<span class="token number">2</span>）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span>  <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dict['Name']: "</span><span class="token punctuation">,</span> dict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"test.py"</span><span class="token punctuation">,</span> line <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span>TypeError<span class="token punctuation">:</span> unhashable type<span class="token punctuation">:</span> <span class="token string">'list'</span>```<span class="token comment" spellcheck="true">#### 1.5.4 内置函数：</span><span class="token operator">|</span>  序号  <span class="token operator">|</span>     函数及描述      <span class="token operator">|</span>           实例               <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">1</span>    <span class="token operator">|</span> len<span class="token punctuation">(</span>dict<span class="token punctuation">)</span> 计算字典元素个数，即键的总数。     <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>dict<span class="token punctuation">)</span> <span class="token number">3</span>` <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">2</span>    <span class="token operator">|</span> str<span class="token punctuation">(</span>dict<span class="token punctuation">)</span> 输出字典，以可打印的字符串表示。 <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>dict<span class="token punctuation">)</span> <span class="token string">"{'Name': 'Runoob', 'Class': 'First', 'Age': 7}"</span>` <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">3</span>    <span class="token operator">|</span> type<span class="token punctuation">(</span>variable<span class="token punctuation">)</span> 返回输入的变量类型，如果变量是字典就返回字典类型。 <span class="token operator">|</span> `<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>dict<span class="token punctuation">)</span> ` <span class="token operator">|</span><span class="token comment" spellcheck="true">#### 1.5.5 内置方法：</span><span class="token comment" spellcheck="true">##### 1.5.5.1 dict.clear()</span>Python 字典 clear<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于删除字典内所有元素。该函数没有任何返回值。```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Zara'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"字典长度 : %d"</span> <span class="token operator">%</span>  len<span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span>字典长度 <span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"字典删除后长度 : %d"</span> <span class="token operator">%</span>  len<span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span>字典删除后长度 <span class="token punctuation">:</span> <span class="token number">0</span>```<span class="token comment" spellcheck="true">##### 1.5.5.2 dict.copy()</span>Python 字典 copy<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数返回一个字典的浅复制。返回一个字典的浅复制。```python<span class="token operator">>></span><span class="token operator">></span> dict1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict2 <span class="token operator">=</span> dict1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"新复制的字典为 : "</span><span class="token punctuation">,</span>dict2<span class="token punctuation">)</span>新复制的字典为 <span class="token punctuation">:</span>  <span class="token punctuation">{</span><span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Class'</span><span class="token punctuation">:</span> <span class="token string">'First'</span><span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">##### 1.5.5.3 dict.fromkeys()</span>Python 字典 fromkeys<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值。该方法返回一个新字典。```python<span class="token operator">>></span><span class="token operator">></span> seq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> dict<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"新的字典为 : %s"</span> <span class="token operator">%</span>  str<span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span>新的字典为 <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'age'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> dict<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"新的字典为 : %s"</span> <span class="token operator">%</span>  str<span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span>新的字典为 <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">##### 1.5.5.4 dict.get(key, default=None)</span>Python 字典 get<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数返回指定键的值，如果值不在字典中返回默认值。返回指定键的值，如果值不在字典中返回默认值 None。```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Age 值为 : %s"</span> <span class="token operator">%</span>  dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Age'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Age 值为 <span class="token punctuation">:</span> <span class="token number">27</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Sex 值为 : %s"</span> <span class="token operator">%</span>  dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Sex'</span><span class="token punctuation">,</span> <span class="token string">"NA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Sex 值为 <span class="token punctuation">:</span> NA```<span class="token comment" spellcheck="true">##### 1.5.5.5 key in dict</span>Python 字典 <span class="token keyword">in</span> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回 true，否则返回 false。而 <span class="token operator">not</span> <span class="token keyword">in</span> 操作符刚好相反，如果键在字典 dict 里返回 false，否则返回 true。<span class="token comment" spellcheck="true">##### 1.5.5.6 dict.items()</span>Python 字典 items<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法以列表返回可遍历的<span class="token punctuation">(</span>键<span class="token punctuation">,</span> 值<span class="token punctuation">)</span> 元组数组。返回可遍历的<span class="token punctuation">(</span>键<span class="token punctuation">,</span> 值<span class="token punctuation">)</span> 元组数组。```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Value : %s"</span> <span class="token operator">%</span>  dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Value <span class="token punctuation">:</span> dict_items<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Age'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Name'</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>```遍历例子：```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">":\t"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出：</span>Name <span class="token punctuation">:</span>   RunoobAge <span class="token punctuation">:</span>    <span class="token number">7</span>```<span class="token comment" spellcheck="true">##### 1.5.5.7 dict.keys()</span>Python3 字典 keys<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法返回一个可迭代对象，可以使用 list<span class="token punctuation">(</span><span class="token punctuation">)</span> 来转换为列表。<span class="token operator">**</span>注意<span class="token operator">**</span>：Python2<span class="token punctuation">.</span>x 是直接返回列表```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 转换为列表</span><span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">]</span>字典所有的键为 <span class="token punctuation">:</span> dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">,</span> <span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>```<span class="token comment" spellcheck="true">##### 1.5.5.8 dict.setdefault(key, default=None)</span>Python 字典 setdefault<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法和 get<span class="token punctuation">(</span><span class="token punctuation">)</span>方法 类似<span class="token punctuation">,</span> 如果键不已经存在于字典中，将会添加键并将值设为默认值。如果 key 在 字典中，返回对应的值。如果不在字典中，则插入 key 及设置的默认值 default，并返回 default ，default 默认值为 None。 ```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Age 键的值为 : %s"</span> <span class="token operator">%</span>  dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'Age'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">)</span>Age 键的值为 <span class="token punctuation">:</span> <span class="token number">7</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Sex 键的值为 : %s"</span> <span class="token operator">%</span>  dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'Sex'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">)</span>Sex 键的值为 <span class="token punctuation">:</span> None<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"新字典为："</span><span class="token punctuation">,</span> dict<span class="token punctuation">)</span>新字典为： <span class="token punctuation">{</span><span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Sex'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">##### 1.5.5.9 dict.update(dict2)</span>Python 字典 update<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数把字典参数 dict2 的 key<span class="token operator">/</span>value<span class="token punctuation">(</span>键<span class="token operator">/</span>值<span class="token punctuation">)</span> 对更新到字典 dict 里。该方法没有任何返回值。```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Sex'</span><span class="token punctuation">:</span> <span class="token string">'female'</span> <span class="token punctuation">}</span> <span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">.</span>update<span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"更新字典 dict : "</span><span class="token punctuation">,</span> dict<span class="token punctuation">)</span>更新字典 dict <span class="token punctuation">:</span>  <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Sex'</span><span class="token punctuation">:</span> <span class="token string">'female'</span><span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">##### 1.5.5.10 dict.values()</span>Python 字典 values<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法返回一个迭代器，可以使用 list<span class="token punctuation">(</span><span class="token punctuation">)</span> 来转换为列表，列表为字典中的所有值。```python<span class="token operator">>></span><span class="token operator">></span> dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Sex'</span><span class="token punctuation">:</span> <span class="token string">'female'</span><span class="token punctuation">,</span> <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token string">'Zara'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"字典所有值为 : "</span><span class="token punctuation">,</span>  list<span class="token punctuation">(</span>dict<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>字典所有值为 <span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'female'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Zara'</span><span class="token punctuation">]</span>```<span class="token comment" spellcheck="true">##### 1.5.5.11 pop(key[,default])</span>Python 字典 pop<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。```python<span class="token operator">>></span><span class="token operator">></span> site<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'alexa'</span><span class="token punctuation">:</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> pop_obj<span class="token operator">=</span>site<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>pop_obj<span class="token punctuation">)</span>菜鸟教程```<span class="token comment" spellcheck="true">##### 1.5.5.12 popitem()</span>Python 字典 popitem<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法随机返回并删除字典中的最后一对键和值。返回一个键值对<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>形式，按照 LIFO（Last In First Out 后进先出法） 顺序规则，即最末尾的键值对。如果字典已经为空，却调用了此方法，就报出KeyError异常。```python<span class="token operator">>></span><span class="token operator">></span> site<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'alexa'</span><span class="token punctuation">:</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> pop_obj<span class="token operator">=</span>site<span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>pop_obj<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>site<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'alexa'</span><span class="token punctuation">:</span> <span class="token number">10000</span><span class="token punctuation">}</span>```注意：    <span class="token number">1</span>、字典是一种映射类型，它的元素是键值对。    <span class="token number">2</span>、字典的关键字必须为不可变类型，且不能重复。    <span class="token number">3</span>、创建空字典使用 <span class="token punctuation">{</span> <span class="token punctuation">}</span>。<span class="token comment" spellcheck="true">### 1.6 集合</span>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。基本功能是进行成员关系测试和删除重复元素。可以使用大括号 <span class="token punctuation">{</span> <span class="token punctuation">}</span> 或者 set<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数创建集合，注意：创建一个空集合必须用 set<span class="token punctuation">(</span><span class="token punctuation">)</span> 而不是 <span class="token punctuation">{</span> <span class="token punctuation">}</span>，因为 <span class="token punctuation">{</span> <span class="token punctuation">}</span> 是用来创建一个空字典。创建格式：```pythonparame <span class="token operator">=</span> <span class="token punctuation">{</span>value01<span class="token punctuation">,</span>value02<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>或者set<span class="token punctuation">(</span>value<span class="token punctuation">)</span>``````python<span class="token operator">>></span><span class="token operator">></span> student <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token string">'Jim'</span><span class="token punctuation">,</span> <span class="token string">'Mary'</span><span class="token punctuation">,</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token string">'Rose'</span><span class="token punctuation">}</span>  <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出集合，重复的元素被自动去掉  </span><span class="token punctuation">{</span><span class="token string">'Mary'</span><span class="token punctuation">,</span> <span class="token string">'Jim'</span><span class="token punctuation">,</span> <span class="token string">'Rose'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token string">'Tom'</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 成员测试 </span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">if</span> <span class="token string">'Rose'</span> <span class="token keyword">in</span> student <span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Rose 在集合中'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">else</span> <span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Rose 不在集合中'</span><span class="token punctuation">)</span>   Rose 在集合中<span class="token comment" spellcheck="true"># set可以进行集合运算 </span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'abracadabra'</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'alacazam'</span><span class="token punctuation">)</span>  <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a 和 b 的差集  </span><span class="token punctuation">{</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a 和 b 的并集  </span><span class="token punctuation">{</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a 和 b 的交集  </span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a 和 b 中不同时存在的元素</span><span class="token punctuation">{</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">### 1.7 空None</span>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None：```python<span class="token operator">>></span><span class="token operator">></span>  a <span class="token operator">=</span> None<span class="token operator">>></span><span class="token operator">></span>  a <span class="token keyword">is</span> None<span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span>  b <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span>  b <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token boolean">True</span>```None也常常作为函数的默认参数：```python<span class="token keyword">def</span> <span class="token function">add_and_maybe_multiply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> a <span class="token operator">+</span> b    <span class="token keyword">if</span> c <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> c    <span class="token keyword">return</span> result```另外，None不仅是一个保留字，还是唯一的NoneType的实例：```python<span class="token operator">>></span><span class="token operator">></span>  type<span class="token punctuation">(</span>None<span class="token punctuation">)</span>NoneType```<span class="token comment" spellcheck="true">### 1.8 字节和Unicode</span>在Python <span class="token number">3</span>及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non<span class="token operator">-</span>ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。假如知道字符编码，可以将其转化为Unicode。看一个例子：```python<span class="token operator">>></span><span class="token operator">></span>  val <span class="token operator">=</span> <span class="token string">"español"</span><span class="token operator">>></span><span class="token operator">></span>  val<span class="token string">'español'</span>```可以用`encode`将这个Unicode字符串编码为UTF<span class="token number">-8</span>：```python<span class="token operator">>></span><span class="token operator">></span> val_utf8 <span class="token operator">=</span> val<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> val_utf8b<span class="token string">'espa\xc3\xb1ol'</span><span class="token operator">>></span><span class="token operator">></span>  type<span class="token punctuation">(</span>val_utf8<span class="token punctuation">)</span>bytes```如果你知道一个字节对象的Unicode编码，用`decode`方法可以解码：```python<span class="token operator">>></span><span class="token operator">></span>  val_utf8<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token string">'español'</span>```虽然UTF<span class="token number">-8</span>编码已经变成主流，但因为历史的原因，你仍然可能碰到其它编码的数据：```python<span class="token operator">>></span><span class="token operator">></span> val<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'latin1'</span><span class="token punctuation">)</span>b<span class="token string">'espa\xf1ol'</span><span class="token operator">>></span><span class="token operator">></span> val<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-16'</span><span class="token punctuation">)</span>b<span class="token string">'\xff\xfee\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00'</span><span class="token operator">>></span><span class="token operator">></span> val<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-16le'</span><span class="token punctuation">)</span>b<span class="token string">'e\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00'</span>```工作中碰到的文件很多都是字节对象，盲目地将所有数据编码为Unicode是不可取的。虽然用的不多，你可以在字节文本的前面加上一个b：```python<span class="token operator">>></span><span class="token operator">></span>  bytes_val <span class="token operator">=</span> b<span class="token string">'this is bytes'</span><span class="token operator">>></span><span class="token operator">></span>  bytes_valb<span class="token string">'this is bytes'</span><span class="token operator">>></span><span class="token operator">></span>  decoded <span class="token operator">=</span> bytes_val<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>  decoded  <span class="token comment" spellcheck="true"># this is str (Unicode) now</span><span class="token string">'this is bytes'</span>```<span class="token comment" spellcheck="true">### 1.9 Python数据类型转换</span>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。<span class="token operator">|</span>                          函数                           <span class="token operator">|</span>                     描述                     <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">,</span>base\<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>int<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将x转换为一个整数              <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>float<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>float<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将x转换到一个浮点数                 <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>complex<span class="token punctuation">(</span>real <span class="token punctuation">[</span><span class="token punctuation">,</span>imag\<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>complex<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 创建一个复数        <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>str<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将对象 x 转换为字符串                    <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>repr<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>repr<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将对象 x 转换为表达式字符串            <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>eval<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>eval<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span>计算字符串中的有效表达式<span class="token punctuation">,</span>返回一个对象  <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python3<span class="token operator">-</span>func<span class="token operator">-</span>tuple<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将序列 s 转换为一个元组             <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python3<span class="token operator">-</span>att<span class="token operator">-</span>list<span class="token operator">-</span>list<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将序列 s 转换为一个列表           <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>set<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>set<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 转换为可变集合                           <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>dict<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>dict<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 创建字典。d 必须是 <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>元组序列<span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>frozenset<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>frozenset<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 转换为不可变集合            <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>chr<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>chr<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将一个整数转换为一个字符                <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>ord<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将一个字符转换为它的整数值              <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>hex<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>hex<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将一个整数转换为一个十六进制字符串      <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">[</span>oct<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com<span class="token operator">/</span>python3<span class="token operator">/</span>python<span class="token operator">-</span>func<span class="token operator">-</span>oct<span class="token punctuation">.</span>html<span class="token punctuation">)</span> <span class="token operator">|</span> 将一个整数转换为一个八进制字符串        <span class="token operator">|</span><span class="token comment" spellcheck="true">## 2. 变量与运算符</span><span class="token comment" spellcheck="true">### 2.1  变量命名规则</span><span class="token comment" spellcheck="true">### 2.2 变量赋值</span><span class="token comment" spellcheck="true">### 2.3 运算符</span>大多数二元数学运算和比较都不难想到：```pythonIn <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">7</span>Out<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">2</span>In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">12</span> <span class="token operator">+</span> <span class="token number">21.5</span>Out<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">33.5</span>In <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token operator">&lt;=</span> <span class="token number">2</span>Out<span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">False</span>```下表列出了所有的二元运算符。要判断两个引用是否指向同一个对象，可以使用`<span class="token keyword">is</span>`方法。`<span class="token keyword">is</span> <span class="token operator">not</span>`可以判断两个对象是不同的：```pythonIn <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span> b <span class="token operator">=</span> aIn <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c <span class="token operator">=</span> list<span class="token punctuation">(</span>a<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token keyword">is</span> bOut<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>In <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token keyword">is</span> <span class="token operator">not</span> cOut<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>```因为`list`总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。使用`<span class="token keyword">is</span>`比较与`<span class="token operator">==</span>`运算符不同，如下：```pythonIn <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">==</span> cOut<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>````<span class="token keyword">is</span>`和`<span class="token keyword">is</span> <span class="token operator">not</span>`常用来判断一个变量是否为`None`，因为只有一个`None`的实例：```pythonIn <span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> NoneIn <span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token keyword">is</span> NoneOut<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>```!<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#x8868;2-3 &amp;#x4E8C;&amp;#x5143;&amp;#x8FD0;&amp;#x7B97;&amp;#x7B26;](/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-python-basis.assets/7178691-9fb5f25b33166acf.png)</span><span class="token comment" spellcheck="true">## 3. Python流程控制</span>Python有若干内建的关键字进行条件逻辑、循环和其它控制流操作<span class="token comment" spellcheck="true">### 3.1 if语句</span><span class="token keyword">if</span>是最广为人知的控制流语句。它检查一个条件，如果为<span class="token boolean">True</span>，就执行后面的语句：```python<span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'It'</span>s negative'<span class="token punctuation">)</span>````<span class="token keyword">if</span>`后面可以跟一个或多个`<span class="token keyword">elif</span>`，所有条件都是<span class="token boolean">False</span>时，还可以添加一个`<span class="token keyword">else</span>`：```python<span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'It is negative'</span><span class="token punctuation">)</span><span class="token keyword">elif</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Equal to zero'</span><span class="token punctuation">)</span><span class="token keyword">elif</span> <span class="token number">0</span> <span class="token operator">&lt;</span> x <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Positive but smaller than 5'</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Positive and larger than or equal to 5'</span><span class="token punctuation">)</span>```如果某个条件为<span class="token boolean">True</span>，后面的`<span class="token keyword">elif</span>`就不会被执行。当使用<span class="token operator">and</span>和<span class="token operator">or</span>时，复合条件语句是从左到右执行：```pythonIn <span class="token punctuation">[</span><span class="token number">117</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">7</span>In <span class="token punctuation">[</span><span class="token number">118</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> d <span class="token operator">=</span> <span class="token number">4</span>In <span class="token punctuation">[</span><span class="token number">119</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">if</span> a <span class="token operator">&lt;</span> b <span class="token operator">or</span> c <span class="token operator">></span> d<span class="token punctuation">:</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Made it'</span><span class="token punctuation">)</span>Made it```在这个例子中，`c <span class="token operator">></span> d`不会被执行，因为第一个比较是<span class="token boolean">True</span>：也可以把比较式串在一起：```pythonIn <span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token operator">></span> <span class="token number">3</span> <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">></span> <span class="token number">1</span>Out<span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>```<span class="token comment" spellcheck="true">### 3.2 for语句</span><span class="token keyword">for</span>循环是在一个集合（列表或元组）中进行迭代，或者就是一个迭代器。<span class="token keyword">for</span>循环的标准语法是：```python<span class="token keyword">for</span> value <span class="token keyword">in</span> collection<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># do something with value</span>```你可以用<span class="token keyword">continue</span>使<span class="token keyword">for</span>循环提前，跳过剩下的部分。看下面这个例子，将一个列表中的整数相加，跳过None：```pythonsequence <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> value <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>    <span class="token keyword">if</span> value <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">continue</span>    total <span class="token operator">+=</span> value```可以用`<span class="token keyword">break</span>`跳出<span class="token keyword">for</span>循环。下面的代码将各元素相加，直到遇到<span class="token number">5</span>：```pythonsequence <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>total_until_5 <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> value <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>    <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    total_until_5 <span class="token operator">+=</span> value```<span class="token keyword">break</span>只中断<span class="token keyword">for</span>循环的最内层，其余的<span class="token keyword">for</span>循环仍会运行：```pythonIn <span class="token punctuation">[</span><span class="token number">121</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>     <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>         <span class="token keyword">if</span> j <span class="token operator">></span> i<span class="token punctuation">:</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>             <span class="token keyword">break</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>```如果集合或迭代器中的元素序列（元组或列表），可以用<span class="token keyword">for</span>循环将其方便地拆分成变量：```python<span class="token keyword">for</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token keyword">in</span> iterator<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># do something</span>```<span class="token comment" spellcheck="true">### 3.3 break 跳出循环</span><span class="token comment" spellcheck="true">### 3.4 continue跳出本次循环</span><span class="token comment" spellcheck="true">### 3.5 pass 什么都不做</span><span class="token comment" spellcheck="true">### 3.6 while</span><span class="token keyword">while</span>循环指定了条件和代码，当条件为<span class="token boolean">False</span>或用<span class="token keyword">break</span>退出循环，代码才会退出：```pythonx <span class="token operator">=</span> <span class="token number">256</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> total <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    total <span class="token operator">+=</span> x    x <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span>```<span class="token comment" spellcheck="true">## 4. Python文件处理</span><span class="token comment" spellcheck="true">### 4.1 常用函数</span><span class="token comment" spellcheck="true">#### 4.1.1 open()</span><span class="token comment" spellcheck="true">#### 4.1.2 read()</span><span class="token comment" spellcheck="true">#### 4.13 .readline()</span><span class="token comment" spellcheck="true">#### 4.1.4 readlines()</span><span class="token comment" spellcheck="true">#### 4.1.5 write()</span><span class="token comment" spellcheck="true">#### 4.1.6 close()</span><span class="token comment" spellcheck="true">### 4.2 上下文管理器</span><span class="token comment" spellcheck="true">#### with open (afile) as:</span><span class="token comment" spellcheck="true">## 5. Python 输入输出</span><span class="token comment" spellcheck="true">### 5.1 输出 print</span><span class="token comment" spellcheck="true">### 5.2 输入 input</span><span class="token comment" spellcheck="true">## 6. Python 异常</span><span class="token comment" spellcheck="true">### 6.1 错误和异常</span><span class="token comment" spellcheck="true">### 6.2 异常类型</span><span class="token comment" spellcheck="true">### 6.3 异常捕获</span><span class="token comment" spellcheck="true">### 6.4 上下文管理</span><span class="token comment" spellcheck="true">### 6.5 特殊处理</span><span class="token comment" spellcheck="true">## 7. Python 函数和模块</span><span class="token comment" spellcheck="true">### 7.1 函数定义</span><span class="token comment" spellcheck="true">### 7.2 函数调用</span><span class="token comment" spellcheck="true">### 7.3 函数返回</span><span class="token comment" spellcheck="true">### 7.4 函数参数</span><span class="token comment" spellcheck="true">### 7.5 迭代器</span><span class="token comment" spellcheck="true">### 7.6 生成器</span><span class="token comment" spellcheck="true">### 7.7 匿名函数</span><span class="token comment" spellcheck="true">### 7.8 函数式编程</span><span class="token comment" spellcheck="true">### 7.9 闭包</span><span class="token comment" spellcheck="true">### 7.10 模块的导入</span><span class="token comment" spellcheck="true">## 8. Python 面相对象</span><span class="token comment" spellcheck="true">### 8.1 类的定义</span><span class="token comment" spellcheck="true">### 8.2 类对象</span><span class="token comment" spellcheck="true">### 8.3 继承</span><span class="token comment" spellcheck="true">### 8.4 操作</span><span class="token comment" spellcheck="true">## 9. Python 多线程</span><span class="token comment" spellcheck="true">### 9.1 多线程可以让程序并行执行</span><span class="token comment" spellcheck="true">### 9.2 常用库</span><span class="token comment" spellcheck="true">### 9.3 常用方法</span><span class="token comment" spellcheck="true">## 10.Python 标准库</span><span class="token comment" spellcheck="true">### 10.1 运行服务的\_\_main\_\_</span><span class="token comment" spellcheck="true">### 10.2 文字处理的re</span><span class="token comment" spellcheck="true">### 10.3 日期类型的time, datetime</span>Python内建的`datetime`模块提供了`datetime`、`date`和`time`类型。`datetime`类型结合了`date`和`time`，是最常使用的：```pythonIn <span class="token punctuation">[</span><span class="token number">102</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> date<span class="token punctuation">,</span> timeIn <span class="token punctuation">[</span><span class="token number">103</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">104</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>dayOut<span class="token punctuation">[</span><span class="token number">104</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">29</span>In <span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>minuteOut<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">30</span>```根据`datetime`实例，你可以用`date`和`time`提取出各自的对象：```pythonIn <span class="token punctuation">[</span><span class="token number">106</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">106</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">107</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">107</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>````strftime`方法可以将datetime格式化为字符串：```pythonIn <span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%m/%d/%Y %H:%M'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'10/29/2011 20:30'</span>````strptime`可以将字符串转换成`datetime`对象：```pythonIn <span class="token punctuation">[</span><span class="token number">109</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">'20091031'</span><span class="token punctuation">,</span> <span class="token string">'%Y%m%d'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">109</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2009</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>```表<span class="token number">2</span><span class="token operator">-</span><span class="token number">5</span>列出了所有的格式化命令。!<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#x8868;2-5 Datetime&amp;#x683C;&amp;#x5F0F;&amp;#x5316;&amp;#x6307;&amp;#x4EE4;&amp;#xFF08;&amp;#x4E0E;ISO C89&amp;#x517C;&amp;#x5BB9;&amp;#xFF09;](/home/jwang/opt/workspace/github/myblog/source/_posts/20200103-python-basis.assets/7178691-100f9a20c1536553.png)</span>当你聚类或对时间序列进行分组，替换datetimes的time字段有时会很有用。例如，用<span class="token number">0</span>替换分和秒：```pythonIn <span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>minute<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> second<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>```因为`datetime<span class="token punctuation">.</span>datetime`是不可变类型，上面的方法会产生新的对象。两个datetime对象的差会产生一个`datetime<span class="token punctuation">.</span>timedelta`类型：```pythonIn <span class="token punctuation">[</span><span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt2 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">112</span><span class="token punctuation">]</span><span class="token punctuation">:</span> delta <span class="token operator">=</span> dt2 <span class="token operator">-</span> dtIn <span class="token punctuation">[</span><span class="token number">113</span><span class="token punctuation">]</span><span class="token punctuation">:</span> deltaOut<span class="token punctuation">[</span><span class="token number">113</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">7179</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">114</span><span class="token punctuation">]</span><span class="token punctuation">:</span> type<span class="token punctuation">(</span>delta<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">114</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta```结果`timedelta<span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">7179</span><span class="token punctuation">)</span>`指明了`timedelta`将<span class="token number">17</span>天、<span class="token number">7179</span>秒的编码方式。将`timedelta`添加到`datetime`，会产生一个新的偏移`datetime`：```pythonIn <span class="token punctuation">[</span><span class="token number">115</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dtOut<span class="token punctuation">[</span><span class="token number">115</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">116</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dt <span class="token operator">+</span> deltaOut<span class="token punctuation">[</span><span class="token number">116</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>```<span class="token comment" spellcheck="true">###</span><span class="token comment" spellcheck="true">### 10.4 数字和数学类型的math, random</span><span class="token comment" spellcheck="true">### 10.5 文件和目录访问pathlib, os.lib</span><span class="token comment" spellcheck="true">### 10.6 数据压缩和归档tarfile</span><span class="token comment" spellcheck="true">### 10.7 通用操作系统os, argparse, logging, subprocess</span><span class="token comment" spellcheck="true">### 10.8 多线程threading, queue</span><span class="token comment" spellcheck="true">### 10.9 Internet数据处理的base64, json, urllib</span><span class="token comment" spellcheck="true">### 10.10 结构化标记处理工具html, xml</span><span class="token comment" spellcheck="true">### 10.11 开发工具的unitest</span><span class="token comment" spellcheck="true">### 10.12 调试工具的timeit</span><span class="token comment" spellcheck="true">### 10.13 软件包发布的venv</span><span class="token comment" spellcheck="true">## 11. Python 第三方库</span><span class="token comment" spellcheck="true">### 11.1 numpy</span><span class="token comment" spellcheck="true">### 11.2 scipy</span><span class="token comment" spellcheck="true">### 11.3 matplotlib</span><span class="token comment" spellcheck="true">### 11.4 pandas</span><span class="token comment" spellcheck="true">### 11.5 sklearn</span><span class="token comment" spellcheck="true">### 11.6 psrchive</span><span class="token comment" spellcheck="true">### 11.7 astropy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Data Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Time of Arrival</title>
      <link href="/2019/09/26/20190926-toa/"/>
      <url>/2019/09/26/20190926-toa/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Arrival-time-files"><a href="#Arrival-time-files" class="headerlink" title="Arrival time files"></a>Arrival time files</h3><p>The tempo2 arrival time file format (which typically has the file extension .tim) has the following form:</p><pre class="line-numbers language-bash"><code class="language-bash">FORMAT 1directory/filename frequency sat uncertainty site<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The FORMAT 1 statement defines this file to be a tempo2 format arrival time file. If a directory and filename is not available then the first column in this file can simply be an identifier for the particular observation. The frequency (in MHz), arrival time (MJD) and uncertainty (µs) can be given to any number of decimal places.</p><h3 id="Using-flags"><a href="#Using-flags" class="headerlink" title="Using flags"></a>Using flags</h3><p>Each arrival time line may have one or more “flags” that provide extra information for the user and the tempo2 algorithms. A few pre-defined flags have been set, but the user is free to define as many flags as required.</p><p>The flags may be given in any order (and flags do not have to be set for all observations). Flags can be used for numerous purposes including:<br><strong>Selecting data:</strong> command line arguments can be used to filter observations based on their flag values.<br>For instance:</p><pre class="line-numbers language-bash"><code class="language-bash">$ tempo2 -f mypar.par mytim.tim -pass <span class="token string">"-b WBCORR DFB4"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>will only select observations that have a “-b” flag set to “WBCORR” or to “DFB4”.</p><pre class="line-numbers language-bash"><code class="language-bash">$ tempo2 -f mypar.par mytim.tim -filter <span class="token string">"-rcvr 10CM"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>will reject all observations that have a “-rcvr” flag set to “10CM”. (More complex filters are available using the select plugins or through a “select file”.)<br><strong>Dealing with phase jumps between instruments/observatories:</strong><br>It is common to include a phase jump between observations from different instruments or observatories. Sometimes these phase jumps are known and can be fixed. Usually, such jumps are measured as part of the tempo2 fit. The timing model can be updated to include</p><pre class="line-numbers language-bash"><code class="language-bash">JUMP -rcvr 10CM 0 1JUMP -rcvr MULTI 0 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>that will include a fit for the phase jump for data obtained with the 10CM receiver and for a phase jump for the MULTI receiver. These jumps are with respect to any observations that were not obtained using the 10CM and MULTI receivers (note: you cannot place a jump around all<br>observations - the jumps d to be with respect to a set of arrival times),</p><p><strong>Highlighting particular observations:</strong><br> The plk plugin allows particular observations to be highlighted. This can be initiated from the command line:</p><pre class="line-numbers language-bash"><code class="language-bash">$ tempo2 -gr plk -f mypar.par mytim.tim -colour -rcvr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>will draw the observations with different “-rcvr” flags with different colours. Within the plugin, the ctr-i and ‘H’ options enable further highlighting of particular observations.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pulsar and Pulsar Timing</title>
      <link href="/2019/09/22/20190922-pulsar-timing/"/>
      <url>/2019/09/22/20190922-pulsar-timing/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="1-About-Pulsar"><a href="#1-About-Pulsar" class="headerlink" title="1. About Pulsar"></a>1. About Pulsar</h2><p>When a large star gets very old, it will probably blow up. What it blows up to depends on how large it was in the first place, but some stars blow up and become Neutron Stars. When a star the size of our sun runs out of fuel, its outer layers are ejected as a colorful nebula, and the core collapses in on itself into a <strong>white dwarf star</strong>, generally destined to cool and fade over time (<em>left, in illustration below</em>). When a super giant star at least 20 times more massive than our sun runs out of fuel, it collapses abruptly, which can trigger a supernova explosion, and can result in the formation of a <strong>black hole</strong> (<em>right</em>). Stars lighter than about 20 solar masses but several times heavier than our sun can end their lives by creating a supernova that leaves behind a small, dense core rather than a black hole. Gravity presses the material in on itself so tightly that protons and electrons combine to make neutrons. The result is a <strong>neutron star</strong>—in which a mass about equal to that of our sun, is compressed into an incredibly dense sphere with a diameter of only about 20 kilometers (<em>middle</em>).</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092204.jpg"><p>The high energy of an explosive birth and an extremely dense core can set the stage for a strong magnetic field. The <strong>magnetic axis</strong> can be dramatically misaligned with the <strong>rotational axis</strong>. As the star rotates, it emanates a radio beam, generated by the combined effect of the magnetic field and the rotation, which sweeps periodically through the surrounding space, like a lighthouse beacon. If we’re lucky, then the radiation from these poles sweeps across the earth once during each orbit and we detect ‘pulses’ of radiation. Hence the name, <strong>pulsars</strong>.</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092205.jpg"><p>Pulsars are fascinating objects - they are incredibly dense (300 million million grams per centimetre cubed!), and often rotating very quickly. Though pulsars do slow down, there are a certain type of extremely short period pulsars (known as millisecond pulsars - they have periods of the order of milliseconds) that slow down very slowly and in an entirely predictable way. Once a mathematical model has been built that describes how the pulsar slows down (called an ephemeris) these pulsars can be used as one of the most reliable clocks in the universe. Because they are so stable data from these pulsars can be used to test theories such as the Theory of General Relativity, or new gravitational models. Joe Taylor of Princeton University and a student of his, Russell Hulse were awarded the Nobel Prize for Physics in 1993 for their pulsar timing work which indirectly detected gravitational waves.</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092202.gif"><p>However, because the pulsar is emitting so much energy it slows down (energy is always conserved) which means that the pulses of radiation get further and further apart. The ‘period’ of a pulsar is the time between each pulse, so as the pulsar slows down the period is seen to increase. Knowing the pulsar period (P) and the rate at which it is slowing down (dP/dt or ‘p-dot’) allows the age and the magnetic field of the pulsar to be found, and the more accurately these parameters are known, the more accurately information can be derived about the pulsar.</p><h3 id="1-1-Discovery-and-Basic-Properties"><a href="#1-1-Discovery-and-Basic-Properties" class="headerlink" title="1.1 Discovery and Basic Properties"></a>1.1 Discovery and Basic Properties</h3><p>Shortly after the discovery of the neutron by Chadwick in 1932, two astronomers, Baade &amp; Zwicky, proposed that during Supernova explosions small, extremely dense objects could be created in the centre of the exploding star. They suggested that the enormous pressure occurring in the centre of the explosion would be sufficient to enable an “inverse beta-decay” during which electrons and protons are combined to neutrons and neutrinos. Neutrinos could leave the star to carry away a substantial amount of energy, leaving behind a very dense object consisting mostly of neutrons. They called these objects accordingly “neutron stars”. </p><p>Five years later, Oppenheimer (who later lead the Manhattan project) &amp; Volkov were the first to calculate the expected size and mass of these newly predicted objects. Based on quantum mechanical arguments they computed that neutron stars should have a diameter of about 20 km while containing 1.4 times the mass of the sun. Given this extremely small size expected for these objects, astronomers therefore considered it to be impossible to ever detect neutron stars and hence to verify the predictions by Baade &amp; Zwicky. </p><p>The situation changed dramatically in 1967. Meanwhile a new window had been opened up for astronomers, the radio window. It was in summer 1967 when a research student, Jocelyn Bell, was working on her PhD thesis at Cambridge under the supervision of Anthony Hewish. They wanted to study the intensity variation of quasars, which were discovered only a few years earlier. After constructing a radio telescope dedicated to monitor the sky for intensity variations, <a href="http://www.pbs.org/wgbh/aso/ontheedge/pulsar/">Jocelyn Bell came across a signal</a> which originated from a certain location in the sky, RA B19:19:36 - DEC +21:47:16. The signal was highly periodic with a periodicity of 1.337 seconds. Figure 1 shows the discovery recording. </p><p>The astronomers were puzzled by this discovery and wanted to establish its nature before they made it public. Indeed, one possibility that was seriously considered was that of a signal sent by extra-terrestrial intelligence. Soon, however, the team discovered more such periodic signals, and it seemed highly unlikely that one would suddenly receive signals from many different civilisations at once. Moreover, a period variation due to a Doppler effect caused by the moving planet of a possibly transmitting civilisation was not discovered. A natural origin of the signal was hence concluded. </p><h3 id="1-2-The-nature-of-pulsars"><a href="#1-2-The-nature-of-pulsars" class="headerlink" title="1.2 The nature of pulsars"></a>1.2 The nature of pulsars</h3><p>A journalist finally invented the name  “Pulsar” for these objects, standing for “Pulsating Radio Source”. Three possible explanation were put forward in the publication reporting the discovery. A pulsar could be</p><ul><li>an oscillating object (similar to intensity variations of Cepheids in the optical),</li><li>an orbiting object (i.e. a companion eclipsing a radio source) and</li><li>a rotating object (like a rotating lighthouse).</li></ul><p>The question about the true nature of pulsars was finally settled, when a pulsar was discovered in the centre of the Crab Nebula supernova remnant. </p><p>The Crab Nebula (Figure 2; also called M1 as it was the first object in Messier’s famous list) is the visible remnant of a supernova explosion witnessed by Chinese astronomers in A.D.1054. The nebula had been in the focus of discussions before, since its brightness was hard to explain given the nebula’s age. It was suggested that a mysterious star visible in the centre (see arrow in Figure 2) was responsible, but the star did not fit any known category. It happened that in parallel to the discovery of pulsars, Thomas Gold (1968) had proposed that the nebula could be powered by a highly magnetised neutron star. After the discovery of pulsars, Staelin &amp; Reifenstein (1968) observed the nebula for pulsed radio emission. They discovered high intensity pulses originating from the central “strange” star, identifying it as a pulsar. It turned out later, that these “giant pulses” which they observed, occur every two minutes or so, and that the true pulse period was in fact as short as 33 milliseconds. </p><p>Periods for radial oscillations of neutron stars were predicted to be larger than 1 second and were hence incompatible with the periods of the first discovered pulsars. Finally, another property of pulsars, also most easily observed in the Crab pulsar, provided the final clue. It was noticed that the period of pulsars slowly increases, for the Crab pulsar by as much as 36 nanoseconds per day. This property is not expected for the model of an eclipsing binary, where due to the loss of energy one would in fact expect the companions to come closer, reducing the pulse period. However, a slow-down of the period is indeed expected for a rotating object. The problem was finally solved: pulsars are rotating cosmic light houses. </p><p>Pulsars are named according to their celestial coordinates. Using the equatorial system, the name is composed from hours and minutes of right ascension and degrees (and minutes) of declination, preceeded by a leading “PSR” for “pulsar”. As the Earth axis is precessing, the equatorial coordinate system changes slowly and we have to indicate the epoch we refer to. For all newly discovered pulsars today, J2000 coordinates are chosen and we write, for instance, PSR J1022+1001. In the past, coordinates referred to epoch B1950, and well studied pulsars are still known under their B1950 names (not including minutes of declination), e.g. see PSR B0329+54 below. </p><p>But the stacked plot pulses below are irregular, not clean bell curves, as shown in the animation above.</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092206.jpg"><p>Several researchers, including <a href="http://adsabs.harvard.edu/abs/1993ApJS...85..145R">Joanna Rankin</a>, have proposed that variation in pulse shape could be due to internal variation in the cone of emissions. Here are some idealized forms, but the pattern could be further complicated with additional hotspots and interference by solar wind.</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092207.jpg"><p>Although there’s definitely variation from pulse to pulse, the average shape over about a minute results in a characteristic form that is different for each individual pulsar.</p><img width="385px" height="185px" src="https://github.com/AstronDog/blog-pic/raw/master/2019092208.jpg"><h2 id="2-Pulsar-Data-Archive"><a href="#2-Pulsar-Data-Archive" class="headerlink" title="2. Pulsar Data Archive"></a>2. Pulsar Data Archive</h2><p>The ‘Archive Files’ contain the raw, unprocessed data taken straight from the telescope. All archive files have names that end in ‘.ar’. The telescope collects information on three parameters, and stores it in a three-dimensional array with the following dimensions:</p><blockquote><p>Polarisation<br>Frequency<br>Timei</p></blockquote><p>The polarisation of light is the angle of oscillation of a transverse light wave. Imagine light as a wave on a string - the polarisation is the angle that the string is moving up and down along. Radio waves are electromagnetic waves just like light, so we can talk about how the radio waves are polarised. One of the ways that the angle of this polarisation may be detected is by crossing two electric dipoles at right angles to one another within the telescope- as the wave passes by it induces a voltage across the dipoles - the proportion of voltage induced across each dipole allows us to know the polarisation of the incident radio signal. The polarisation of the radio signal is not the same throughout the pulse - indicating that it changes across the beam. Knowing how it changes allows astronomers to learn about mechanisms inside the pulsar.</p><p>The telescope collects polarisation data as coherency products . These are:</p><blockquote><p>LL (left polarised)<br>RR (right polarised)<br>LR<br>RL</p></blockquote><p>These coherency products are used to give the Stoke’s Parameters (I; Total intensity, Q and U; Linear intensities and V; Circular intensity) which can be used to specify the phase and polarisation of the radiation at any time.</p><p>The frequency in this case doesn’t refer to the pulsar frequency, but to the frequency of radiation coming in. Observations are made in certain bandwidths centred on one frequency, eg 800MHz +/- 0.5MHz so there is some spread in the frequencies of radiation being observed. The frequency of the signal is very important in correcting for a phenomenon known as dispersion:</p><p>As electromagnetic radiation travels through space, it interacts with the interstellar medium (ISM). Photons are scattered off interstellar electrons essentially causing them to slow down. This effect is more prominent with lower frequencies and so they are slowed down more than higher frequencies. This means that when a pulse is detected at the telescope, higher frequencies are detected sooner than lower frequencies. An example of an archive file is shown below:</p><img width="385px" height="185px" src="/home/jwang/2019092208.jpg"><p>Note how the higher frequencies arrive well before the lower frequencies. Knowing the frequencies of the incoming data, this dispersion effect can be accounted for, and the pulse ‘lined up’. An interesting offshoot of this effect is that it gives astronomers the ability to estimate a distance to the pulsar by measuring just how much more delayed the lower frequencies are. The more delayed they are, the more electrons the radiation interacted with - so assuming that the electron density in space is constant (which is not a great assumption), we have an indication of the pulsar’s distance from Earth. The ‘amount of delay’ across the frequencies in each pulse is known as the Dispersion Measure (DM) .</p><p>The ultimate aim of this part of the timing process is to create a Pulse Profile. A pulse profile is a single polarisation intensity distribution usually formed by the integration of several, to several thousand, to several million pulsar rotatios. A good pulse profile will be narrow (properly dispersion corrected and correctly timed) with a high signal to noise ratio. The signal to noise ratio (SNR) is the height of the pulse signal, divided by the average height of the background noise - so the bigger the better! Quantitatively, the ‘root-mean-square’ (like the average) of the noise height goes as one over the square root of the total integration time. This means that combining the data from more pulses reduces the noise height, so the SNR goes up. This is a good thing.</p><h2 id="3-Pulsar-Timing"><a href="#3-Pulsar-Timing" class="headerlink" title="3. Pulsar Timing"></a>3. Pulsar Timing</h2><p>The inherent assumption is that average pulsar profiles are stable (Lorimer &amp; Kramer 2004), and that any given observed profile \(O(x)\) is just a phase-shifted version of the intrinsic profile \(P(x)\) multiplied by a constant plus noise \(N(x)\), ie $$O(x) = AP(x − \alhpa) + N(x)$$, where A is a scale factor and α is the phase shift. One then cross correlates this observed profile with a template, and obtains an arrival time and associated error.</p><p>Pulsars are intrinsically low-luminosity objects, and pulsar timing requires the world’s largest telescopes in many cases just to detect them. From an astrometric point of view, we can think of pulsar timing as an interferometric experiment. The pulsar, due to its massive moment of inertia and small braking torque is a very precise clock. The pulses therefore represent a source of coherent radiation and the Earth-Sun system are immersed in radiation from this coherent source. The wavelength of the radiation can be thought of as having a wavelength \(\lambda = cP\), where \(c\) is the speed of light. The baseline of our experiment is 2 astronomical units (AU). The position of the pulsar can therefore be determined to an accuracy of \(~λ/(2AU)\) times the relative accuracy with which we can determine the arrival time of the pulse at any given epoch. For a gaussian profile this is approximately \(w/(2 × P × SNR)\) where \(w\) is the half-width of the Gaussian and SNR is the signal-to-noise ratio of the pulsar.</p><p>The SNR is provided by a modified version of the radiometer equation: $$SNR = $$</p><p>where S is the pulsar flux in Janskys, G the receiver gain in the units of K/Jy, B the<br>receiver bandwith (Hz), Np is the number of polarisations (usually 2), t the integration<br>time in seconds, and Trec and Tsky are the effective temperatures of the receiver and sky<br>respectively.<br>This means the error (σ) in the arrival times or TOAs is approximately:</p><p>and for the brightest millisecond pulsars can be below 100 nanoseconds. These types of errors permit not only positions to be determined to a precision of just tens of microarcseconds, but also allow very accurate proper motions and even parallaxes, orbital period derivatives, and relativistic effects such as Shapiro delay to be observed. For narrow pulsar profiles, \(\sigma ∝ w^{3/2}\) , highlighting the importance of finding pulsars with narrow features or using instrumentation that minimizes any smearing. </p><p>The theory of pulsar timing relies on the pulse profile being an invariant. We know it isn’t. Observations of slow pulsars with large fluxes demonstrate that pulsar profiles require many rotations to stabilize, but due to their small fluxes, this is difficult to<br>establish for the millisecond pulsars.</p><p>Astronomers fit a template, often constructed of either the sum of the best observations or the addition of several Gaussian components that closely approximate the pulse shape to each observation. As we saw in the introduction the “theory” is that each observation is just a scaled version of the template plus random noise with a phase shift. Fitting to equation 1.1 for A and α (often in the Fourier domain) yield an arrival time (TOA) and error. These TOAs and errors are often placed into a least squares fitting program like tempo2 (Hobbs, Edwards and Manchester 2006) to yield pulsar parameter estimations from which physical interpretations are made.</p><p>Unfortunately, once this fit is performed, the reduced chi-squared is often far from unity, limiting the interpretation of the physical parameter errors, and ultimately the pulsar timing methodology. A conservative approach to this problem is to keep adding a systematic error term in quadrature to each TOA until the reduced chi-squared is unity. A more dangerous (but more often used approach) is to linearly increase the size of each error until the reduced chi-squared is unity. This is an optimistic assumption, but reduces the size of the errors on the physical parameters.</p><h2 id="4-Pulsar-Timing-Process"><a href="#4-Pulsar-Timing-Process" class="headerlink" title="4. Pulsar Timing Process"></a>4. Pulsar Timing Process</h2><p>There are 6 main steps to timing a pulsar:</p><blockquote><ol><li>Use Pav to view the pulses and familiarise yourself with the data.</li><li>Use Pam to scrunch the data</li><li>Choose a standard pulse for that set of data</li><li>Use Pat to measure the difference in pulse arrival times from the standard pulse</li><li>Use the online Pulsar Catalogue to get a up to date ephemeris for the pulsar</li><li>Fit the ephemeris parameters for minmize the residuals with tempo2</li></ol></blockquote><p>The ephemeris of a pulsar is a mathematical model that defines how the pulsar ‘pulses’ - an accurate ephemeris will allow you to predict any time into the future whether the pulse will be ‘on’ or ‘off’.</p><h3 id="4-1-Using-Pav-Pulsar-Archive-Viewer"><a href="#4-1-Using-Pav-Pulsar-Archive-Viewer" class="headerlink" title="4.1 Using Pav (Pulsar Archive Viewer)"></a>4.1 Using Pav (Pulsar Archive Viewer)</h3><p>You can look at a pulse using the visualisation tool ‘pav’. In the directory that you just created, try typing:</p><pre class="line-numbers language-bash"><code class="language-bash">pav -DFTp <span class="token string">'name-of-file.ar'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(Any archive file will do for now) Before displaying the data, your computer will ask you to specify a graphics device:</p><pre class="line-numbers language-bash"><code class="language-bash">Graphics device/type <span class="token punctuation">(</span>? to see list, default /NULL<span class="token punctuation">)</span>:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Type:</p><pre class="line-numbers language-bash"><code class="language-bash">/xs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>And a pulse should appear (Hint: typing all the file-name in can be tedious, use your mouse to copy the file-name by left-clicking on the name - it should highlight it. Then, go back to where you were typing and right-click - the highlighted region will copy down).</p><p>What pav has done, is:</p><blockquote><ol><li>‘Scrunched’ (combined) all of the frequency data and accounted for dispersion</li><li>Scrunched all of the polarisation data</li><li>Scrunched the timing data</li><li>Put all the combined data together and created one final pulse for that archive.</li></ol></blockquote><p>To compare more than one pulse at a time, type:</p><pre class="line-numbers language-bash"><code class="language-bash"> pav -DFTp -N 3,3 *.ar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Press ‘enter’ to scroll through the data page by page.</p><p>So have a look at these pulses - you’ll notice that most archives show a double peak. Interestingly if you look at the dates (in the filename) you’ll see that the earlier archives don’t resolve the double pulse but the later ones do. This is because the telescope software and hardware has improved somewhat over the years. Some of these archives are great, others are not - some appear to have nothing in them, others really do have nothing in them. One thing to look for is the signal to noise ratio - this is the height of the pulse over the height of the noise in the background. Bigger signal to noise ratios mean a clearer pulse.</p><h3 id="4-2-Using-Pam-Pulsar-Archive-Manipulator"><a href="#4-2-Using-Pam-Pulsar-Archive-Manipulator" class="headerlink" title="4.2 Using Pam (Pulsar Archive Manipulator)"></a>4.2 Using Pam (Pulsar Archive Manipulator)</h3><p>Using ‘pav’ to view the archives involved telling pav to scrunch the data.</p><p>Pam will scrunch the data in each archive, and write it to a new file ending in ‘.FTp’. The archives must be pammed like this so that the pulse arrival times can be properly compared in the next section. You could pam each archive individually- but it would take too long. Using the wildcard ‘*’ you can specify that pam should run on each archive in the following way:</p><pre class="line-numbers language-bash"><code class="language-bash">pam -FTp -e FTp *.ar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This literally means: use pam to scrunch the archives ending in ‘.ar’ in frequency, time and polarisation, then write files (-e) that end with ‘.FTp’.</p><p>Because the files have been scrunched, you can view ‘.FTp’ files using ‘pav’ but without the ‘FTp’ part, so try the command:</p><pre class="line-numbers language-bash"><code class="language-bash">pav -D -N 3,3 *.FT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Or, to just view one file:</p><pre class="line-numbers language-bash"><code class="language-bash">pav -D <span class="token string">'filename.FT'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>These pulses should look exactly the same as the scrunched archive files you were looking at in the previous section.</p><h3 id="4-3-Choosing-A-Standard-Pulse"><a href="#4-3-Choosing-A-Standard-Pulse" class="headerlink" title="4.3 Choosing A Standard Pulse"></a>4.3 Choosing A Standard Pulse</h3><p>Now that the data has been scrunched, It is advisable to choose the ‘best looking pulse’ profile as the standard template through psrstat script, which can be used to  evaluation the S/N value of the archives.  Type:</p><pre class="line-numbers language-bash"><code class="language-bash">psrstat -c snr -Q *.FTp <span class="token operator">|</span> <span class="token function">sort</span> -gk2  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>For simplicity’s sake I’d strongly recommend you to pick the one(for examples, J1713+0747.aaa.FTp) with highest S/N as the single brightest templates and  copy this standard pulse to the tempaltes directory:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> templates<span class="token function">cp</span> J1713+0747.aaa.FTp ./templates/J1713+0747.FTp.single.std<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-4-Using-Pat-Pulsar-Archive-Timer"><a href="#4-4-Using-Pat-Pulsar-Archive-Timer" class="headerlink" title="4.4 Using Pat (Pulsar Archive Timer)"></a>4.4 Using Pat (Pulsar Archive Timer)</h3><p>Pat is used to determine the arrival times of pulsars in each archive. This is the most important part of timing a pulsar and determining its ephemeris.</p><p>Pat will take the pulse data from each pammed data file and measure its arrival time relative to that of the standard pulse. It compiles all of the arrival time data into a file that is suitable for reading by a program called TEMPO2. At the present time, pat can use several cross-correlation algorithms to determine the phase shift between the standard template and the observed Profile. Here, we strongly suggest you to use the ‘Fourier domain with Markov chain Monte Carlo’(‘FDM’) algorithms. </p><p>To use pat, type the following command:</p><pre class="line-numbers language-bash"><code class="language-bash">pat -FT -A FDM -C snr -s fcm20cm.std -f <span class="token string">"tempo2 IPTA"</span> *.FTp <span class="token operator">></span> J1713+0747.tim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This translates to: ‘Use pat to compare your standard file to the arrival times of pulses in each of the files with names ending in ‘.FTp’. Output all the arrival time data into a file called your.tim’.</p><p>You could look at the data that pat has produced by either typing ‘more yourinitials.tim’ into your shell, or opening the file with vim (%vim J1713+0747.tim). The data is in a table with the following columns:</p><p>Filename : Observation Frequency : Time of Arrival : Error in Microsecs : Telescope no and any other flags and value represent the observation messages.</p><p>So now you have created a file with the arrival times of all the pulses relative to the standard pulse. This will be used in the next part to show the timing residuals of the pulsar and fit for the up to data ephemeris.</p><h3 id="4-5-Downloading-an-Ephemeris"><a href="#4-5-Downloading-an-Ephemeris" class="headerlink" title="4.5 Downloading an Ephemeris"></a>4.5 Downloading an Ephemeris</h3><p>The most simple pulsar data format is the ephemeris. This is the parameters used in the timing model. Ephemerdies come as text files with a .eph or .par extension.</p><p>For most pulsars, an attempt at timing has already been made and an estimate of an ephemeris drawn up. We use this now to base our new ephemeris on and give the program some idea of where to start. For most pulsars, the ephemeris can be download form the IPTA data release through the EPTA website.</p><p>There appears to be no formal specification of what parameters are used in these files, although a loose standard has developed, with the following common parameters.</p><table><thead><tr><th>Param</th><th>Units</th><th>Description</th><th>Aliases</th></tr></thead><tbody><tr><td>PSRJ</td><td>Str</td><td>Pulsar JName</td><td></td></tr><tr><td>RAJ</td><td>hr</td><td>Right Asscention (J2000)</td><td></td></tr><tr><td>DECJ</td><td>deg</td><td>Declination (J2000)</td><td></td></tr><tr><td>PEPOCH</td><td>MJD</td><td>Period Epoch</td><td></td></tr><tr><td>F0</td><td>Hz</td><td>Rotational Frequency</td><td>or P/P0</td></tr><tr><td>F1</td><td>Hz/s</td><td>First derivitive of F0</td><td></td></tr><tr><td>F2</td><td>Hz/s/s</td><td>Second derivitive of F0</td><td></td></tr><tr><td>POSEPOCH</td><td>MJD</td><td>Position Epoch</td><td></td></tr><tr><td>DM</td><td>pc/cm3</td><td>Dispersion Measure</td><td></td></tr><tr><td>START</td><td>MJD</td><td>Time the eph is valid from</td><td></td></tr><tr><td>FINISH</td><td>MJD</td><td>Time the eph is valid till</td><td></td></tr><tr><td>BINARY</td><td>Str</td><td>The binary model used (if any)</td><td></td></tr><tr><td>EPHVER</td><td>Int</td><td>The eph version</td><td>5:tempo2</td></tr><tr><td>CLK</td><td>Str</td><td>Definition of clock to use</td><td></td></tr><tr><td>PMRA</td><td>mas/yr</td><td>Proper mothin in RA</td><td></td></tr><tr><td>PMDEC</td><td>mas/yr</td><td>Proper mothin in DEC</td><td></td></tr><tr><td>PX</td><td>mas</td><td>Parallax</td><td></td></tr><tr><td>NITS</td><td>Int</td><td>Number of fitting interations</td><td></td></tr></tbody></table><p>The parameters for the binary motion are dependent on the binary model used.</p><p>For the <strong>BT</strong> model:</p><table><thead><tr><th>Param</th><th>Units</th><th>Description</th><th>Aliases</th></tr></thead><tbody><tr><td>A1</td><td>ltsec</td><td>projected semimajor axis</td><td></td></tr><tr><td>ECC</td><td></td><td>Eccentricity of the orbit</td><td></td></tr><tr><td>T0</td><td>MJD</td><td>Epoch of periastron</td><td></td></tr><tr><td>PB</td><td>days</td><td>Orbital Period</td><td></td></tr><tr><td>OM</td><td>deg</td><td>Longitude of Periastron</td><td></td></tr><tr><td>ECCDOT</td><td></td><td>First derivitive of ECC</td><td></td></tr><tr><td>XDOT</td><td></td><td>First derivitive of A1</td><td></td></tr><tr><td>OMDOT</td><td>deg/yr</td><td>First derivitive of OM</td><td></td></tr><tr><td>PBDOT</td><td></td><td>First derivitive of PB</td><td></td></tr></tbody></table><h3 id="4-6-Using-tempo2-to-show-the-residuals-and-fit-Ephemeris-for-the-Pulsar"><a href="#4-6-Using-tempo2-to-show-the-residuals-and-fit-Ephemeris-for-the-Pulsar" class="headerlink" title="4.6. Using tempo2 to show the residuals and fit Ephemeris for the Pulsar"></a>4.6. Using tempo2 to show the residuals and fit Ephemeris for the Pulsar</h3><p>The TEMPO2 software package is mainly used in pulsar timing analysis. It d implements pulsar timing algorithms with a precision and accuracy of ~1 ns.  Usually TEMPO2 is used to compare a model for a pulsar’s rotation, position and orbital parameters with actual observations of  pulse arrival times. </p><p>The difference between actual and predicted arrival times are known as the pulsar “timing residuals”. After calculating these timing residuals, TEMPO2 carries out a linear least-squares-fit to improve the parameters in the model. It is possible that the model is too simplistic and does not contain all the phenomena that affect the pulse arrival times. For instance, the pulsar may undergo glitch events, or may have unmodelled binary companions. Various tools exist to study such effects that are not included in the timing model. TEMPO2 can also be used to predict the pulse period and phase at any given time.</p><p>Type:</p><pre class="line-numbers language-bash"><code class="language-bash">tempo2 -gr plk -f J1713+0747.IPTA.par J1713+0747.tim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$$x = 100 * y + z - 10 / 33 + 10 % 3$$</p><p>hangjiangongsh1:  \(a + b\)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190527-sklearn</title>
      <link href="/2019/05/27/20190527-sklearn/"/>
      <url>/2019/05/27/20190527-sklearn/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>scikit-learn是Python的一个第三方开源机器学习模块，它建立在NumPy，SciPy和matplotlib模块之上能够为用户提供各种机器学习算法接口，可以让用户简单、高效地进行数据挖掘和数据分析。<br>其中包括：<br>1.分类（Classification）<br>2.回归（Regression）<br>3.聚类（Clustering）<br>4.数据降维（Dimensionality reduction）<br>5.常用模型（Model selection）<br>6.数据预处理（Preprocessing）</p><h2 id="sklearn安装"><a href="#sklearn安装" class="headerlink" title="sklearn安装"></a>sklearn安装</h2><p>sklearn的目前版本是0.19.1<br>依赖包：<br>Python (&gt;=2.6或&gt;=3.3)<br>NumPy(&gt;=1.6.1)<br>SciPy(&gt;=0.9)</p><p>使用pip安装，terminal直接执行即可</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> -U scikit-learn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用Anaconda安装，推荐Anaconda，因为里面已经内置了NumPy，SciPy等常用工具</p><pre class="line-numbers language-bash"><code class="language-bash">conda <span class="token function">install</span> scikit-learn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后可以在python中检查一下版本，import sklearn不报错，则表示安装成功</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token keyword">import</span> sklearn<span class="token operator">>></span>sklearn<span class="token punctuation">.</span>__version__<span class="token string">'0.19.1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="数据加载（Data-Loading）"><a href="#数据加载（Data-Loading）" class="headerlink" title="数据加载（Data Loading）"></a>数据加载（Data Loading）</h2><h3 id="输入是一个特征矩阵或者csv文件"><a href="#输入是一个特征矩阵或者csv文件" class="headerlink" title="输入是一个特征矩阵或者csv文件"></a>输入是一个特征矩阵或者csv文件</h3><p>首先，数据应该被载入内存中。<br>scikit-learn的实现使用了NumPy中的arrays，所以，我们要使用NumPy来载入csv文件。<br>以下是从UCI机器学习数据仓库中下载的数据。</p><pre><code>import numpy as npimport urllib# url with dataseturl = "http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data"# download the fileraw_data = urllib.urlopen(url)# load the CSV file as a numpy matrixdataset = np.loadtxt(raw_data, delimiter=",")# separate the data from the target attributesX = dataset[:,0:7]y = dataset[:,8]</code></pre><p>我们要使用该数据集作为例子，将特征矩阵作为X，目标变量作为y。</p><p>注意事项：</p><p>（1）可以用浏览器打开那个url，把数据文件保存在本地，然后直接用 np.loadtxt(‘data.txt’, delemiter=”,”) 就可以加载数据了；</p><p>（2）X = dataset[:, 0:7]的意思是：把dataset中的所有行，所有0-7列的数据都保存在X中；</p><h3 id="输入Sklearn自带的部分数据集"><a href="#输入Sklearn自带的部分数据集" class="headerlink" title="输入Sklearn自带的部分数据集"></a>输入Sklearn自带的部分数据集</h3><p>sklearn自带了很多数据集，可以用来对算法进行测试分析，免去了自己再去找数据集的烦恼<br>其中包括：</p><table><thead><tr><th align="center">方法名</th><th align="center">返回数据</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">load_boston([return_X_y])</td><td align="center">波士顿房价数据</td><td align="center">回归</td></tr><tr><td align="center">load_iris([return_X_y])</td><td align="center">鸢尾花数据</td><td align="center">分类</td></tr><tr><td align="center">load_diabetes([return_X_y])</td><td align="center">糖尿病数据集</td><td align="center">回归</td></tr><tr><td align="center">load_linnerud([return_X_y])</td><td align="center">Linnerrud 数据集</td><td align="center">多标签回归</td></tr><tr><td align="center">load_breast_cancer([return_X_y])</td><td align="center">乳腺癌数据集</td><td align="center">分类</td></tr><tr><td align="center">load_wine([return_X_y])</td><td align="center">葡萄酒数据</td><td align="center">分类</td></tr><tr><td align="center">load_digits([n_class, return_X_y])</td><td align="center">手写数字数据集</td><td align="center">分类</td></tr></tbody></table><p>导入数据集，然后选择相应机器学习方法进行训练，训练过程中可以通过一些技巧调整参数，使得学习准确率更高。模型训练完成之后便可预测新数据，然后我们还可以通过MatPlotLib等方法来直观的展示数据。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets<span class="token comment" spellcheck="true">#引入数据集,sklearn包含众多数据集</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token comment" spellcheck="true">#将数据分为测试集和训练集</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier<span class="token comment" spellcheck="true">#利用邻近点方式训练数据</span><span class="token comment" spellcheck="true">###引入数据###</span>iris<span class="token operator">=</span>datasets<span class="token punctuation">.</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#引入iris鸢尾花数据,iris数据包含4个特征变量</span>iris_X<span class="token operator">=</span>iris<span class="token punctuation">.</span>data<span class="token comment" spellcheck="true">#特征变量</span>iris_y<span class="token operator">=</span>iris<span class="token punctuation">.</span>target<span class="token comment" spellcheck="true">#目标值</span>X_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test<span class="token operator">=</span>train_test_split<span class="token punctuation">(</span>iris_X<span class="token punctuation">,</span>iris_y<span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#利用train_test_split进行将训练集和测试集进行分开，test_size占30%</span><span class="token keyword">print</span><span class="token punctuation">(</span>y_train<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#我们看到训练数据的特征值分为3类</span><span class="token triple-quoted-string string">'''[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2] '''</span><span class="token comment" spellcheck="true">###训练数据###</span>knn<span class="token operator">=</span>KNeighborsClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#引入训练方法</span>knn<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#进行填充测试数据进行训练</span><span class="token comment" spellcheck="true">###预测数据###</span><span class="token keyword">print</span><span class="token punctuation">(</span>knn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#预测特征值</span><span class="token triple-quoted-string string">'''[1 1 1 0 2 2 1 1 1 0 0 0 2 2 0 1 2 2 0 1 0 0 0 0 0 0 2 1 0 0 0 1 0 2 0 2 0 1 2 1 0 0 1 0 2]'''</span><span class="token keyword">print</span><span class="token punctuation">(</span>y_test<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#真实特征值</span><span class="token triple-quoted-string string">'''[1 1 1 0 1 2 1 1 1 0 0 0 2 2 0 1 2 2 0 1 0 0 0 0 0 0 2 1 0 0 0 1 0 2 0 2 0 1 2 1 0 0 1 0 2]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自己构造数据集"><a href="#自己构造数据集" class="headerlink" title="自己构造数据集"></a>自己构造数据集</h3><p>Sklearn提供一些标准数据，我们不必再从其他网站寻找数据进行训练。例如我们上面用来训练的load_iris数据，可以很方便的返回数据特征变量和目标值。除了引入数据之外，我们还可以通过load_sample_images()来引入图片。<br>除了sklearn提供的一些数据之外，还可以自己来构造一些数据帮助我们学习。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets<span class="token comment" spellcheck="true">#引入数据集</span><span class="token comment" spellcheck="true">#构造的各种参数可以根据自己需要调整</span>X<span class="token punctuation">,</span>y<span class="token operator">=</span>datasets<span class="token punctuation">.</span>make_regression<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>n_features<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>n_targets<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>noise<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">###绘制构造的数据###</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据特征缩放"><a href="#数据特征缩放" class="headerlink" title="数据特征缩放"></a>数据特征缩放</h2><p>因为对于大多数的机器学习算法和优化算法来说，将特征值缩放到相同区间可以使得获取性能更好的模型。就梯度下降算法而言，例如有两个不同的特征，第一个特征的取值范围为1<del>10，第二个特征的取值范围为1</del>10000。在梯度下降算法中，代价函数为最小平方误差函数，所以在使用梯度下降算法的时候，算法会明显的偏向于第二个特征，因为它的取值范围更大。在比如，k近邻算法，它使用的是欧式距离，也会导致其偏向于第二个特征。对于决策树和随机森林以及XGboost算法而言，特征缩放对于它们没有什么影响。</p><p>用的特征缩放算法有两种，归一化(normalization)和标准化(standardization)。归一化算法是通过特征的最大最小值将特征缩放到[0,1]区间范围内，而多于许多机器学习算法，标准化也许会更好，标准化是通过特征的平均值和标准差将特征缩放成一个标准的正态分布，均值为0，方差为1。</p><h3 id="归一化（Normalization）"><a href="#归一化（Normalization）" class="headerlink" title="归一化（Normalization）"></a>归一化（Normalization）</h3><p>1、把数变为（0，1）之间的小数。主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，更加便捷快速。<br>2、把有量纲表达式变为无量纲表达式。归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。</p><p>归一化算法有：</p><p>1.线性转换（Min-Max） （常用）</p><p>　  y=(x-MinValue)/(MaxValue-MinValue)</p><p>２.对数函数转换：</p><pre><code> y=log10(x)</code></pre><p>３.反余切函数转换</p><pre><code> y=atan(x)*2/PI</code></pre><p>４.线性也与对数函数结合</p><pre><code> 式(1)将输入值换算为[-1,1]区间的值， 在输出层用式(2)换算回初始值，其中和分别表示训练样本集中负荷的最大值和最小值。</code></pre><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>数据的标准化是将数据按比例缩放，使之落入一个小的特定区间。由于信用指标体系的各个指标度量单位是不同的，为了能够将指标参与评价计算，需要对指标进行规范化处理，通过函数变换将其数值映射到某个数值区间。</p><p>标准化算法有：</p><p>1.z-score标准化(或零－均值标准化)（常用）</p><p>　y=(x-X的平均值)／X的标准差=(x-mean)/std </p><p>  优点：当X的最大值和最小值未知，或孤立点左右了最大－最小规范化时，该方法有用</p><p>2.最小－最大规范化(线性变换)</p><p>   y=( (x-MinValue) / (MaxValue-MinValue) )(new_MaxValue-new_MinValue)+new_minValue</p><p>３.小数定标规范化：通过移动X的小数位置来进行规范化</p><p>　 y= x/10的j次方　　(其中,j使得Max(|y|) &lt;1的最小整数</p><p>４.对数Logistic模式：</p><pre><code>新数据=1/（1+e^(-原数据)）</code></pre><p>５.模糊量化模式：</p><pre><code>新数据=1/2+1/2sin[派3.1415/（极大值-极小值）*（X-（极大值-极小值）/2） ]       X为原数据</code></pre><h3 id="正则化（Regulation）"><a href="#正则化（Regulation）" class="headerlink" title="正则化（Regulation）"></a>正则化（Regulation）</h3><p>用一组与原不适定问题相“邻近”的适定问题的解，去逼近原问题的解，这种方法称为正则化方法。如何建立有效的正则化方法是反问题领域中不适定问题研究的重要内容。通常的正则化方法有基于变分原理的Tikhonov 正则化、各种迭代方法以及其它的一些改进方法。</p><p>首先求出样本的p-范数，然后该样本的所有元素都要除以该范数，这样最终使得每个样本的范数都为1</p><pre class="line-numbers language-python"><code class="language-python">new_X <span class="token operator">=</span> sk_preprocessing<span class="token punctuation">.</span>normalize<span class="token punctuation">(</span>X<span class="token punctuation">,</span>norm<span class="token operator">=</span><span class="token string">'l2'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'求二范数'</span><span class="token punctuation">,</span>new_X<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印结果：</p><pre class="line-numbers language-python"><code class="language-python">规范化到一定区间内 <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.40824829</span> <span class="token operator">-</span><span class="token number">0.40824829</span>  <span class="token number">0.81649658</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">.</span>          <span class="token number">0.89442719</span> <span class="token operator">-</span><span class="token number">0.4472136</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">.</span>          <span class="token number">0.4472136</span>  <span class="token operator">-</span><span class="token number">0.89442719</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，归一化是为了消除不同数据之间的量纲，方便数据比较和共同处理，比如在神经网络中，归一化可以加快训练网络的收敛性；标准化是为了方便数据的下一步处理，而进行的数据缩放等变换，并不是为了方便与其他数据一同处理或比较，比如数据经过零-均值标准化后，更利于使用标准正态分布的性质，进行处理；正则化而是利用先验知识，在处理过程中引入正则化因子(regulator)，增加引导约束的作用，比如在逻辑回归中使用正则化，可有效降低过拟合的现象。</p><h2 id="特征选择-Feature-Selection"><a href="#特征选择-Feature-Selection" class="headerlink" title="特征选择(Feature Selection)"></a>特征选择(Feature Selection)</h2><p>在解决一个实际问题的过程中，选择合适的特征或者构建特征的能力特别重要。这成为特征选择或者特征工程。<br>特征选择时一个很需要创造力的过程，更多的依赖于直觉和专业知识，并且有很多现成的算法来进行特征的选择。<br>下面的树算法(Tree algorithms)计算特征的信息量：</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> ExtraTreesClassifiermodel <span class="token operator">=</span> ExtraTreesClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># display the relative importance of each attribute</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>feature_importances_<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出每个特征的重要程度：</p><pre><code>[ 0.13784722  0.15383598  0.25451389  0.17476852  0.02847222  0.12314815  0.12741402]</code></pre><h2 id="数据模型（Sklearn-Model）"><a href="#数据模型（Sklearn-Model）" class="headerlink" title="数据模型（Sklearn Model）"></a>数据模型（Sklearn Model）</h2><h3 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h3><p>大多数问题都可以归结为二元分类问题。这个算法的优点是可以给出数据所在类别的概率</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegressionmodel <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'MODEL'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make predictions</span>expected <span class="token operator">=</span> ypredicted <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># summarize the fit of the model</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'RESULT'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CONFUSION MATRIX'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>confusion_matrix<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python"><code class="language-python">MODELLogisticRegression<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> class_weight<span class="token operator">=</span>None<span class="token punctuation">,</span> dual<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> fit_intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>          intercept_scaling<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> multi_class<span class="token operator">=</span><span class="token string">'ovr'</span><span class="token punctuation">,</span>          penalty<span class="token operator">=</span><span class="token string">'l2'</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span>None<span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">'liblinear'</span><span class="token punctuation">,</span> tol<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">,</span>          verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>RESULT             precision    recall  f1<span class="token operator">-</span>score   support        <span class="token number">0.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">4</span>        <span class="token number">1.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">6</span>avg <span class="token operator">/</span> total       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>        <span class="token number">10</span>CONFUSION MATRIX<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯(Naive Bayes)"></a>朴素贝叶斯(Naive Bayes)</h3><p>这也是著名的机器学习算法，该方法的任务是还原训练样本数据的分布密度，其在多类别分类中有很好的效果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>naive_bayes <span class="token keyword">import</span> GaussianNBmodel <span class="token operator">=</span> GaussianNB<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'MODEL'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make predictions</span>expected <span class="token operator">=</span> ypredicted <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># summarize the fit of the model</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'RESULT'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'CONFUSION MATRIX'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>confusion_matrix<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python"><code class="language-python">MODELGaussianNB<span class="token punctuation">(</span><span class="token punctuation">)</span>RESULT             precision    recall  f1<span class="token operator">-</span>score   support        <span class="token number">0.0</span>       <span class="token number">0.80</span>      <span class="token number">1.00</span>      <span class="token number">0.89</span>         <span class="token number">4</span>        <span class="token number">1.0</span>       <span class="token number">1.00</span>      <span class="token number">0.83</span>      <span class="token number">0.91</span>         <span class="token number">6</span>avg <span class="token operator">/</span> total       <span class="token number">0.92</span>      <span class="token number">0.90</span>      <span class="token number">0.90</span>        <span class="token number">10</span>CONFUSION MATRIX<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="k近邻-k-Nearest-Neighbours"><a href="#k近邻-k-Nearest-Neighbours" class="headerlink" title="k近邻(k-Nearest Neighbours)"></a>k近邻(k-Nearest Neighbours)</h3><p>k近邻算法常常被用作是分类算法一部分，比如可以用它来评估特征，在特征选择上我们可以用到它。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier<span class="token comment" spellcheck="true"># fit a k-nearest neighbor model to the data</span>model <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make predictions</span>expected <span class="token operator">=</span> ypredicted <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># summarize the fit of the model</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>confusion_matrix<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-python"><code class="language-python">KNeighborsClassifier<span class="token punctuation">(</span>algorithm<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> leaf_size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">'minkowski'</span><span class="token punctuation">,</span>           metric_params<span class="token operator">=</span>None<span class="token punctuation">,</span> n_neighbors<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> weights<span class="token operator">=</span><span class="token string">'uniform'</span><span class="token punctuation">)</span>             precision    recall  f1<span class="token operator">-</span>score   support        <span class="token number">0.0</span>       <span class="token number">0.75</span>      <span class="token number">0.75</span>      <span class="token number">0.75</span>         <span class="token number">4</span>        <span class="token number">1.0</span>       <span class="token number">0.83</span>      <span class="token number">0.83</span>      <span class="token number">0.83</span>         <span class="token number">6</span>avg <span class="token operator">/</span> total       <span class="token number">0.80</span>      <span class="token number">0.80</span>      <span class="token number">0.80</span>        <span class="token number">10</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a>决策树(Decision Tree)</h3><p>分类与回归树(Classification and Regression Trees ,CART)算法常用于特征含有类别信息的分类或者回归问题，这种方法非常适用于多分类情况。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeClassifier<span class="token comment" spellcheck="true"># fit a CART model to the data</span>model <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make predictions</span>expected <span class="token operator">=</span> ypredicted <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># summarize the fit of the model</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>confusion_matrix<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python"><code class="language-python">DecisionTreeClassifier<span class="token punctuation">(</span>class_weight<span class="token operator">=</span>None<span class="token punctuation">,</span> criterion<span class="token operator">=</span><span class="token string">'gini'</span><span class="token punctuation">,</span> max_depth<span class="token operator">=</span>None<span class="token punctuation">,</span>            max_features<span class="token operator">=</span>None<span class="token punctuation">,</span> max_leaf_nodes<span class="token operator">=</span>None<span class="token punctuation">,</span> min_samples_leaf<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>            min_samples_split<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> min_weight_fraction_leaf<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span>            random_state<span class="token operator">=</span>None<span class="token punctuation">,</span> splitter<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>             precision    recall  f1<span class="token operator">-</span>score   support        <span class="token number">0.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">4</span>        <span class="token number">1.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">6</span>avg <span class="token operator">/</span> total       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>        <span class="token number">10</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="支持向量机-Support-Vector-Machine"><a href="#支持向量机-Support-Vector-Machine" class="headerlink" title="支持向量机(Support Vector Machine)"></a>支持向量机(Support Vector Machine)</h3><p>SVM是非常流行的机器学习算法，主要用于分类问题，如同逻辑回归问题，它可以使用一对多的方法进行多类别的分类。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVC<span class="token comment" spellcheck="true"># fit a SVM model to the data</span>model <span class="token operator">=</span> SVC<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># make predictions</span>expected <span class="token operator">=</span> ypredicted <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># summarize the fit of the model</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>confusion_matrix<span class="token punctuation">(</span>expected<span class="token punctuation">,</span> predicted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python"><code class="language-python">SVC<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> cache_size<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">,</span> class_weight<span class="token operator">=</span>None<span class="token punctuation">,</span> coef0<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> degree<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span>  kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> probability<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span>None<span class="token punctuation">,</span>  shrinking<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> tol<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>             precision    recall  f1<span class="token operator">-</span>score   support        <span class="token number">0.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">4</span>        <span class="token number">1.0</span>       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>         <span class="token number">6</span>avg <span class="token operator">/</span> total       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>        <span class="token number">10</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190515 Sardinia</title>
      <link href="/2019/05/14/20190515-Sardinia/"/>
      <url>/2019/05/14/20190515-Sardinia/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><center>**Slides for EPTA Sardinia**</center><br> <div class="row">    <embed src="https://astrondog.github.io/file/20190515_EPTA_SARDINIA.pdf" width="100%" height="550" type="application/pdf"></div><br><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
            <tag> Meeting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex Presentation Notes</title>
      <link href="/2019/05/06/20190506-latex-ppt/"/>
      <url>/2019/05/06/20190506-latex-ppt/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Standard-Frame"><a href="#Standard-Frame" class="headerlink" title="Standard Frame"></a>Standard Frame</h3><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\documentclass</span><span class="token punctuation">{</span><span class="token keyword">beamer</span><span class="token punctuation">}</span><span class="token function selector">\usepackage</span><span class="token punctuation">[</span>english<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">babel</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">%如果去掉，中英混合会出错</span><span class="token function selector">\usepackage</span><span class="token punctuation">[</span>noindent<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">ctex</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">%可使用 \usepackage{CJK}</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">beamerthemesplit</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">% Or whatever. Note that the encoding and the font should match. If T1</span><span class="token comment" spellcheck="true">% does not look nice, try deleting the line with the fontenc.</span><span class="token function selector">\usepackage</span><span class="token punctuation">[</span>T1<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">fontenc</span><span class="token punctuation">}</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">times</span><span class="token punctuation">}</span> <span class="token function selector">\usetheme</span><span class="token punctuation">{</span>Berkeley<span class="token punctuation">}</span> <span class="token function selector">\title</span><span class="token punctuation">{</span>XXXX<span class="token punctuation">}</span> <span class="token function selector">\subtitle</span><span class="token punctuation">{</span>XXXX<span class="token punctuation">}</span> <span class="token function selector">\author</span><span class="token punctuation">{</span>Ofey<span class="token punctuation">}</span> <span class="token function selector">\institute</span><span class="token punctuation">{</span>  School of Computer Science<span class="token function selector">\\</span>  Beijing Institute of Technology<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">% This is only inserted into the PDF information catalog. Can be left out.</span><span class="token function selector">\subject</span><span class="token punctuation">{</span>OOO<span class="token punctuation">}</span><span class="token function selector">\keywords</span><span class="token punctuation">{</span>OXOX<span class="token punctuation">}</span> <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span> <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span class="token punctuation">{</span>XXXX<span class="token punctuation">}</span>A normal frame.<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span> <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Multiple Authors and Institutions</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\author</span><span class="token punctuation">{</span>F.~Author<span class="token function selector">\inst</span><span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token function selector">\and</span> S.~Another<span class="token function selector">\inst</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token function selector">\institute</span><span class="token punctuation">[</span>Universities of Somewhere and Elsewhere<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">% (optional, but mostly needed) </span><span class="token punctuation">{</span>     <span class="token function selector">\inst</span><span class="token punctuation">{</span>1<span class="token punctuation">}</span><span class="token comment" spellcheck="true">% </span>    University of Somewhere     <span class="token function selector">\inst</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token comment" spellcheck="true">% </span>    University of Elsewhere<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Table-of-Content"><a href="#Table-of-Content" class="headerlink" title="Table of Content"></a>Table of Content</h3><h4 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h4><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span>  <span class="token function selector">\tableofcontents</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有时，可能目录太多，想分成两栏，可以使用multicol包</p><h4 id="Complex"><a href="#Complex" class="headerlink" title="Complex"></a>Complex</h4><pre class="line-numbers language-latex"><code class="language-latex"><span class="token comment" spellcheck="true">% This environment allows switching between one and multicolumn format on the same page</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">multicol</span><span class="token punctuation">}</span> <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span class="token punctuation">{</span>Outline<span class="token punctuation">}</span>   <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">multicols</span><span class="token punctuation">}</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span>    <span class="token function selector">\tableofcontents</span>    <span class="token comment" spellcheck="true">% You might wish to add the option [pausesections]</span>  <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">multicols</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Only-Show-Selecetd-Section"><a href="#Only-Show-Selecetd-Section" class="headerlink" title="Only Show Selecetd Section"></a>Only Show Selecetd Section</h4><pre class="line-numbers language-latex"><code class="language-latex">有时，可能不想显示subsection之类，亦或者只想限制指定的几个section，如下：<span class="token function selector">\tableofcontents</span><span class="token punctuation">[</span>hidesubsections,sections=<span class="token punctuation">{</span>&lt;1-4><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">%显示1-4section，不显示subsection</span><span class="token function selector">\tableofcontents</span>还有很多其他参数设置，详见文档。若想在没个章节前显示下目录提示，可以如下代码：<span class="token function selector">\AtBeginSection</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span>    <span class="token function selector">\frametitle</span><span class="token punctuation">{</span><span class="token headline class-name">Outline</span><span class="token punctuation">}</span>     <span class="token function selector">\tableofcontents</span><span class="token punctuation">[</span>currentsection,hideothersubsections<span class="token punctuation">]</span>   <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span>   <span class="token function selector">\addtocounter</span><span class="token punctuation">{</span>framenumber<span class="token punctuation">}</span><span class="token punctuation">{</span>-1<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">%目录页不计算页码</span><span class="token punctuation">}</span>不过没发现如何获得当前section的数值，这样我就可以自动在每张前插入目录，且使当前目录为第一。当然，还可以做成一个个显示目录的动画效果，不过没啥实际意义- -！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Interlinkage"><a href="#Interlinkage" class="headerlink" title="Interlinkage"></a>Interlinkage</h3><p>slides中的链接<br>有时想在slides中加入超链接，可以跳转到指定的页面，这个也是很easy的。<br>给欲跳转到的frame加上label</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\frame</span><span class="token punctuation">[</span>label = XXX<span class="token punctuation">]</span><span class="token punctuation">{</span>  <span class="token function selector">\frametitle</span><span class="token punctuation">{</span><span class="token headline class-name">OOO</span><span class="token punctuation">}</span>  <span class="token function selector">\framesubtitle</span><span class="token punctuation">{</span>XXX<span class="token punctuation">}</span>  OOXX<span class="token punctuation">}</span>再在想加入超链接的地方加入：  <span class="token function selector">\hyperlink</span><span class="token punctuation">{</span>XXX<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token function selector">\beamergotobutton</span><span class="token punctuation">{</span>乃想显示的文本<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">%\beamergotobutton可以选其他的按钮</span>显示时间+页数这个根据不同的主题不一样，比如Berkeley默认就木有，而CambridgeUS就是有的，可以自己在导言区加入：<span class="token function selector">\setbeamertemplate</span><span class="token punctuation">{</span>footline<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">%</span>  <span class="token function selector">\leavevmode</span><span class="token comment" spellcheck="true">%</span>  <span class="token function selector">\hbox</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">%</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token punctuation">[</span>wd=.333333<span class="token function selector">\paperwidth</span>,ht=2.25ex,dp=1ex,center<span class="token punctuation">]</span><span class="token punctuation">{</span>author in head/foot<span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>      <span class="token function selector">\usebeamerfont</span><span class="token punctuation">{</span>author in head/foot<span class="token punctuation">}</span><span class="token function selector">\insertshortauthor</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token punctuation">[</span>wd=.333333<span class="token function selector">\paperwidth</span>,ht=2.25ex,dp=1ex,center<span class="token punctuation">]</span><span class="token punctuation">{</span>title in head/foot<span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>      <span class="token function selector">\usebeamerfont</span><span class="token punctuation">{</span>title in head/foot<span class="token punctuation">}</span><span class="token function selector">\insertshorttitle</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token punctuation">[</span>wd=.333333<span class="token function selector">\paperwidth</span>,ht=2.25ex,dp=1ex,right<span class="token punctuation">]</span><span class="token punctuation">{</span>date in head/foot<span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>      <span class="token function selector">\usebeamerfont</span><span class="token punctuation">{</span>date in head/foot<span class="token punctuation">}</span><span class="token function selector">\insertshortdate</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function selector">\hspace*</span><span class="token punctuation">{</span>2em<span class="token punctuation">}</span>      <span class="token function selector">\insertframenumber</span><span class="token punctuation">{</span><span class="token punctuation">}</span> / <span class="token function selector">\inserttotalframenumber</span><span class="token function selector">\hspace*</span><span class="token punctuation">{</span>2ex<span class="token punctuation">}</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">beamercolorbox</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">%</span>  <span class="token function selector">\vskip</span>0pt<span class="token comment" spellcheck="true">%</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Footline"><a href="#Footline" class="headerlink" title="Footline"></a>Footline</h3><p>页脚显示文本<br>有时希望在frame的左下角页脚能显示一些内容，并不是为了报告时如何，只是给其他途径看slides的人一点更详尽的解释、资料，但是又不想用脚注(脚注在beamer效果不咋的)。</p><pre><code>% add text to beamer footline \makeatletter% add a macro that saves its argument\newcommand{\footlineextra}[1]{\gdef\insertfootlineextra{#1}}\newbox\footlineextrabox % add a beamer template that sets the saved argument in a box.% The * means that the beamer font and color "footline extra" are automatically added. \defbeamertemplate*{footline extra}{default}{  \begin{beamercolorbox}[ht=2.25ex,dp=1ex,leftskip=\Gm@lmargin]{footline extra}    \insertfootlineextra    % \par\vspace{2.5pt}  \end{beamercolorbox}} \addtobeamertemplate{footline}{%  % set the box with the extra footline material but make it add no vertical space  \setbox\footlineextrabox=\vbox{\usebeamertemplate*{footline extra}}  \vskip -\ht\footlineextrabox  \vskip -\dp\footlineextrabox  \box\footlineextrabox%}{} % patch \begin{frame} to reset the footline extra material\let\beamer@original@frame=\frame\def\frame{\gdef\insertfootlineextra{}\beamer@original@frame}\footlineextra{}\makeatother使用很简单：\footlineextra{XXXX}</code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>LATEX最爽的几点之一就是参考文献的管理使用啊，毕设论文得用doc的泪奔T.T<br>一般用的比较多的是bibtex，首先，自己搞定bib文件，然后slides中加上一页来放引用文献</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token comment" spellcheck="true">%一般的引用样式只是[1]类，paper中这样没啥，slides这样不够友好</span><span class="token comment" spellcheck="true">%apalike：美国心理学学会期刊样式，显示作者名+年份</span><span class="token function selector">\bibliographystyle</span><span class="token punctuation">{</span>apalike<span class="token punctuation">}</span>   <span class="token function selector">\bibliography</span><span class="token punctuation">{</span>XXX<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">%引用的XXX.bib文件</span>此外，reference可能较多，slides一页一般都不够用，beamer是可以自动分成多页的，如下：<span class="token comment" spellcheck="true">% If there are too many of them to fit on the frame, </span><span class="token comment" spellcheck="true">% you must manually split them among additional frames or use the allowframebreaks option.</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span class="token punctuation">[</span>allowframebreaks<span class="token punctuation">]</span><span class="token punctuation">{</span>References<span class="token punctuation">}</span>   <span class="token function selector">\scriptsize</span>  <span class="token function selector">\bibliographystyle</span><span class="token punctuation">{</span>apalike<span class="token punctuation">}</span>  <span class="token function selector">\bibliography</span><span class="token punctuation">{</span>XXX<span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">frame</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用，自然是\cite{}命令了</p><h3 id="Tabel"><a href="#Tabel" class="headerlink" title="Tabel"></a>Tabel</h3><p>有时，需要画一些表格，可能比较复杂，比如可能需要合并几行，或者几列，下面一个示例：<br>导言区加上</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">multirow</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">% The \cline command draws horizontal lines across the columns specified,</span>�ginning in column i and ending in column j, which are identified in the mandatory argument.<span class="token comment" spellcheck="true">% \cline{i-j}</span>  <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>c|c|c|c<span class="token punctuation">}</span>      <span class="token function selector">\hline</span>      <span class="token comment" spellcheck="true">% \multicolumn{2}{c}{\backslashbox{Name}{Numer}} &amp;  \multicolumn{2}{c}{}\\ \hline</span>      <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>*<span class="token punctuation">}</span><span class="token punctuation">{</span>CleanEval<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>*<span class="token punctuation">}</span><span class="token punctuation">{</span>CleanEval-Eng<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> training set <span class="token punctuation">&amp;</span> 60 <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>3-4<span class="token punctuation">}</span>       <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>*<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>          <span class="token punctuation">&amp;</span> <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>*<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>              <span class="token punctuation">&amp;</span> evaluation set <span class="token punctuation">&amp;</span>   864 <span class="token function selector">\\</span> <span class="token function selector">\hline</span>        <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span>CETD<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> NYTimes      <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>100<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>2-4<span class="token punctuation">}</span>       <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token punctuation">&amp;</span> Yahoo!       <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>100<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>2-4<span class="token punctuation">}</span>       <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token punctuation">&amp;</span> Wikipedia    <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>100<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>2-4<span class="token punctuation">}</span>      <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token punctuation">&amp;</span> BBC          <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>100<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>2-4<span class="token punctuation">}</span>      <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token punctuation">&amp;</span> Ars Technica <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>100<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\cline</span><span class="token punctuation">{</span>2-4<span class="token punctuation">}</span>      <span class="token function selector">\multirow</span><span class="token punctuation">{</span>6<span class="token punctuation">}</span>*<span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token punctuation">&amp;</span> Chaos        <span class="token punctuation">&amp;</span> <span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span>200<span class="token punctuation">}</span> <span class="token function selector">\\</span> <span class="token function selector">\hline</span>     <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span>  <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sidebar"><a href="#Sidebar" class="headerlink" title="Sidebar"></a>Sidebar</h3><p>Berkeley主题中的sidebar默认显示所有的subsection，并且在显示对应的页时，高亮相应的section。对此可以作一些自定义。<br>一般章节较多时，sidebar就很不友好了，显示不全，间距还大，别扭，只是取消显示subsection,一句话搞定</p><p>\usetheme[hideallsubsections]{Berkeley}<br>一种更好的sidebar显示方式：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token comment" spellcheck="true">% By default, the current entry of the table of contents in the sidebar will be highlighted by using a more vibrant color.</span><span class="token comment" spellcheck="true">% A good alternative is to highlight the current entry by using a different color for the background of the current point.</span><span class="token comment" spellcheck="true">% The color theme sidebartab installs the appropriate colors</span> <span class="token function selector">\usecolortheme</span><span class="token punctuation">{</span>sidebartab<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Figures"><a href="#Figures" class="headerlink" title="Figures"></a>Figures</h3><p>beamer仿佛默认是不显示图标标号的默认值是Figure：XXX</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token comment" spellcheck="true">% show fig and table number</span><span class="token function selector">\setbeamertemplate</span><span class="token punctuation">{</span>caption<span class="token punctuation">}</span><span class="token punctuation">[</span>numbered<span class="token punctuation">]</span><span class="token comment" spellcheck="true">% show theorems and example number</span><span class="token function selector">\setbeamertemplate</span><span class="token punctuation">{</span>theorems<span class="token punctuation">}</span><span class="token punctuation">[</span>numbered<span class="token punctuation">]</span>字体大小beamer中某人的一些项目字体太大，比如样例example，可以在导言区自定义<span class="token function selector">\setbeamerfont</span><span class="token punctuation">{</span>example<span class="token punctuation">}</span><span class="token punctuation">{</span>size=<span class="token function selector">\tiny</span><span class="token punctuation">}</span><span class="token function selector">\setbeamerfont</span><span class="token punctuation">{</span>algorithm<span class="token punctuation">}</span><span class="token punctuation">{</span>size=<span class="token function selector">\scriptsize</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Text-Size"><a href="#Text-Size" class="headerlink" title="Text Size"></a>Text Size</h3><p>\tiny<br>\scriptsize<br>\footnotesize<br>\small<br>\normalsize<br>\large<br>\Large<br>\LARGE<br>\huge<br>\Huge</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Usage and Theme Beautify</title>
      <link href="/2019/03/29/20190329-hexo-usage/"/>
      <url>/2019/03/29/20190329-hexo-usage/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h3><p>Hexo 是一个基于 Node.js 的静态站点生成框架，快速、简洁且高效。Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><ul><li>首先需要在系统中安装git并进行基本配置</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span><span class="token function">git</span> config --global user.name <span class="token string">"username"</span><span class="token function">git</span> config --global user.email <span class="token string">"youremail"</span><span class="token function">git</span> clone repo_url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装Node-js-和-nvm"><a href="#安装Node-js-和-nvm" class="headerlink" title="安装Node.js 和 nvm"></a>安装Node.js 和 nvm</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> nodejs<span class="token comment" spellcheck="true"># nodejs的管理工具</span><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="安装Hexo-及初始化"><a href="#安装Hexo-及初始化" class="headerlink" title="安装Hexo 及初始化"></a>安装Hexo 及初始化</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -ghexo init myblog<span class="token function">cd</span> myblog<span class="token function">npm</span> <span class="token function">install</span>hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果报错执行代码,不报错忽略</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> config <span class="token keyword">set</span> user 0<span class="token function">sudo</span> <span class="token function">npm</span> config <span class="token keyword">set</span> unsafe-perm <span class="token boolean">true</span><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问<a href="http://localhost:4000，会看到生成好的博客。">http://localhost:4000，会看到生成好的博客。</a></p><h4 id="github-配置"><a href="#github-配置" class="headerlink" title="github 配置"></a>github 配置</h4><ol><li><p>注册一个github账户，成为(re)poer。</p></li><li><p>打开个人的profile，点击右上角的+，new一个repository（新建一个仓库），注意，要将你的repository name设置为[username.github.io]，这一步很重要。然后其它的不用管，直接create repository。</p></li><li><p>配置ssh keys，在settings中打开SSH and GPG keys，new一个ssh key。在下面的输入框中填写的你本机的ssh公钥，使用ssh-keygen -t rsa -C “youremail”，在你的用户目录下找到.ssh目录中的id_rsa.pub的内容，也就是你本机ssh公钥，然后点击添加。可以使用cat id_rsa.pub查看其中的内容。</p></li><li><p>验证：ssh -T <a href="mailto:git@github.com">git@github.com</a>，看到successfully就说明配置完成了。</p></li><li><p>修改Hexo部分默认配置</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /opt/blogvim _config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#启动Git部署，位于Deployment部分</span>deploy:    type: <span class="token function">git</span>    repo: git@github.com:BoView/BoView.github.io.git <span class="token comment" spellcheck="true">#换成自己的用户名和仓库名</span>    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Hexo-常用指令"><a href="#Hexo-常用指令" class="headerlink" title="Hexo 常用指令"></a>Hexo 常用指令</h4><ul><li>新建博客项目，默认为指定的folder文件夹;</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo init <span class="token punctuation">[</span>folder<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>新建文章，总共有post、draft、page三种layout，文章以你指定的title名创建，title中如果有空格请使用“”括起来;</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token string">"title"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成静态文件，下面的代码为简写，可以添加-w参数监视文件的变动;</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo generatehexo g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>启动本地服务器，可以添加参数-p指定服务器的端口，默认在端口4000</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo serverhexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>博客项目部署</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo deployhexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一键静态文件生成与部署</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo g -dhexo d -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>清楚缓存和生成的静态文件，对应于db.json和public目录下的文件</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo cleanhexo cl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>列出博客文件树</li></ul><pre class="line-numbers language-bash"><code class="language-bash">hexo list route<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="绑定域名（阿里云上申请的域名，解析到服务器）"><a href="#绑定域名（阿里云上申请的域名，解析到服务器）" class="headerlink" title="绑定域名（阿里云上申请的域名，解析到服务器）"></a>绑定域名（阿里云上申请的域名，解析到服务器）</h4><p>添加三条解析：<br>前两条选择A记录类型，主机记录设置为@，线路选择默认，TTL选择600，记录值分别为192.30.252.153、192.30.252.154；<br>后一条选择CNAME记录类型，主机记录设置为www，线路选择默认，TTL选择600，记录值为github的仓库名boview.github.io。</p><p>在hexo里配置CNAME</p><pre class="line-numbers language-bash"><code class="language-bash">vim /opt/blog/source/CNAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">www.sunlinbo.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：这里加上www，那么浏览器里就只有加上www才能够访问;这里不加www，那么浏览器里加不加上www都能够访问。</p><h3 id="Hexo-的Next主题美化"><a href="#Hexo-的Next主题美化" class="headerlink" title="Hexo 的Next主题美化"></a>Hexo 的Next主题美化</h3><h4 id="主题安装及基本配置："><a href="#主题安装及基本配置：" class="headerlink" title="主题安装及基本配置："></a>主题安装及基本配置：</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/theme-next/hexo-theme-next themes/next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，打开 站点配置文件,找到 theme 字段，并将其值更改为 next， 保存并依次执行git clean，git g,git s 然后查看运行结果。</p><p>nexT主题有四种选择，上面这个只是最简洁的一种，我选择的是Muse布局</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol><li><p>顶部图片设置</p></li><li><p>设置头像及旋转<br>找一张你喜欢的头像图片放入 myblog/themes/next/source/images 目录中，例如我这里放了一张logo.jpg。然后打开 myblog/themes/next/_config.yml 主题配置文件。找到关键字 avatar, 在后面加入 logo.jpg 的路径地址（注意：是想相对路径）。</p></li></ol><p>在~/hexo/themes/next/source/css/_custom文件夹下的costom.styl文件内添加以下代码：</p><pre class="line-numbers language-bash"><code class="language-bash">// 侧栏头像圆形及旋转效果.site-author-image <span class="token punctuation">{</span>    border: 0px solid rgb<span class="token punctuation">(</span>255, 255, 255<span class="token punctuation">)</span><span class="token punctuation">;</span>    border-radius: 100%<span class="token punctuation">;</span>    transition: transform 1.0s ease-out<span class="token punctuation">;</span><span class="token punctuation">}</span>img:hover <span class="token punctuation">{</span>    transform: rotateZ<span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>.posts-expand .post-body img:hover <span class="token punctuation">{</span>    transform: initial<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>设置网站的图标Favicon</li></ol><p>下载一个32 * 32的图片，并改名为favicon.ico, 然后放到/blog/themes/next/source/images目录</p><p>修改主题配置文件</p><pre class="line-numbers language-bash"><code class="language-bash">    favicon:    　small: /images/favicon-16x16-next.png    　medium: /images/favicon.ico    　apple_touch_icon: /images/apple-touch-icon-next.png    　safari_pinned_tab: /images/logo.svg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>文章加密访问</li></ol><p>在　/blog/themes/next/layout/_partials/head/head.swig 文件中添加：</p><pre class="line-numbers language-bash"><code class="language-bash">  <span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token punctuation">(</span>function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          if<span class="token punctuation">(</span><span class="token string">'{{ page.password }}'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>prompt<span class="token punctuation">(</span><span class="token string">'请输入文章密码'</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">'{{ page.password }}'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  alert<span class="token punctuation">(</span><span class="token string">'密码错误！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  history.back<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span>/script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在需要加密的文章的页面顶部(Front matter区域)加入 “password : 设置密码值”</p><ol start="6"><li><p>修改文章底部的那个带#号的标签<br>修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成<i class="fa fa-tag"></i></p></li><li><p>隐藏网页底部powered By Hexo / 强力驱动<br>打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。</p></li><li><p>侧边栏社交链接</p></li></ol><p>修改主题配置文件: 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址</p><pre class="line-numbers language-bash"><code class="language-bash">  <span class="token comment" spellcheck="true">#设置侧边栏社交链</span>  social:    GitHub: https://github.com/zzwwqq <span class="token operator">||</span> github    E-Mail: mailto:zwq13264860490@gmail.com <span class="token operator">||</span> envelope    Weibo: https://weibo.com/u/5564810309/home?wvr<span class="token operator">=</span>5 <span class="token operator">||</span> weibo    知乎: https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities <span class="token operator">||</span> snapchat  ​  <span class="token comment" spellcheck="true">#这里键的值必须和上面social中的 "||" 后面指定的名称一致，在fontawesome官网找喜欢的小图标，将名字复制在如下位置，如E-Mail:对应的图标名称为envelope。</span>  ​  social_icons:    enable: <span class="token boolean">true</span>    <span class="token comment" spellcheck="true"># `enable` 选项用于控制是否显示图标</span>    icons_only: <span class="token boolean">false</span>    transition: <span class="token boolean">false</span>     <span class="token comment" spellcheck="true">#图标</span>    GitHub: github    E-Mail: envelope    Weibo: weibo    知乎: snapchat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="9"><li>封面模式</li></ol><p>需要安装一个小插件是：hexo-less，安装指令: $ npm install –save hexo-less</p><p>该插件解决了什么问题呢？</p><p>手动设置文章概要，但不影响章内䆟。只需在文章中写 <!-- less --> 作为分割线， <!-- less --> 上面的内容会作为摘要，但不作为文章内容的一部分。</p><ol start="10"><li><p>菜单栏添加菜单选项<br>next默认菜单栏只有home和archives菜单，你可以添加更多的菜单，比如这里我们添加tags和categories。只需打开myblog/themes/next/_config.yml主题配置文件，搜索关键字Menu Settings找到如下图代码块，然后将tags和categories选项前的注释符号#去掉就能启用这两个菜单。</p></li><li><p>头像设置为圆形<br>打开站点下的myblog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl文件 ,在.site-author-image选择器的末尾（右括号前）添加</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash">border-radius: 50%<span class="token punctuation">;</span>transition: 2s all<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在.site-author-image选择器右括号后另起一行,加入以下代码：</p><pre class="line-numbers language-bash"><code class="language-bash">.site-author-image:hover<span class="token punctuation">{</span>  transform: rotate<span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者你可以看下面的代码会更加直观。</p><p>原来的：</p><pre class="line-numbers language-bash"><code class="language-bash">   .site-author-image <span class="token punctuation">{</span>  display: block<span class="token punctuation">;</span>  margin: 0 auto<span class="token punctuation">;</span>  padding: <span class="token variable">$site</span>-author-image-padding<span class="token punctuation">;</span>  max-width: <span class="token variable">$site</span>-author-image-width<span class="token punctuation">;</span>  height: <span class="token variable">$site</span>-author-image-height<span class="token punctuation">;</span>  border: <span class="token variable">$site</span>-author-image-border-width solid <span class="token variable">$site</span>-author-image-border-color<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后：</p><pre class="line-numbers language-bash"><code class="language-bash">.site-author-image <span class="token punctuation">{</span>  display: block<span class="token punctuation">;</span>  margin: 0 auto<span class="token punctuation">;</span>  padding: <span class="token variable">$site</span>-author-image-padding<span class="token punctuation">;</span>  max-width: <span class="token variable">$site</span>-author-image-width<span class="token punctuation">;</span>  height: <span class="token variable">$site</span>-author-image-height<span class="token punctuation">;</span>  border: <span class="token variable">$site</span>-author-image-border-width solid <span class="token variable">$site</span>-author-image-border-color<span class="token punctuation">;</span>  opacity: hexo-config<span class="token punctuation">(</span><span class="token string">'avatar.opacity'</span><span class="token punctuation">)</span> is a <span class="token string">'unit'</span> ? hexo-config<span class="token punctuation">(</span><span class="token string">'avatar.opacity'</span><span class="token punctuation">)</span> <span class="token keyword">:</span> 1<span class="token punctuation">;</span>  border-radius: 50%<span class="token punctuation">;</span>  transition: 2s all<span class="token punctuation">;</span><span class="token punctuation">}</span>.site-author-image:hover<span class="token punctuation">{</span>  transform: rotate<span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="12"><li>添加动态背景<br>打开myblog/themes/next/_config.yml主题配置文件，搜索关键字canvas找到如下位置：</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Canvas-nest</span><span class="token comment" spellcheck="true"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span>canvas_nest: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># JavaScript 3D library.</span><span class="token comment" spellcheck="true"># Dependencies: https://github.com/theme-next/theme-next-three</span><span class="token comment" spellcheck="true"># three_waves</span>three_waves: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># canvas_lines</span>canvas_lines: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># canvas_sphere</span>canvas_sphere: <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看你喜欢哪种动态背景风格，分别有canvas_nest、three_waves、canvas_lines、canvas_sphere四种，选择一种然后将冒号后面的false改成true。这里我选择的是第一种canvas_nest，改成如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#Canvas-nest</span><span class="token comment" spellcheck="true"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span>canvas_nest: <span class="token boolean">true</span><span class="token comment" spellcheck="true"># JavaScript 3D library.</span><span class="token comment" spellcheck="true"># Dependencies: https://github.com/theme-next/theme-next-three</span><span class="token comment" spellcheck="true"># three_waves</span>three_waves: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># canvas_lines</span>canvas_lines: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># canvas_sphere</span>canvas_sphere: <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="13"><li>增加搜索功能</li></ol><p>需要安装 hexo-generator-searchdb插件来实现这个功能，在站点的根目录下执行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-searchdb --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑myblog/_config.yml全局配置文件，新增以下内容到任意位置：</p><pre class="line-numbers language-bash"><code class="language-bash">search:  path: search.xml  field: post  format: html  limit: 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开myblog/themes/next/_config.yml主题配置文件，搜索关键字local_search找到如下代码，enable默认是false，将enable设置为true，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">local_search:  enable: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="14"><li>实现字数统计和阅读时长的功能<br>需要安装hexo-wordcount这个插件来实现这个功能，在站点根目录下打开git bash，输入：</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-wordcount --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开myblog/themes/next/_config.yml主题配置文件，搜索关键字post_wordcount。<br>将其配置修改成以下代码：</p><pre class="line-numbers language-bash"><code class="language-bash">post_wordcount:  item_text: <span class="token boolean">true</span>  wordcount: <span class="token boolean">true</span>  min2read: <span class="token boolean">true</span>  totalcount: <span class="token boolean">false</span>  separated_meta: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="15"><li><p>添加emoji</p></li><li><p>添加404</p></li><li><p>添加评论系统</p></li><li><p>添加看板娘</p></li></ol><ul><li>安装</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-helper-live2d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在站点的 _config.yml 下配置</li></ul><pre class="line-numbers language-bash"><code class="language-bash">live2d:  enable: <span class="token boolean">true</span>  scriptFrom: local  model:    use: live2d-widget-model-miku  display:    position: right    width: 150    height: 300  mobile:    show: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制代码其中，live2d.model.use使用来配置对应的萌宠模型，我这边是live2d-widget-model-miku</p><ol start="19"><li><p>插入音乐和视频</p></li><li><p>添加pdf</p></li><li><p>字数统计和阅读时长</p></li><li><p>鼠标点击特效</p></li><li><p>打字特效</p></li><li><p>代码块一键复制</p></li><li><p>个性化回到顶部</p></li><li><p>文章阅读统计及热度</p></li><li><p>设置阅读全文显示摘要图片</p></li></ol><ul><li>摘要配图，文章也有<br>在文章中使用 手动进行截断</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"zhaiyao"</span> style<span class="token operator">=</span><span class="token string">"width: 735px;height: 372px;"</span><span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"image.jpg"</span> style<span class="token operator">=</span><span class="token string">"width: 100%;height: 100%"</span> alt<span class="token operator">=</span><span class="token string">"wechat_jump_game"</span> align<span class="token operator">=</span>center /<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>摘要内容<span class="token operator">&lt;</span><span class="token operator">!</span>-- <span class="token function">more</span> --<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>摘要配图，文章没有<br>在custom.styl(hexo/themes/next/source/css/_custom/custom.styl)里设计一个专有容器</li></ul><pre class="line-numbers language-bash"><code class="language-bash">//图片外部的容器方框 .out-img-topic <span class="token punctuation">{</span>  display: block<span class="token punctuation">;</span>  max-height:300px<span class="token punctuation">;</span>  margin-bottom: 24px<span class="token punctuation">;</span>  overflow: hidden<span class="token punctuation">;</span><span class="token punctuation">}</span>//图片img.img-topic <span class="token punctuation">{</span>  display: block <span class="token punctuation">;</span>  margin-left: .7em<span class="token punctuation">;</span>  margin-right: .7em<span class="token punctuation">;</span>  padding: 0<span class="token punctuation">;</span>  float: right<span class="token punctuation">;</span>  clear: right<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里图片外部的容器用来限制图片显示的大小，最大的高度为300px，overflow: hidden;让多余部分隐藏。margin-bottom: 24px;确保图片和文章摘要部分空出一定空间。</p><p>修改/themes/next/layout/ _macro/post.swig，在if is_index与if post.description and theme.excerpt_description<br>之间添加以下代码:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">{</span>% <span class="token keyword">if</span> post.images %<span class="token punctuation">}</span>    <span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"out-img-topic"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"{{"</span> post.images<span class="token operator">=</span><span class="token string">""</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;&amp;#125;="" class="img-topic"></span>    <span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在front-matter中加一个images字段</p><pre class="line-numbers language-bash"><code class="language-bash">images: <span class="token string">"/images/摘要配图/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="28"><li>主页文章添加边框阴影效果<br>打开 themes/next/source/css/_custom/ 下的 custom.styl，向里面加代码：</li></ol><pre class="line-numbers language-bash"><code class="language-bash">.post <span class="token punctuation">{</span>   margin-top: 0px<span class="token punctuation">;</span>   margin-bottom: 60px<span class="token punctuation">;</span>   padding: 25px<span class="token punctuation">;</span>   -webkit-box-shadow: 0 0 5px rgba<span class="token punctuation">(</span>202, 203, 203, .5<span class="token punctuation">)</span><span class="token punctuation">;</span>   -moz-box-shadow: 0 0 5px rgba<span class="token punctuation">(</span>202, 203, 204, .5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="29"><li>添加背景图片<br>修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</li></ol><pre class="line-numbers language-bash"><code class="language-bash">body <span class="token punctuation">{</span>    background:url<span class="token punctuation">(</span>https://source.unsplash.com/random/1600x900<span class="token punctuation">)</span><span class="token punctuation">;</span>    background-repeat: no-repeat<span class="token punctuation">;</span>    background-attachment:fixed<span class="token punctuation">;</span>    background-position:50% 50%<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果按照上一步添加完图片之后，发现出现了另外一个大问题，整个博客背景都是透明的，只能看见图片，看不清文章文字，这样绝对不行的，办法如下，照例在上面的文件下面继续追加如下代码：</p><pre class="line-numbers language-bash"><code class="language-bash">.main-inner <span class="token punctuation">{</span>    margin-top: 60px<span class="token punctuation">;</span>    padding: 60px 60px 60px 60px<span class="token punctuation">;</span>    background: <span class="token comment" spellcheck="true">#fff;</span>    min-height: 500px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown Template</title>
      <link href="/2019/03/26/20190326-hexo-template/"/>
      <url>/2019/03/26/20190326-hexo-template/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="有道云笔记-markdown模板"><a href="#有道云笔记-markdown模板" class="headerlink" title="有道云笔记 markdown模板"></a>有道云笔记 markdown模板</h3><p>抽空把<a href="http://note.youdao.com/iyoudao/?p=2411">【简明版】有道云笔记Markdown指南</a>的图片版欢迎成了Markdown~</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/758x240-2.jpg" alt="image"></p><p>什么是Markdown？Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。</p><p><strong>有道云笔记内置Markdown编辑器和使用指南，非技术类笔记用户，千万不要被「标记」、「语言」吓到，Markdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。</strong></p><p>就是这十个不到的标记符号，却能让人<strong>优雅地沉浸式记录，专注内容而不是纠结排版</strong>，达到「心中无尘，码字入神」的境界。</p><h1 id="一、利用Markdown可以做什么？"><a href="#一、利用Markdown可以做什么？" class="headerlink" title="一、利用Markdown可以做什么？"></a>一、利用Markdown可以做什么？</h1><ol><li>代码高亮</li></ol><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-1%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.png" alt="image"></p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><pre class="line-numbers language-python"><code class="language-python">@requires_authorization<span class="token keyword">def</span> <span class="token function">somefunc</span><span class="token punctuation">(</span>param1<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> param2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''A docstring'''</span>    <span class="token keyword">if</span> param1 <span class="token operator">></span> param2<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># interesting</span>        <span class="token keyword">print</span> <span class="token string">'Greater'</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>param2<span class="token operator">-</span>param1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> NoneClass <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token operator">>></span><span class="token operator">></span> message <span class="token operator">=</span> <span class="token triple-quoted-string string">'''interpreter... prompt'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>制作待办事项To-do List</li></ol><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-2%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9.png" alt="image"></p><h3 id="To-do-List"><a href="#To-do-List" class="headerlink" title="To-do List"></a>To-do List</h3><ul><li><input checked="" disabled="" type="checkbox"> 已完成项目1<ul><li><input checked="" disabled="" type="checkbox"> 已完成事项1</li><li><input checked="" disabled="" type="checkbox"> 已完成事项2</li></ul></li><li><input disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><ol start="3"><li>表格</li></ol><h3 id="简单表格："><a href="#简单表格：" class="headerlink" title="简单表格："></a>简单表格：</h3><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-3%E8%A1%A8%E6%A0%BC.png" alt="image"></p><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 USD</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">12 USD</td><td align="center">234</td></tr></tbody></table><h3 id="复杂表格"><a href="#复杂表格" class="headerlink" title="复杂表格"></a>复杂表格</h3><p>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：<a href="http://pressbin.com/tools/excel_to_html_table/index.html%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%A0%E9%99%A4%E7%A9%BA%E6%A0%87%E8%AE%B0%E5%AF%B9%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AEcolspan%E5%92%8Crowspan%E5%B1%9E%E6%80%A7%E5%8D%B3%E5%8F%AF%E3%80%82[%E4%B8%BE%E4%BE%8B](https://blog.csdn.net/wiborgite/article/details/78044656)">http://pressbin.com/tools/excel_to_html_table/index.html，然后删除空标记对，并设置colspan和rowspan属性即可。[举例](https://blog.csdn.net/wiborgite/article/details/78044656)</a></p><ol start="4"><li>书写数学公式</li></ol><pre class="line-numbers language-bash"><code class="language-bash">pm <span class="token function">install</span> hexo-renderer-mathjax2 --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.png" alt="image"></p><h2 id="Mathematical-formula-y-x-2"><a href="#Mathematical-formula-y-x-2" class="headerlink" title="Mathematical formula $y = x^2$"></a>Mathematical formula <code>$y = x^2$</code></h2><p>Inline math: $x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$</p><p>Outline math:</p><p>This formula: $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ is an example.</p><h1 id="二、有道云笔记Markdown简明版使用指南"><a href="#二、有道云笔记Markdown简明版使用指南" class="headerlink" title="二、有道云笔记Markdown简明版使用指南"></a>二、有道云笔记Markdown简明版使用指南</h1><p><strong>0. 标题</strong></p><p>标题是每篇文章必备而且最常用的格式。</p><p>在Markdown中，如果想将一段文字定义为标题，只需要在这段文字前面加上 #，再在 # 后加一个空格即可。还可增加二、三、四、五、六级标题，总共六级，只需要增加 # ，增加一个 # ，标题字号相应降低一级。如图：</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-0-%E6%A0%87%E9%A2%98.png" alt="image"></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><strong>1. 列表</strong></p><p>列表格式也很常用，它可以让你的文稿变得井井有条。在 Markdown 中，你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li><p>列表1</p></li><li><p>列表1.1</p></li><li><p>列表1.2</p></li><li><p>列表2</p></li><li><p>列表3</p></li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li><p>列表1</p></li><li><p>列表1.1</p></li><li><p>列表1.2</p></li><li><p>列表2</p></li><li><p>列表3</p></li></ol><p><strong>2. 引用</strong></p><p>如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。</p><p>在引用文字前加上 &gt; 并与文字保留一个字符的空格，即可。</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-2%E5%BC%95%E7%94%A8.png" alt="image"></p><blockquote><p>记录， 成为更好的自己。————有道云笔记</p></blockquote><p><strong>3. 粗体和斜体</strong></p><p>Markdown 的粗体和斜体也非常简单：</p><p>用两个 * 包含一段文本就是粗体的语法；</p><p>用一个 * 包含一段文本就是斜体的语法。</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-3-%E7%B2%97%E4%BD%93%E6%96%9C%E4%BD%93.png" alt="image"></p><p><em>这是斜体</em></p><p><strong>这是粗体</strong></p><h4 id="注意：-符号与文本之间无需空格"><a href="#注意：-符号与文本之间无需空格" class="headerlink" title="注意： 符号与文本之间无需空格"></a>注意： 符号与文本之间无需空格</h4><p><strong>4. 链接和图片</strong></p><pre><code>链接：在 Markdown 中，插入链接只需要使用 [显示文本](链接地址) 即可。图片：在 Markdown 中，插入图片只需要使用 ![显示文本](图片链接地址)即可。</code></pre><p>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-4%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87.png" alt="image"></p><h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><p><a href="http://note.youdao.com/">有道云笔记官网</a></p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p><img src="http://note.youdao.com/favicon.ico" alt="有道云笔记"></p><h4 id="图片位置大小控制"><a href="#图片位置大小控制" class="headerlink" title="图片位置大小控制"></a>图片位置大小控制</h4><p align="center"><img src="https://github.com/AstronDog/blog-pic/raw/master/logo.png" alt="AstronDog" width="100"></p><h1 align="center">AstronDog</h1><a href="https://www.dogecloud.com/?ref=dplayer" target="_blank">    <img width="222px" src="https://i.imgur.com/BBKXPAp.png"></a><a href="https://console.upyun.com/register/?invite=BkLZ2Xqob" target="_blank">    <img width="222px" src="https://imgur.com/apG1uKf.png"></a><p><strong>5. 分割线</strong></p><p>分割线的语法只需要另起一行，连续输入三个星号 * 即可分割两段文字内容。</p><p>如图：</p><p><img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-5-%E5%88%86%E5%89%B2%E7%BA%BF.png" alt="image"></p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>这是第一段内容</p><hr><p>这是第二段内容</p><p>lalalla $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ lalala</p><p>lalalla $x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$ lalala</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex Usage</title>
      <link href="/2019/02/21/20190221-latex/"/>
      <url>/2019/02/21/20190221-latex/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><center>**Latex Manual**</center><br> <div class="row">    <embed src="https://astrondog.github.io/file/latex.pdf" width="100%" height="550" type="application/pdf"></div><br><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Travel Plan</title>
      <link href="/2019/02/17/20190217-trave-Italy/"/>
      <url>/2019/02/17/20190217-trave-Italy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Trip-to-Italy"><a href="#Trip-to-Italy" class="headerlink" title="Trip to Italy"></a>Trip to Italy</h3><h4 id="10th-May"><a href="#10th-May" class="headerlink" title="10th May"></a>10th May</h4><p>17:50 – 20:30,         (91 Euro/p)<br>Cologne-Madrid,  (Plane)</p><h4 id="13th-May"><a href="#13th-May" class="headerlink" title="13th May"></a>13th May</h4><p>15:55 – 18:00,         (53 Euro/p)<br>Madrid-Cagliari,         (Plane)  </p><h4 id="17th-May"><a href="#17th-May" class="headerlink" title="17th May"></a>17th May</h4><p>06:45 – 07:55,         (36 Euro/p)<br>Cagliari-Rome,          (Plane)</p><h4 id="19th-May"><a href="#19th-May" class="headerlink" title="19th May"></a>19th May</h4><p>09:50 – 12:00,         (73 Euro/p)<br>Rome-Cologne,           (Plane)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leisure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>惊艳韶华</title>
      <link href="/2019/02/16/20190216-fanghua/"/>
      <url>/2019/02/16/20190216-fanghua/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="一切景物皆情语-blush"><a href="#一切景物皆情语-blush" class="headerlink" title="一切景物皆情语 :blush:"></a>一切景物皆情语 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8">😊</span></h3><ol><li>我什么都没忘，但是有些事只适合收藏，不能说，不能想，却也不能忘。</li><li>以前见过的人啊，现在隔着山海漠不相关了。</li><li>我们坐在夜里，喝了几杯，上半夜没有月亮，所 以也没有情话。即使在黑夜里，我也看得清这一切，你欲言又止，我也没有再说。后来就散了。自律和克制没能带给我自由，却给了我更明媚的清晨。</li><li>所有的悲欢都已化为灰烬，任世间的哪一条路，我都不能再与你同行。</li><li>你不用对每个过客负责，也不用对每个路人说教。</li><li>人在饿的时候会选择不爱的食物，会在寂寞的时候选择不爱的人，因为强扭的瓜不甜，但是解渴。</li><li>真心喜欢过的人没法做朋友，因为看多几眼都还是想拥有。</li><li>我十有八九的欲言又止，在日后想来都庆幸。而绝大多数的敞开心扉在事后都追悔</li><li>有的人注定只能惊艳时光而不能温暖你的岁月</li><li>这世界本就没有任何一句话，可以让你醍醐灌顶。真正叫你醍醐灌顶的，只能是一段经历。而那句话，只是火药仓库内划燃的一根火柴。</li><li>时间美化那悸动也抚平激动。</li><li>吹灭读书灯，一身都是月。</li><li>你问人问题，她若答非所问，便已是答了，毋需再问。</li><li>久而久之，就不了了之了。</li><li>曾经以为走不出的日子，现在都回不去了。</li><li>孤独不是受到了冷落和遗弃，而是无知己，不被理解。真正的孤独者不言孤独，偶尔作些长啸，如我们看到的兽。</li><li>当黄昏靠岸，码头格外悲伤。</li><li>世上的事情都经不起推敲，一推敲，哪一件都藏着委屈。</li><li>你终于相信，生命中会出现这样一个人。就算不顾一切，就算倾其所有，就算万死不辞，你也无法和他走到最后。 </li><li>你来时冬至，但眉上风止，开口是“我来得稍稍迟”。</li><li>经一场大梦，梦中见满眼山花如翡，如见故人，喜不自胜。</li><li>纵使文章惊海内，纸上苍生而已。</li><li>每个人都有自己的沼泽，你不用拉我。</li><li>奉日月以为盟，昭天地以为鉴，啸山河以为证，敬鬼神以为凭。从此山高不阻其志，涧深不断其行，流年不毁其意，风霜不掩其情。纵然前路荆棘遍野，亦将坦然无惧仗剑随行。</li></ol><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"我要你","author":"任素汐","url":"http://ac-ANdqGl5F.clouddn.com/14bae372d1d17ebbd56d.mp3","pic":"http://ac-ANdqGl5F.clouddn.com/6937370626da45e44b6c.png","lrc":"http://ac-ANdqGl5F.clouddn.com/90ec5c7ef9041dc61ecb.lrc"}]};options.element = document.getElementById("aplayer0");var ap = new APlayer(options);window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><div id="dplayer0" class="dplayer" style="margin-bottom: 20px;"></div><script>var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":0,"theme":"#FADFA3","loop":1,"video":{"url":"http://ac-andqgl5f.clouddn.com/09c42372a4347ab48756.mp4","pic":"https://github.com/AstronDog/blog_pic/raw/master/003.jpg"}});</script><!-- dplayer used1 --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Leisure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personal </tag>
            
            <tag> Quotes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Installation for Pulsar Data Analysis</title>
      <link href="/2019/01/18/20190118-pulsar-software/"/>
      <url>/2019/01/18/20190118-pulsar-software/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="1-Ubuntu-Linux-64-bit"><a href="#1-Ubuntu-Linux-64-bit" class="headerlink" title="1. Ubuntu Linux (64-bit)"></a>1. Ubuntu Linux (64-bit)</h3><p>This guide takes you through the necessary steps required to install software for pulsar data analysis on a machine running Ubuntu Linux. These notes are based on installation onto a fresh install of Ubuntu 14.04 LTS on a 64-bit machine. Please note that for installation to be successful, the software should be installed in the order described on this page.</p><h3 id="2-Installation"><a href="#2-Installation" class="headerlink" title="2. Installation"></a>2. Installation</h3><h4 id="2-1-Define-some-environmental-variables"><a href="#2-1-Define-some-environmental-variables" class="headerlink" title="2.1 Define some environmental variables"></a>2.1 Define some environmental variables</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Path to the pulsar software installation directory e.g:</span><span class="token function">export</span> ASTROSOFT<span class="token operator">=</span>/home/<span class="token punctuation">{</span>user<span class="token punctuation">}</span>/pulsar_software<span class="token comment" spellcheck="true"># OSTYPE</span><span class="token function">export</span> OSTYPE<span class="token operator">=</span>linux<span class="token comment" spellcheck="true"># BOOST</span><span class="token function">export</span> BOOST_ROOT<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/boost_1_68_0<span class="token function">export</span> BOOST_LIB<span class="token operator">=</span><span class="token variable">$BOOST_ROOT</span>/stage/lib<span class="token comment" spellcheck="true"># PSRCAT</span><span class="token function">export</span> PSRCAT_RUNDIR<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/psrcat_tar<span class="token function">export</span> PSRCAT_FILE<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/psrcat_tar/psrcat.db<span class="token comment" spellcheck="true"># Tempo</span><span class="token function">export</span> TEMPO<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/tempo<span class="token comment" spellcheck="true"># Tempo2</span><span class="token function">export</span> TEMPO2<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/tempo2/T2runtime<span class="token comment" spellcheck="true"># PGPLOT</span><span class="token function">export</span> PGPLOT_DIR<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/pgplot_build<span class="token function">export</span> PGPLOT_DEV<span class="token operator">=</span>/xwindow<span class="token function">export</span> PGPLOT_FONT<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/pgplot_build/grfont.dat<span class="token comment" spellcheck="true"># PRESTO</span><span class="token function">export</span> PRESTO<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/presto<span class="token comment" spellcheck="true"># MULTINEST</span><span class="token function">export</span> MULTINEST_DIR<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>/TempoNest/MultiNest<span class="token comment" spellcheck="true"># LD_LIBRARY_PATH</span><span class="token function">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/usr/lib:/usr/lib/x86_64-linux-gnu:<span class="token variable">$PGPLOT_DIR</span><span class="token keyword">:</span><span class="token variable">$ASTROSOFT</span>/lib:<span class="token variable">$PRESTO</span>/lib:<span class="token variable">$PRESTO</span>/lib64:<span class="token variable">$MULTINEST_DIR</span><span class="token comment" spellcheck="true"># PATH</span><span class="token comment" spellcheck="true"># Some Presto executables match sigproc executables so keep separate -</span><span class="token comment" spellcheck="true"># all other executables are found in $ASTROSOFT/bin</span><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$ASTROSOFT</span>/bin:<span class="token variable">$PRESTO</span>/bin:<span class="token variable">$PGPLOT_DIR</span><span class="token comment" spellcheck="true"># PYTHON PATH eg.</span><span class="token function">export</span> PYTHONPATH<span class="token operator">=</span><span class="token variable">$PRESTO</span>/lib/python:<span class="token variable">$PRESTO</span>/lib64/python:/usr/lib/python2.7/site-packages/:/usr/lib64/python2.7/site-packages:<span class="token variable">$ASTROSOFT</span>/lib/python2.7/site-packages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then reload your .bashrc file and check changes are taken up:</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> ~/.bashrc$ <span class="token keyword">echo</span> <span class="token variable">$ASTROSOFT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-Install-some-dependencies"><a href="#2-2-Install-some-dependencies" class="headerlink" title="2.2 Install some dependencies"></a>2.2 Install some dependencies</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">ftp</span> <span class="token function">wget</span> csh build-essential gfortran  cvs autoconf automake libtool m4 <span class="token function">git</span> gsl-bin libgsl-dev flex bison fort77 libglib2.0-dev gnuplot gnuplot-x11 python-dev python-numpy python-scipy python-matplotlib ipython python-sympy python-nose swig libltdl-dev libltdl7 dkms <span class="token function">htop</span> <span class="token function">screen</span> xterm emacs gpicview xpdf cmake default-jre default-jdk libblas3 liblapack3 libblas-dev liblapack-dev libxext-dev libx11-dev libopenmpi-dev openmpi-bin libhdf5-openmpi-dev mpich libmpich-dev libhdf5-mpich-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-3-Build"><a href="#2-3-Build" class="headerlink" title="2.3 Build"></a>2.3 Build</h4><h5 id="ZLIB"><a href="#ZLIB" class="headerlink" title="ZLIB"></a>ZLIB</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> zlib-1.2.11/./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span><span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> curl-7.61.1/./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-ssh --with-zlib<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> git-2.19.0/./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> CFLAGS<span class="token operator">=</span>-I<span class="token variable">$ASTROSOFT</span>/include LDFLAGS<span class="token operator">=</span>-L<span class="token variable">$ASTROSOFT</span>/lib<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="LAPACK"><a href="#LAPACK" class="headerlink" title="LAPACK"></a>LAPACK</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> lapack-release/<span class="token function">make</span> PREFIX<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="BOOST"><a href="#BOOST" class="headerlink" title="BOOST"></a>BOOST</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> boost_1_68_0/./bootstrap.sh --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span>./b2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="PRF2FITS"><a href="#PRF2FITS" class="headerlink" title="PRF2FITS"></a>PRF2FITS</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> prf2fits/<span class="token function">make</span> cfgen prf2fits<span class="token function">cp</span> <span class="token punctuation">{</span>prf2fits,cfgen<span class="token punctuation">}</span> <span class="token variable">$ASTROSOFT</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="FFTW"><a href="#FFTW" class="headerlink" title="FFTW"></a>FFTW</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> fftw-<span class="token punctuation">{</span>version<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>a) single precision (for Ps</p><pre class="line-numbers language-bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --enable-float --enable-threads --enable-shared --enable-single CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC<span class="token function">make</span><span class="token function">make</span> check<span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b) double precision (for Tempo2)</p><pre class="line-numbers language-bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC<span class="token function">make</span><span class="token function">make</span> check<span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="CFITISO"><a href="#CFITISO" class="headerlink" title="CFITISO"></a>CFITISO</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> cfitsio./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC<span class="token function">make</span> shared<span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PSRCAT"><a href="#PSRCAT" class="headerlink" title="PSRCAT"></a>PSRCAT</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> psrcat_tar<span class="token function">source</span> makeit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Copy psrcat executable to $ASTROSOFT/bin:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> psrcat <span class="token variable">$ASTROSOFT</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="PGPLOT"><a href="#PGPLOT" class="headerlink" title="PGPLOT"></a>PGPLOT</h5><p>Create an empty directory (pgplot_build) alongside the pgplot-{version} directory.<br>Copy pgplot-{version}/drivers.list to the pgplot_build directory.</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> pgplot_build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Edit drivers.list as required to enable the appropriate drivers(suggest to uncomment the following lines:),</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#GIDRIV 1</span><span class="token comment" spellcheck="true">#GIDRIV 2</span><span class="token comment" spellcheck="true">#PNDRIV 1 </span><span class="token comment" spellcheck="true">#PNDRIV 2 </span><span class="token comment" spellcheck="true">#PSDRIV 1</span><span class="token comment" spellcheck="true">#PSDRIV 2</span><span class="token comment" spellcheck="true">#PSDRIV 3</span><span class="token comment" spellcheck="true">#PSDRIV 4</span><span class="token comment" spellcheck="true">#X2DRIV 0</span><span class="token comment" spellcheck="true">#XWDRIV 1</span><span class="token comment" spellcheck="true">#XWDRIV 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>then start the build:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">..</span>/pgplot/makemake <span class="token punctuation">..</span>/pgplot linux g77_gcc_aout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Edit the makefile with the following:</p><p>a) Set the fortran compiler to gfortran, and append FFLAGC and CFLAGC with -fPIC e.g:</p><pre class="line-numbers language-bash"><code class="language-bash">FCOMPL<span class="token operator">=</span>gfortranFFLAGC<span class="token operator">=</span>-fPIC -Wall -OCFLAGC<span class="token operator">=</span>-fPIC -DPG_PPU -O2 -I.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>b) Check paths to png.h, pngconf.h, zlib.h, zconf.h, and change line 882</p><pre class="line-numbers language-bash"><code class="language-bash">pndriv.o <span class="token keyword">:</span> ./png.h ./pngconf.h ./zlib.h ./zconf.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>to eg:</p><pre class="line-numbers language-bash"><code class="language-bash">pndriv.o <span class="token keyword">:</span> /usr/include/libpng12/png.h /usr/include/libpng12/pngconf.h /usr/include/zlib.h /usr/src/linux-headers-4.18.0-15/incluede/linux/zconf.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Save the file and compile it:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span class="token function">make</span> clean<span class="token function">make</span> cpgld -shared -o libcpgplot.so --whole-archive libcpgplot.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Try the PGPLOT demo:</p><pre class="line-numbers language-bash"><code class="language-bash">./pgdemo1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Press enter at the prompt.</p><h5 id="TEMPO"><a href="#TEMPO" class="headerlink" title="TEMPO"></a>TEMPO</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> tempo./prepare./configure F77<span class="token operator">=</span>gfortran --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TEMPO2"><a href="#TEMPO2" class="headerlink" title="TEMPO2"></a>TEMPO2</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> tempo2./bootstrap./configure F77<span class="token operator">=</span>gfortran --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-cfitsio-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-fftw3-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC CXXFLAGS<span class="token operator">=</span><span class="token string">"-I<span class="token variable">$ASTROSOFT</span>/include -I<span class="token variable">$PGPLOT_DIR</span>"</span> LDFLAGS<span class="token operator">=</span>-L<span class="token variable">$PGPLOT_DIR</span><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> plugins <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> plugins-install<span class="token function">make</span> unsupported<span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PSRCHIVE-with-python-interface"><a href="#PSRCHIVE-with-python-interface" class="headerlink" title="PSRCHIVE (with python interface)"></a>PSRCHIVE (with python interface)</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> psrchive./bootstrap./configure F77<span class="token operator">=</span>gfortran --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-cfitsio-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-fftw3-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --enable-shared CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC CXXFLAGS<span class="token operator">=</span><span class="token string">"-I<span class="token variable">$INC</span> -I<span class="token variable">$PGPLOT_DIR</span>"</span> LDFLAGS<span class="token operator">=</span>-L<span class="token variable">$PGPLOT_DIR</span><span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="SIGPROC-Mike-Keith’s-version"><a href="#SIGPROC-Mike-Keith’s-version" class="headerlink" title="SIGPROC (Mike Keith’s version)"></a>SIGPROC (Mike Keith’s version)</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> sigproc./bootstrap./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-cfitsio-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-fftw-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> F77<span class="token operator">=</span>gfortran CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC CPPFLAGS<span class="token operator">=</span>-I<span class="token variable">$ASTROSOFT</span>/include LDFLAGS<span class="token operator">=</span><span class="token string">"-L<span class="token variable">$ASTROSOFT</span>/lib -L<span class="token variable">$PGPLOT_DIR</span> -L/usr/lib/x86_64-linux-gnu"</span> LIBS<span class="token operator">=</span><span class="token string">"-lX11 -ltempo2pred -lpng"</span><span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="DSPSR"><a href="#DSPSR" class="headerlink" title="DSPSR"></a>DSPSR</h5><p>To select the backend support to be compiled, create a text file named ‘backends.list’ containing e.g:</p><pre class="line-numbers language-bash"><code class="language-bash">apsr asp bcpm bpsr caspsr cpsr2 cpsr dummy fits gmrt guppi kat lbadr64 lbadr lump lwa mark4 mark5 maxim mwa pdev pmdaq s2 sigproc spda1k spigot vdif<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Continue the build:</p><pre class="line-numbers language-bash"><code class="language-bash">./bootstrap./configure --prefix<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> --with-cfitsio-dir<span class="token operator">=</span><span class="token variable">$ASTROSOFT</span> F77<span class="token operator">=</span>gfortran CFLAGS<span class="token operator">=</span>-fPIC FFLAGS<span class="token operator">=</span>-fPIC LDFLAGS<span class="token operator">=</span>-L<span class="token variable">$PGPLOT_DIR</span><span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TEMPONEST"><a href="#TEMPONEST" class="headerlink" title="TEMPONEST"></a>TEMPONEST</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> TempoNest<span class="token comment" spellcheck="true"># build MultiNest</span><span class="token function">cd</span> MultiNest/<span class="token function">mv</span> Makefile MakefileMPI<span class="token function">cp</span> MakefileNoMPI Makefile<span class="token function">make</span><span class="token function">make</span> libnest3.so<span class="token function">cd</span> <span class="token punctuation">..</span>/./autogen.sh./configure CXXFLAGS<span class="token operator">=</span>-I<span class="token variable">$ASTROSOFT</span>/include LDFLAGS<span class="token operator">=</span>-L<span class="token variable">$ASTROSOFT</span>/lib<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PRESTO-v2-latest-version"><a href="#PRESTO-v2-latest-version" class="headerlink" title="PRESTO v2 (latest version)"></a>PRESTO v2 (latest version)</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> presto/src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Edit Makefile as follows:</p><p>a) Define paths to fftw and cfitsio includes and libs</p><pre class="line-numbers language-bash"><code class="language-bash">FFTINC <span class="token operator">=</span> -I<span class="token variable"><span class="token variable">$(</span>ASTROSOFT<span class="token variable">)</span></span>/includeFFTLINK <span class="token operator">=</span> -L<span class="token variable"><span class="token variable">$(</span>ASTROSOFT<span class="token variable">)</span></span>/lib -lfftw3fCFITSIOINC <span class="token operator">=</span> -I<span class="token variable"><span class="token variable">$(</span>ASTROSOFT<span class="token variable">)</span></span>/includeCFITSIOLINK <span class="token operator">=</span> -L<span class="token variable"><span class="token variable">$(</span>ASTROSOFT<span class="token variable">)</span></span>/lib -lcfitsio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>b) Add ‘-lm’ flag to CFLAGS</p><p>c) Add ‘-g -fPIC’ to FFLAGS</p><p>Continue the build:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span> makewisdom<span class="token function">make</span> prep<span class="token function">make</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Now for the python:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> <span class="token variable">$PRESTO</span>/python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Edit library and include paths in setup.py and setup_ppgplot.py e.g.:</p><pre class="line-numbers language-bash"><code class="language-bash">setup.py---extra_compile_args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"-DUSEFFTW -fPIC"</span><span class="token punctuation">]</span>include_dirs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"/home/{user}/pulsar_software/include"</span><span class="token punctuation">]</span>ppgplot_libraries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"cpgplot"</span>, <span class="token string">"pgplot"</span>, <span class="token string">"X11"</span>, <span class="token string">"png"</span>, <span class="token string">"m"</span>, <span class="token string">"gfortran"</span><span class="token punctuation">]</span>ppgplot_library_dirs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"/home/{user}/pulsar_software/pgplot_build"</span><span class="token punctuation">]</span>presto_libraries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"presto"</span>, <span class="token string">"fftw3f"</span>, <span class="token string">"m"</span><span class="token punctuation">]</span>presto_library_dirs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"/home/{user}/pulsar_software/lib"</span>,<span class="token string">"/home/{user}/pulsar_software/presto/lib"</span><span class="token punctuation">]</span>---setup_ppgplot.py---extra_compile_args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"-fPIC"</span><span class="token punctuation">]</span>ppgplot_libraries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"cpgplot"</span>, <span class="token string">"pgplot"</span>, <span class="token string">"X11"</span>, <span class="token string">"png"</span>, <span class="token string">"m"</span>, <span class="token string">"g2c"</span>, <span class="token string">"gfortran"</span><span class="token punctuation">]</span>ppgplot_library_dirs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"/home/{user}/pulsar_software/pgplot_build"</span><span class="token punctuation">]</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Continue the build:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Packages-Download"><a href="#Packages-Download" class="headerlink" title="Packages Download"></a>Packages Download</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># zlib</span>curl -L <span class="token string">"https://zlib.net/zlib-1.2.11.tar.gz"</span> -o zlib-1.2.11<span class="token punctuation">..</span>tar.gz<span class="token comment" spellcheck="true"># git</span>curl -L <span class="token string">"https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.4.tar.gz"</span> -o git-2.9.4.tar.gz<span class="token comment" spellcheck="true"># boost</span>curl -L <span class="token string">"https://dl.bintray.com/boostorg/release/1.68.0/source/boost_1_68_0.tar.gz"</span> -o boost_1_68_0.tar.gz<span class="token comment" spellcheck="true"># curl</span>curl -L <span class="token string">"https://curl.haxx.se/download/curl-7.61.1.tar.gz"</span> -o curl-7.61.1.tar.gz<span class="token comment" spellcheck="true"># calceph</span>curl -L <span class="token string">"https://www.imcce.fr/content/medias/recherche/equipes/asd/calceph/calceph-3.1.0.tar.gz"</span> -o calceph-3.1.0.tar.gz<span class="token comment" spellcheck="true"># lapack</span><span class="token function">git</span> clone https://github.com/Reference-LAPACK/lapack-release.git<span class="token comment" spellcheck="true"># psr2fits</span><span class="token function">git</span> clone https://github.com/shiningsurya/prf2fits.git<span class="token comment" spellcheck="true"># cfitsio</span>curl -L <span class="token string">"http://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio3450.tar.gz"</span> -o cfitsio3450.tar.gz <span class="token comment" spellcheck="true"># psrcat</span>curl -L <span class="token string">"http://www.atnf.csiro.au/research/pulsar/psrcat/downloads/psrcat_pkg.tar.gz"</span> -o psrcat_pkg.tar.gz<span class="token comment" spellcheck="true"># fftw</span>curl -L <span class="token string">"http://www.fftw.org/fftw-3.3.8.tar.gz"</span> -o fftw-3.3.8.tar.gz<span class="token comment" spellcheck="true"># pgplot</span>curl -L <span class="token string">"ftp://ftp.astro.caltech.edu/pub/pgplot/pgplot5.2.tar.gz"</span> -o pgplot5.2.tar.gz<span class="token comment" spellcheck="true"># psrchive</span><span class="token function">git</span> clone git://git.code.sf.net/p/psrchive/code psrchive<span class="token comment" spellcheck="true"># tempo</span><span class="token function">git</span> clone git://git.code.sf.net/p/tempo/tempo<span class="token comment" spellcheck="true"># tempo2</span><span class="token function">git</span> clone https://bitbucket.org/psrsoft/tempo2.git<span class="token comment" spellcheck="true"># presto</span><span class="token function">git</span> clone git://github.com/scottransom/presto.git<span class="token comment" spellcheck="true"># dspsr</span><span class="token function">git</span> clone git://git.code.sf.net/p/dspsr/code dspsr<span class="token comment" spellcheck="true"># tempoNest</span><span class="token function">git</span> clone https://github.com/LindleyLentati/TempoNest.git<span class="token comment" spellcheck="true"># Mike Keith's version of sigproc which handles PSRFITS format files:</span><span class="token function">git</span> clone https://github.com/SixByNine/sigproc.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pulsar </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20181115 Bielefeld</title>
      <link href="/2018/11/15/20181115-Bielefeld/"/>
      <url>/2018/11/15/20181115-Bielefeld/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><center>**Slides for 2018 EPTA Autumn Meeting in Bielefeld**</center><br> <div class="row">    <embed src="https://astrondog.github.io/file/20181113_EPTA_Bielefeld.pdf" width="100%" height="550" type="application/pdf"></div><br><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
            <tag> Meeting </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
